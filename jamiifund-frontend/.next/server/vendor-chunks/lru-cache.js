"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/lru-cache";
exports.ids = ["vendor-chunks/lru-cache"];
exports.modules = {

/***/ "(ssr)/./node_modules/lru-cache/dist/esm/index.js":
/*!**************************************************!*\
  !*** ./node_modules/lru-cache/dist/esm/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LRUCache: () => (/* binding */ LRUCache)\n/* harmony export */ });\n/**\n * @module LRUCache\n */ const perf = typeof performance === \"object\" && performance && typeof performance.now === \"function\" ? performance : Date;\nconst warned = new Set();\n/* c8 ignore start */ const PROCESS = typeof process === \"object\" && !!process ? process : {};\n/* c8 ignore start */ const emitWarning = (msg, type, code, fn)=>{\n    typeof PROCESS.emitWarning === \"function\" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);\n};\nlet AC = globalThis.AbortController;\nlet AS = globalThis.AbortSignal;\n/* c8 ignore start */ if (typeof AC === \"undefined\") {\n    //@ts-ignore\n    AS = class AbortSignal {\n        addEventListener(_, fn) {\n            this._onabort.push(fn);\n        }\n        constructor(){\n            this._onabort = [];\n            this.aborted = false;\n        }\n    };\n    //@ts-ignore\n    AC = class AbortController {\n        constructor(){\n            this.signal = new AS();\n            warnACPolyfill();\n        }\n        abort(reason) {\n            if (this.signal.aborted) return;\n            //@ts-ignore\n            this.signal.reason = reason;\n            //@ts-ignore\n            this.signal.aborted = true;\n            //@ts-ignore\n            for (const fn of this.signal._onabort){\n                fn(reason);\n            }\n            this.signal.onabort?.(reason);\n        }\n    };\n    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== \"1\";\n    const warnACPolyfill = ()=>{\n        if (!printACPolyfillWarning) return;\n        printACPolyfillWarning = false;\n        emitWarning(\"AbortController is not defined. If using lru-cache in \" + \"node 14, load an AbortController polyfill from the \" + \"`node-abort-controller` package. A minimal polyfill is \" + \"provided for use by LRUCache.fetch(), but it should not be \" + \"relied upon in other contexts (eg, passing it to other APIs that \" + \"use AbortController/AbortSignal might have undesirable effects). \" + \"You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.\", \"NO_ABORT_CONTROLLER\", \"ENOTSUP\", warnACPolyfill);\n    };\n}\n/* c8 ignore stop */ const shouldWarn = (code)=>!warned.has(code);\nconst TYPE = Symbol(\"type\");\nconst isPosInt = (n)=>n && n === Math.floor(n) && n > 0 && isFinite(n);\n/* c8 ignore start */ // This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max)=>!isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;\n/* c8 ignore stop */ class ZeroArray extends Array {\n    constructor(size){\n        super(size);\n        this.fill(0);\n    }\n}\nclass Stack {\n    // private constructor\n    static #constructing = false;\n    static create(max) {\n        const HeapCls = getUintArray(max);\n        if (!HeapCls) return [];\n        Stack.#constructing = true;\n        const s = new Stack(max, HeapCls);\n        Stack.#constructing = false;\n        return s;\n    }\n    constructor(max, HeapCls){\n        /* c8 ignore start */ if (!Stack.#constructing) {\n            throw new TypeError(\"instantiate Stack using Stack.create(n)\");\n        }\n        /* c8 ignore stop */ this.heap = new HeapCls(max);\n        this.length = 0;\n    }\n    push(n) {\n        this.heap[this.length++] = n;\n    }\n    pop() {\n        return this.heap[--this.length];\n    }\n}\nlet prop;\n/**\n * Default export, the thing you're using this module to get.\n *\n * The `K` and `V` types define the key and value types, respectively. The\n * optional `FC` type defines the type of the `context` object passed to\n * `cache.fetch()` and `cache.memo()`.\n *\n * Keys and values **must not** be `null` or `undefined`.\n *\n * All properties from the options object (with the exception of `max`,\n * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are\n * added as normal public members. (The listed options are read-only getters.)\n *\n * Changing any of these will alter the defaults for subsequent method calls.\n */ class LRUCache {\n    static{\n        prop = Symbol.toStringTag;\n    }\n    // options that cannot be changed without disaster\n    #max;\n    #maxSize;\n    #dispose;\n    #disposeAfter;\n    #fetchMethod;\n    #memoMethod;\n    // computed properties\n    #size;\n    #calculatedSize;\n    #keyMap;\n    #keyList;\n    #valList;\n    #next;\n    #prev;\n    #head;\n    #tail;\n    #free;\n    #disposed;\n    #sizes;\n    #starts;\n    #ttls;\n    #hasDispose;\n    #hasFetchMethod;\n    #hasDisposeAfter;\n    /**\n     * Do not call this method unless you need to inspect the\n     * inner workings of the cache.  If anything returned by this\n     * object is modified in any way, strange breakage may occur.\n     *\n     * These fields are private for a reason!\n     *\n     * @internal\n     */ static unsafeExposeInternals(c) {\n        return {\n            // properties\n            starts: c.#starts,\n            ttls: c.#ttls,\n            sizes: c.#sizes,\n            keyMap: c.#keyMap,\n            keyList: c.#keyList,\n            valList: c.#valList,\n            next: c.#next,\n            prev: c.#prev,\n            get head () {\n                return c.#head;\n            },\n            get tail () {\n                return c.#tail;\n            },\n            free: c.#free,\n            // methods\n            isBackgroundFetch: (p)=>c.#isBackgroundFetch(p),\n            backgroundFetch: (k, index, options, context)=>c.#backgroundFetch(k, index, options, context),\n            moveToTail: (index)=>c.#moveToTail(index),\n            indexes: (options)=>c.#indexes(options),\n            rindexes: (options)=>c.#rindexes(options),\n            isStale: (index)=>c.#isStale(index)\n        };\n    }\n    // Protected read-only members\n    /**\n     * {@link LRUCache.OptionsBase.max} (read-only)\n     */ get max() {\n        return this.#max;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.maxSize} (read-only)\n     */ get maxSize() {\n        return this.#maxSize;\n    }\n    /**\n     * The total computed size of items in the cache (read-only)\n     */ get calculatedSize() {\n        return this.#calculatedSize;\n    }\n    /**\n     * The number of items stored in the cache (read-only)\n     */ get size() {\n        return this.#size;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n     */ get fetchMethod() {\n        return this.#fetchMethod;\n    }\n    get memoMethod() {\n        return this.#memoMethod;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.dispose} (read-only)\n     */ get dispose() {\n        return this.#dispose;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n     */ get disposeAfter() {\n        return this.#disposeAfter;\n    }\n    constructor(options){\n        // conditionally set private methods related to TTL\n        this.#updateItemAge = ()=>{};\n        this.#statusTTL = ()=>{};\n        this.#setItemTTL = ()=>{};\n        /* c8 ignore stop */ this.#isStale = ()=>false;\n        this.#removeItemSize = (_i)=>{};\n        this.#addItemSize = (_i, _s, _st)=>{};\n        this.#requireSize = (_k, _v, size, sizeCalculation)=>{\n            if (size || sizeCalculation) {\n                throw new TypeError(\"cannot set size without setting maxSize or maxEntrySize on cache\");\n            }\n            return 0;\n        };\n        /**\n     * A String value that is used in the creation of the default string\n     * description of an object. Called by the built-in method\n     * `Object.prototype.toString`.\n     */ this[prop] = \"LRUCache\";\n        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;\n        if (max !== 0 && !isPosInt(max)) {\n            throw new TypeError(\"max option must be a nonnegative integer\");\n        }\n        const UintArray = max ? getUintArray(max) : Array;\n        if (!UintArray) {\n            throw new Error(\"invalid max value: \" + max);\n        }\n        this.#max = max;\n        this.#maxSize = maxSize;\n        this.maxEntrySize = maxEntrySize || this.#maxSize;\n        this.sizeCalculation = sizeCalculation;\n        if (this.sizeCalculation) {\n            if (!this.#maxSize && !this.maxEntrySize) {\n                throw new TypeError(\"cannot set sizeCalculation without setting maxSize or maxEntrySize\");\n            }\n            if (typeof this.sizeCalculation !== \"function\") {\n                throw new TypeError(\"sizeCalculation set to non-function\");\n            }\n        }\n        if (memoMethod !== undefined && typeof memoMethod !== \"function\") {\n            throw new TypeError(\"memoMethod must be a function if defined\");\n        }\n        this.#memoMethod = memoMethod;\n        if (fetchMethod !== undefined && typeof fetchMethod !== \"function\") {\n            throw new TypeError(\"fetchMethod must be a function if specified\");\n        }\n        this.#fetchMethod = fetchMethod;\n        this.#hasFetchMethod = !!fetchMethod;\n        this.#keyMap = new Map();\n        this.#keyList = new Array(max).fill(undefined);\n        this.#valList = new Array(max).fill(undefined);\n        this.#next = new UintArray(max);\n        this.#prev = new UintArray(max);\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free = Stack.create(max);\n        this.#size = 0;\n        this.#calculatedSize = 0;\n        if (typeof dispose === \"function\") {\n            this.#dispose = dispose;\n        }\n        if (typeof disposeAfter === \"function\") {\n            this.#disposeAfter = disposeAfter;\n            this.#disposed = [];\n        } else {\n            this.#disposeAfter = undefined;\n            this.#disposed = undefined;\n        }\n        this.#hasDispose = !!this.#dispose;\n        this.#hasDisposeAfter = !!this.#disposeAfter;\n        this.noDisposeOnSet = !!noDisposeOnSet;\n        this.noUpdateTTL = !!noUpdateTTL;\n        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;\n        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;\n        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;\n        this.ignoreFetchAbort = !!ignoreFetchAbort;\n        // NB: maxEntrySize is set to maxSize if it's set\n        if (this.maxEntrySize !== 0) {\n            if (this.#maxSize !== 0) {\n                if (!isPosInt(this.#maxSize)) {\n                    throw new TypeError(\"maxSize must be a positive integer if specified\");\n                }\n            }\n            if (!isPosInt(this.maxEntrySize)) {\n                throw new TypeError(\"maxEntrySize must be a positive integer if specified\");\n            }\n            this.#initializeSizeTracking();\n        }\n        this.allowStale = !!allowStale;\n        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;\n        this.updateAgeOnGet = !!updateAgeOnGet;\n        this.updateAgeOnHas = !!updateAgeOnHas;\n        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;\n        this.ttlAutopurge = !!ttlAutopurge;\n        this.ttl = ttl || 0;\n        if (this.ttl) {\n            if (!isPosInt(this.ttl)) {\n                throw new TypeError(\"ttl must be a positive integer if specified\");\n            }\n            this.#initializeTTLTracking();\n        }\n        // do not allow completely unbounded caches\n        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n            throw new TypeError(\"At least one of max, maxSize, or ttl is required\");\n        }\n        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n            const code = \"LRU_CACHE_UNBOUNDED\";\n            if (shouldWarn(code)) {\n                warned.add(code);\n                const msg = \"TTL caching without ttlAutopurge, max, or maxSize can \" + \"result in unbounded memory consumption.\";\n                emitWarning(msg, \"UnboundedCacheWarning\", code, LRUCache);\n            }\n        }\n    }\n    /**\n     * Return the number of ms left in the item's TTL. If item is not in cache,\n     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.\n     */ getRemainingTTL(key) {\n        return this.#keyMap.has(key) ? Infinity : 0;\n    }\n    #initializeTTLTracking() {\n        const ttls = new ZeroArray(this.#max);\n        const starts = new ZeroArray(this.#max);\n        this.#ttls = ttls;\n        this.#starts = starts;\n        this.#setItemTTL = (index, ttl, start = perf.now())=>{\n            starts[index] = ttl !== 0 ? start : 0;\n            ttls[index] = ttl;\n            if (ttl !== 0 && this.ttlAutopurge) {\n                const t = setTimeout(()=>{\n                    if (this.#isStale(index)) {\n                        this.#delete(this.#keyList[index], \"expire\");\n                    }\n                }, ttl + 1);\n                // unref() not supported on all platforms\n                /* c8 ignore start */ if (t.unref) {\n                    t.unref();\n                }\n            /* c8 ignore stop */ }\n        };\n        this.#updateItemAge = (index)=>{\n            starts[index] = ttls[index] !== 0 ? perf.now() : 0;\n        };\n        this.#statusTTL = (status, index)=>{\n            if (ttls[index]) {\n                const ttl = ttls[index];\n                const start = starts[index];\n                /* c8 ignore next */ if (!ttl || !start) return;\n                status.ttl = ttl;\n                status.start = start;\n                status.now = cachedNow || getNow();\n                const age = status.now - start;\n                status.remainingTTL = ttl - age;\n            }\n        };\n        // debounce calls to perf.now() to 1s so we're not hitting\n        // that costly call repeatedly.\n        let cachedNow = 0;\n        const getNow = ()=>{\n            const n = perf.now();\n            if (this.ttlResolution > 0) {\n                cachedNow = n;\n                const t = setTimeout(()=>cachedNow = 0, this.ttlResolution);\n                // not available on all platforms\n                /* c8 ignore start */ if (t.unref) {\n                    t.unref();\n                }\n            /* c8 ignore stop */ }\n            return n;\n        };\n        this.getRemainingTTL = (key)=>{\n            const index = this.#keyMap.get(key);\n            if (index === undefined) {\n                return 0;\n            }\n            const ttl = ttls[index];\n            const start = starts[index];\n            if (!ttl || !start) {\n                return Infinity;\n            }\n            const age = (cachedNow || getNow()) - start;\n            return ttl - age;\n        };\n        this.#isStale = (index)=>{\n            const s = starts[index];\n            const t = ttls[index];\n            return !!t && !!s && (cachedNow || getNow()) - s > t;\n        };\n    }\n    #updateItemAge;\n    #statusTTL;\n    #setItemTTL;\n    #isStale;\n    #initializeSizeTracking() {\n        const sizes = new ZeroArray(this.#max);\n        this.#calculatedSize = 0;\n        this.#sizes = sizes;\n        this.#removeItemSize = (index)=>{\n            this.#calculatedSize -= sizes[index];\n            sizes[index] = 0;\n        };\n        this.#requireSize = (k, v, size, sizeCalculation)=>{\n            // provisionally accept background fetches.\n            // actual value size will be checked when they return.\n            if (this.#isBackgroundFetch(v)) {\n                return 0;\n            }\n            if (!isPosInt(size)) {\n                if (sizeCalculation) {\n                    if (typeof sizeCalculation !== \"function\") {\n                        throw new TypeError(\"sizeCalculation must be a function\");\n                    }\n                    size = sizeCalculation(v, k);\n                    if (!isPosInt(size)) {\n                        throw new TypeError(\"sizeCalculation return invalid (expect positive integer)\");\n                    }\n                } else {\n                    throw new TypeError(\"invalid size value (must be positive integer). \" + \"When maxSize or maxEntrySize is used, sizeCalculation \" + \"or size must be set.\");\n                }\n            }\n            return size;\n        };\n        this.#addItemSize = (index, size, status)=>{\n            sizes[index] = size;\n            if (this.#maxSize) {\n                const maxSize = this.#maxSize - sizes[index];\n                while(this.#calculatedSize > maxSize){\n                    this.#evict(true);\n                }\n            }\n            this.#calculatedSize += sizes[index];\n            if (status) {\n                status.entrySize = size;\n                status.totalCalculatedSize = this.#calculatedSize;\n            }\n        };\n    }\n    #removeItemSize;\n    #addItemSize;\n    #requireSize;\n    *#indexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for(let i = this.#tail; true;){\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#head) {\n                    break;\n                } else {\n                    i = this.#prev[i];\n                }\n            }\n        }\n    }\n    *#rindexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for(let i = this.#head; true;){\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#tail) {\n                    break;\n                } else {\n                    i = this.#next[i];\n                }\n            }\n        }\n    }\n    #isValidIndex(index) {\n        return index !== undefined && this.#keyMap.get(this.#keyList[index]) === index;\n    }\n    /**\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from most recently used to least recently used.\n     */ *entries() {\n        for (const i of this.#indexes()){\n            if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [\n                    this.#keyList[i],\n                    this.#valList[i]\n                ];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.entries}\n     *\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from least recently used to most recently used.\n     */ *rentries() {\n        for (const i of this.#rindexes()){\n            if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [\n                    this.#keyList[i],\n                    this.#valList[i]\n                ];\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the keys in the cache,\n     * in order from most recently used to least recently used.\n     */ *keys() {\n        for (const i of this.#indexes()){\n            const k = this.#keyList[i];\n            if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.keys}\n     *\n     * Return a generator yielding the keys in the cache,\n     * in order from least recently used to most recently used.\n     */ *rkeys() {\n        for (const i of this.#rindexes()){\n            const k = this.#keyList[i];\n            if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the values in the cache,\n     * in order from most recently used to least recently used.\n     */ *values() {\n        for (const i of this.#indexes()){\n            const v = this.#valList[i];\n            if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.values}\n     *\n     * Return a generator yielding the values in the cache,\n     * in order from least recently used to most recently used.\n     */ *rvalues() {\n        for (const i of this.#rindexes()){\n            const v = this.#valList[i];\n            if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Iterating over the cache itself yields the same results as\n     * {@link LRUCache.entries}\n     */ [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * Find a value for which the supplied fn method returns a truthy value,\n     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.\n     */ find(fn, getOptions = {}) {\n        for (const i of this.#indexes()){\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n            if (value === undefined) continue;\n            if (fn(value, this.#keyList[i], this)) {\n                return this.get(this.#keyList[i], getOptions);\n            }\n        }\n    }\n    /**\n     * Call the supplied function on each item in the cache, in order from most\n     * recently used to least recently used.\n     *\n     * `fn` is called as `fn(value, key, cache)`.\n     *\n     * If `thisp` is provided, function will be called in the `this`-context of\n     * the provided object, or the cache if no `thisp` object is provided.\n     *\n     * Does not update age or recenty of use, or iterate over stale values.\n     */ forEach(fn, thisp = this) {\n        for (const i of this.#indexes()){\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n            if (value === undefined) continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * The same as {@link LRUCache.forEach} but items are iterated over in\n     * reverse order.  (ie, less recently used items are iterated over first.)\n     */ rforEach(fn, thisp = this) {\n        for (const i of this.#rindexes()){\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n            if (value === undefined) continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * Delete any stale entries. Returns true if anything was removed,\n     * false otherwise.\n     */ purgeStale() {\n        let deleted = false;\n        for (const i of this.#rindexes({\n            allowStale: true\n        })){\n            if (this.#isStale(i)) {\n                this.#delete(this.#keyList[i], \"expire\");\n                deleted = true;\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Get the extended info about a given entry, to get its value, size, and\n     * TTL info simultaneously. Returns `undefined` if the key is not present.\n     *\n     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive\n     * serialization, the `start` value is always the current timestamp, and the\n     * `ttl` is a calculated remaining time to live (negative if expired).\n     *\n     * Always returns stale values, if their info is found in the cache, so be\n     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})\n     * if relevant.\n     */ info(key) {\n        const i = this.#keyMap.get(key);\n        if (i === undefined) return undefined;\n        const v = this.#valList[i];\n        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n        if (value === undefined) return undefined;\n        const entry = {\n            value\n        };\n        if (this.#ttls && this.#starts) {\n            const ttl = this.#ttls[i];\n            const start = this.#starts[i];\n            if (ttl && start) {\n                const remain = ttl - (perf.now() - start);\n                entry.ttl = remain;\n                entry.start = Date.now();\n            }\n        }\n        if (this.#sizes) {\n            entry.size = this.#sizes[i];\n        }\n        return entry;\n    }\n    /**\n     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n     * passed to {@link LRLUCache#load}.\n     *\n     * The `start` fields are calculated relative to a portable `Date.now()`\n     * timestamp, even if `performance.now()` is available.\n     *\n     * Stale entries are always included in the `dump`, even if\n     * {@link LRUCache.OptionsBase.allowStale} is false.\n     *\n     * Note: this returns an actual array, not a generator, so it can be more\n     * easily passed around.\n     */ dump() {\n        const arr = [];\n        for (const i of this.#indexes({\n            allowStale: true\n        })){\n            const key = this.#keyList[i];\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n            if (value === undefined || key === undefined) continue;\n            const entry = {\n                value\n            };\n            if (this.#ttls && this.#starts) {\n                entry.ttl = this.#ttls[i];\n                // always dump the start relative to a portable timestamp\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = perf.now() - this.#starts[i];\n                entry.start = Math.floor(Date.now() - age);\n            }\n            if (this.#sizes) {\n                entry.size = this.#sizes[i];\n            }\n            arr.unshift([\n                key,\n                entry\n            ]);\n        }\n        return arr;\n    }\n    /**\n     * Reset the cache and load in the items in entries in the order listed.\n     *\n     * The shape of the resulting cache may be different if the same options are\n     * not used in both caches.\n     *\n     * The `start` fields are assumed to be calculated relative to a portable\n     * `Date.now()` timestamp, even if `performance.now()` is available.\n     */ load(arr) {\n        this.clear();\n        for (const [key, entry] of arr){\n            if (entry.start) {\n                // entry.start is a portable timestamp, but we may be using\n                // node's performance.now(), so calculate the offset, so that\n                // we get the intended remaining TTL, no matter how long it's\n                // been on ice.\n                //\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = Date.now() - entry.start;\n                entry.start = perf.now() - age;\n            }\n            this.set(key, entry.value, entry);\n        }\n    }\n    /**\n     * Add a value to the cache.\n     *\n     * Note: if `undefined` is specified as a value, this is an alias for\n     * {@link LRUCache#delete}\n     *\n     * Fields on the {@link LRUCache.SetOptions} options param will override\n     * their corresponding values in the constructor options for the scope\n     * of this single `set()` operation.\n     *\n     * If `start` is provided, then that will set the effective start\n     * time for the TTL calculation. Note that this must be a previous\n     * value of `performance.now()` if supported, or a previous value of\n     * `Date.now()` if not.\n     *\n     * Options object may also include `size`, which will prevent\n     * calling the `sizeCalculation` function and just use the specified\n     * number if it is a positive integer, and `noDisposeOnSet` which\n     * will prevent calling a `dispose` function in the case of\n     * overwrites.\n     *\n     * If the `size` (or return value of `sizeCalculation`) for a given\n     * entry is greater than `maxEntrySize`, then the item will not be\n     * added to the cache.\n     *\n     * Will update the recency of the entry.\n     *\n     * If the value is `undefined`, then this is an alias for\n     * `cache.delete(key)`. `undefined` is never stored in the cache.\n     */ set(k, v, setOptions = {}) {\n        if (v === undefined) {\n            this.delete(k);\n            return this;\n        }\n        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;\n        let { noUpdateTTL = this.noUpdateTTL } = setOptions;\n        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);\n        // if the item doesn't fit, don't do anything\n        // NB: maxEntrySize set to maxSize by default\n        if (this.maxEntrySize && size > this.maxEntrySize) {\n            if (status) {\n                status.set = \"miss\";\n                status.maxEntrySizeExceeded = true;\n            }\n            // have to delete, in case something is there already.\n            this.#delete(k, \"set\");\n            return this;\n        }\n        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);\n        if (index === undefined) {\n            // addition\n            index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;\n            this.#keyList[index] = k;\n            this.#valList[index] = v;\n            this.#keyMap.set(k, index);\n            this.#next[this.#tail] = index;\n            this.#prev[index] = this.#tail;\n            this.#tail = index;\n            this.#size++;\n            this.#addItemSize(index, size, status);\n            if (status) status.set = \"add\";\n            noUpdateTTL = false;\n        } else {\n            // update\n            this.#moveToTail(index);\n            const oldVal = this.#valList[index];\n            if (v !== oldVal) {\n                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n                    oldVal.__abortController.abort(new Error(\"replaced\"));\n                    const { __staleWhileFetching: s } = oldVal;\n                    if (s !== undefined && !noDisposeOnSet) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(s, k, \"set\");\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([\n                                s,\n                                k,\n                                \"set\"\n                            ]);\n                        }\n                    }\n                } else if (!noDisposeOnSet) {\n                    if (this.#hasDispose) {\n                        this.#dispose?.(oldVal, k, \"set\");\n                    }\n                    if (this.#hasDisposeAfter) {\n                        this.#disposed?.push([\n                            oldVal,\n                            k,\n                            \"set\"\n                        ]);\n                    }\n                }\n                this.#removeItemSize(index);\n                this.#addItemSize(index, size, status);\n                this.#valList[index] = v;\n                if (status) {\n                    status.set = \"replace\";\n                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;\n                    if (oldValue !== undefined) status.oldValue = oldValue;\n                }\n            } else if (status) {\n                status.set = \"update\";\n            }\n        }\n        if (ttl !== 0 && !this.#ttls) {\n            this.#initializeTTLTracking();\n        }\n        if (this.#ttls) {\n            if (!noUpdateTTL) {\n                this.#setItemTTL(index, ttl, start);\n            }\n            if (status) this.#statusTTL(status, index);\n        }\n        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while(task = dt?.shift()){\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return this;\n    }\n    /**\n     * Evict the least recently used item, returning its value or\n     * `undefined` if cache is empty.\n     */ pop() {\n        try {\n            while(this.#size){\n                const val = this.#valList[this.#head];\n                this.#evict(true);\n                if (this.#isBackgroundFetch(val)) {\n                    if (val.__staleWhileFetching) {\n                        return val.__staleWhileFetching;\n                    }\n                } else if (val !== undefined) {\n                    return val;\n                }\n            }\n        } finally{\n            if (this.#hasDisposeAfter && this.#disposed) {\n                const dt = this.#disposed;\n                let task;\n                while(task = dt?.shift()){\n                    this.#disposeAfter?.(...task);\n                }\n            }\n        }\n    }\n    #evict(free) {\n        const head = this.#head;\n        const k = this.#keyList[head];\n        const v = this.#valList[head];\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error(\"evicted\"));\n        } else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n                this.#dispose?.(v, k, \"evict\");\n            }\n            if (this.#hasDisposeAfter) {\n                this.#disposed?.push([\n                    v,\n                    k,\n                    \"evict\"\n                ]);\n            }\n        }\n        this.#removeItemSize(head);\n        // if we aren't about to use the index, then null these out\n        if (free) {\n            this.#keyList[head] = undefined;\n            this.#valList[head] = undefined;\n            this.#free.push(head);\n        }\n        if (this.#size === 1) {\n            this.#head = this.#tail = 0;\n            this.#free.length = 0;\n        } else {\n            this.#head = this.#next[head];\n        }\n        this.#keyMap.delete(k);\n        this.#size--;\n        return head;\n    }\n    /**\n     * Check if a key is in the cache, without updating the recency of use.\n     * Will return false if the item is stale, even though it is technically\n     * in the cache.\n     *\n     * Check if a key is in the cache, without updating the recency of\n     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set\n     * to `true` in either the options or the constructor.\n     *\n     * Will return `false` if the item is stale, even though it is technically in\n     * the cache. The difference can be determined (if it matters) by using a\n     * `status` argument, and inspecting the `has` field.\n     *\n     * Will not update item age unless\n     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n     */ has(k, hasOptions = {}) {\n        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === undefined) {\n                return false;\n            }\n            if (!this.#isStale(index)) {\n                if (updateAgeOnHas) {\n                    this.#updateItemAge(index);\n                }\n                if (status) {\n                    status.has = \"hit\";\n                    this.#statusTTL(status, index);\n                }\n                return true;\n            } else if (status) {\n                status.has = \"stale\";\n                this.#statusTTL(status, index);\n            }\n        } else if (status) {\n            status.has = \"miss\";\n        }\n        return false;\n    }\n    /**\n     * Like {@link LRUCache#get} but doesn't update recency or delete stale\n     * items.\n     *\n     * Returns `undefined` if the item is stale, unless\n     * {@link LRUCache.OptionsBase.allowStale} is set.\n     */ peek(k, peekOptions = {}) {\n        const { allowStale = this.allowStale } = peekOptions;\n        const index = this.#keyMap.get(k);\n        if (index === undefined || !allowStale && this.#isStale(index)) {\n            return;\n        }\n        const v = this.#valList[index];\n        // either stale and allowed, or forcing a refresh of non-stale value\n        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n    }\n    #backgroundFetch(k, index, options, context) {\n        const v = index === undefined ? undefined : this.#valList[index];\n        if (this.#isBackgroundFetch(v)) {\n            return v;\n        }\n        const ac = new AC();\n        const { signal } = options;\n        // when/if our AC signals, then stop listening to theirs.\n        signal?.addEventListener(\"abort\", ()=>ac.abort(signal.reason), {\n            signal: ac.signal\n        });\n        const fetchOpts = {\n            signal: ac.signal,\n            options,\n            context\n        };\n        const cb = (v, updateCache = false)=>{\n            const { aborted } = ac.signal;\n            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;\n            if (options.status) {\n                if (aborted && !updateCache) {\n                    options.status.fetchAborted = true;\n                    options.status.fetchError = ac.signal.reason;\n                    if (ignoreAbort) options.status.fetchAbortIgnored = true;\n                } else {\n                    options.status.fetchResolved = true;\n                }\n            }\n            if (aborted && !ignoreAbort && !updateCache) {\n                return fetchFail(ac.signal.reason);\n            }\n            // either we didn't abort, and are still here, or we did, and ignored\n            const bf = p;\n            if (this.#valList[index] === p) {\n                if (v === undefined) {\n                    if (bf.__staleWhileFetching) {\n                        this.#valList[index] = bf.__staleWhileFetching;\n                    } else {\n                        this.#delete(k, \"fetch\");\n                    }\n                } else {\n                    if (options.status) options.status.fetchUpdated = true;\n                    this.set(k, v, fetchOpts.options);\n                }\n            }\n            return v;\n        };\n        const eb = (er)=>{\n            if (options.status) {\n                options.status.fetchRejected = true;\n                options.status.fetchError = er;\n            }\n            return fetchFail(er);\n        };\n        const fetchFail = (er)=>{\n            const { aborted } = ac.signal;\n            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;\n            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;\n            const noDelete = allowStale || options.noDeleteOnFetchRejection;\n            const bf = p;\n            if (this.#valList[index] === p) {\n                // if we allow stale on fetch rejections, then we need to ensure that\n                // the stale value is not removed from the cache when the fetch fails.\n                const del = !noDelete || bf.__staleWhileFetching === undefined;\n                if (del) {\n                    this.#delete(k, \"fetch\");\n                } else if (!allowStaleAborted) {\n                    // still replace the *promise* with the stale value,\n                    // since we are done with the promise at this point.\n                    // leave it untouched if we're still waiting for an\n                    // aborted background fetch that hasn't yet returned.\n                    this.#valList[index] = bf.__staleWhileFetching;\n                }\n            }\n            if (allowStale) {\n                if (options.status && bf.__staleWhileFetching !== undefined) {\n                    options.status.returnedStale = true;\n                }\n                return bf.__staleWhileFetching;\n            } else if (bf.__returned === bf) {\n                throw er;\n            }\n        };\n        const pcall = (res, rej)=>{\n            const fmp = this.#fetchMethod?.(k, v, fetchOpts);\n            if (fmp && fmp instanceof Promise) {\n                fmp.then((v)=>res(v === undefined ? undefined : v), rej);\n            }\n            // ignored, we go until we finish, regardless.\n            // defer check until we are actually aborting,\n            // so fetchMethod can override.\n            ac.signal.addEventListener(\"abort\", ()=>{\n                if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {\n                    res(undefined);\n                    // when it eventually resolves, update the cache.\n                    if (options.allowStaleOnFetchAbort) {\n                        res = (v)=>cb(v, true);\n                    }\n                }\n            });\n        };\n        if (options.status) options.status.fetchDispatched = true;\n        const p = new Promise(pcall).then(cb, eb);\n        const bf = Object.assign(p, {\n            __abortController: ac,\n            __staleWhileFetching: v,\n            __returned: undefined\n        });\n        if (index === undefined) {\n            // internal, don't expose status.\n            this.set(k, bf, {\n                ...fetchOpts.options,\n                status: undefined\n            });\n            index = this.#keyMap.get(k);\n        } else {\n            this.#valList[index] = bf;\n        }\n        return bf;\n    }\n    #isBackgroundFetch(p) {\n        if (!this.#hasFetchMethod) return false;\n        const b = p;\n        return !!b && b instanceof Promise && b.hasOwnProperty(\"__staleWhileFetching\") && b.__abortController instanceof AC;\n    }\n    async fetch(k, fetchOptions = {}) {\n        const { // get options\n        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, // set options\n        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, // fetch exclusive options\n        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal } = fetchOptions;\n        if (!this.#hasFetchMethod) {\n            if (status) status.fetch = \"get\";\n            return this.get(k, {\n                allowStale,\n                updateAgeOnGet,\n                noDeleteOnStaleGet,\n                status\n            });\n        }\n        const options = {\n            allowStale,\n            updateAgeOnGet,\n            noDeleteOnStaleGet,\n            ttl,\n            noDisposeOnSet,\n            size,\n            sizeCalculation,\n            noUpdateTTL,\n            noDeleteOnFetchRejection,\n            allowStaleOnFetchRejection,\n            allowStaleOnFetchAbort,\n            ignoreFetchAbort,\n            status,\n            signal\n        };\n        let index = this.#keyMap.get(k);\n        if (index === undefined) {\n            if (status) status.fetch = \"miss\";\n            const p = this.#backgroundFetch(k, index, options, context);\n            return p.__returned = p;\n        } else {\n            // in cache, maybe already fetching\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                const stale = allowStale && v.__staleWhileFetching !== undefined;\n                if (status) {\n                    status.fetch = \"inflight\";\n                    if (stale) status.returnedStale = true;\n                }\n                return stale ? v.__staleWhileFetching : v.__returned = v;\n            }\n            // if we force a refresh, that means do NOT serve the cached value,\n            // unless we are already in the process of refreshing the cache.\n            const isStale = this.#isStale(index);\n            if (!forceRefresh && !isStale) {\n                if (status) status.fetch = \"hit\";\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                if (status) this.#statusTTL(status, index);\n                return v;\n            }\n            // ok, it is stale or a forced refresh, and not already fetching.\n            // refresh the cache.\n            const p = this.#backgroundFetch(k, index, options, context);\n            const hasStale = p.__staleWhileFetching !== undefined;\n            const staleVal = hasStale && allowStale;\n            if (status) {\n                status.fetch = isStale ? \"stale\" : \"refresh\";\n                if (staleVal && isStale) status.returnedStale = true;\n            }\n            return staleVal ? p.__staleWhileFetching : p.__returned = p;\n        }\n    }\n    async forceFetch(k, fetchOptions = {}) {\n        const v = await this.fetch(k, fetchOptions);\n        if (v === undefined) throw new Error(\"fetch() returned undefined\");\n        return v;\n    }\n    memo(k, memoOptions = {}) {\n        const memoMethod = this.#memoMethod;\n        if (!memoMethod) {\n            throw new Error(\"no memoMethod provided to constructor\");\n        }\n        const { context, forceRefresh, ...options } = memoOptions;\n        const v = this.get(k, options);\n        if (!forceRefresh && v !== undefined) return v;\n        const vv = memoMethod(k, v, {\n            options,\n            context\n        });\n        this.set(k, vv, options);\n        return vv;\n    }\n    /**\n     * Return a value from the cache. Will update the recency of the cache\n     * entry found.\n     *\n     * If the key is not found, get() will return `undefined`.\n     */ get(k, getOptions = {}) {\n        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const value = this.#valList[index];\n            const fetching = this.#isBackgroundFetch(value);\n            if (status) this.#statusTTL(status, index);\n            if (this.#isStale(index)) {\n                if (status) status.get = \"stale\";\n                // delete only if not an in-flight background fetch\n                if (!fetching) {\n                    if (!noDeleteOnStaleGet) {\n                        this.#delete(k, \"expire\");\n                    }\n                    if (status && allowStale) status.returnedStale = true;\n                    return allowStale ? value : undefined;\n                } else {\n                    if (status && allowStale && value.__staleWhileFetching !== undefined) {\n                        status.returnedStale = true;\n                    }\n                    return allowStale ? value.__staleWhileFetching : undefined;\n                }\n            } else {\n                if (status) status.get = \"hit\";\n                // if we're currently fetching it, we don't actually have it yet\n                // it's not stale, which means this isn't a staleWhileRefetching.\n                // If it's not stale, and fetching, AND has a __staleWhileFetching\n                // value, then that means the user fetched with {forceRefresh:true},\n                // so it's safe to return that value.\n                if (fetching) {\n                    return value.__staleWhileFetching;\n                }\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                return value;\n            }\n        } else if (status) {\n            status.get = \"miss\";\n        }\n    }\n    #connect(p, n) {\n        this.#prev[n] = p;\n        this.#next[p] = n;\n    }\n    #moveToTail(index) {\n        // if tail already, nothing to do\n        // if head, move head to next[index]\n        // else\n        //   move next[prev[index]] to next[index] (head has no prev)\n        //   move prev[next[index]] to prev[index]\n        // prev[index] = tail\n        // next[tail] = index\n        // tail = index\n        if (index !== this.#tail) {\n            if (index === this.#head) {\n                this.#head = this.#next[index];\n            } else {\n                this.#connect(this.#prev[index], this.#next[index]);\n            }\n            this.#connect(this.#tail, index);\n            this.#tail = index;\n        }\n    }\n    /**\n     * Deletes a key out of the cache.\n     *\n     * Returns true if the key was deleted, false otherwise.\n     */ delete(k) {\n        return this.#delete(k, \"delete\");\n    }\n    #delete(k, reason) {\n        let deleted = false;\n        if (this.#size !== 0) {\n            const index = this.#keyMap.get(k);\n            if (index !== undefined) {\n                deleted = true;\n                if (this.#size === 1) {\n                    this.#clear(reason);\n                } else {\n                    this.#removeItemSize(index);\n                    const v = this.#valList[index];\n                    if (this.#isBackgroundFetch(v)) {\n                        v.__abortController.abort(new Error(\"deleted\"));\n                    } else if (this.#hasDispose || this.#hasDisposeAfter) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(v, k, reason);\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([\n                                v,\n                                k,\n                                reason\n                            ]);\n                        }\n                    }\n                    this.#keyMap.delete(k);\n                    this.#keyList[index] = undefined;\n                    this.#valList[index] = undefined;\n                    if (index === this.#tail) {\n                        this.#tail = this.#prev[index];\n                    } else if (index === this.#head) {\n                        this.#head = this.#next[index];\n                    } else {\n                        const pi = this.#prev[index];\n                        this.#next[pi] = this.#next[index];\n                        const ni = this.#next[index];\n                        this.#prev[ni] = this.#prev[index];\n                    }\n                    this.#size--;\n                    this.#free.push(index);\n                }\n            }\n        }\n        if (this.#hasDisposeAfter && this.#disposed?.length) {\n            const dt = this.#disposed;\n            let task;\n            while(task = dt?.shift()){\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Clear the cache entirely, throwing away all values.\n     */ clear() {\n        return this.#clear(\"delete\");\n    }\n    #clear(reason) {\n        for (const index of this.#rindexes({\n            allowStale: true\n        })){\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                v.__abortController.abort(new Error(\"deleted\"));\n            } else {\n                const k = this.#keyList[index];\n                if (this.#hasDispose) {\n                    this.#dispose?.(v, k, reason);\n                }\n                if (this.#hasDisposeAfter) {\n                    this.#disposed?.push([\n                        v,\n                        k,\n                        reason\n                    ]);\n                }\n            }\n        }\n        this.#keyMap.clear();\n        this.#valList.fill(undefined);\n        this.#keyList.fill(undefined);\n        if (this.#ttls && this.#starts) {\n            this.#ttls.fill(0);\n            this.#starts.fill(0);\n        }\n        if (this.#sizes) {\n            this.#sizes.fill(0);\n        }\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free.length = 0;\n        this.#calculatedSize = 0;\n        this.#size = 0;\n        if (this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while(task = dt?.shift()){\n                this.#disposeAfter?.(...task);\n            }\n        }\n    }\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbHJ1LWNhY2hlL2Rpc3QvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Q0FFQyxHQUNELE1BQU1BLE9BQU8sT0FBT0MsZ0JBQWdCLFlBQ2hDQSxlQUNBLE9BQU9BLFlBQVlDLEdBQUcsS0FBSyxhQUN6QkQsY0FDQUU7QUFDTixNQUFNQyxTQUFTLElBQUlDO0FBQ25CLG1CQUFtQixHQUNuQixNQUFNQyxVQUFXLE9BQU9DLFlBQVksWUFBWSxDQUFDLENBQUNBLFVBQVVBLFVBQVUsQ0FBQztBQUN2RSxtQkFBbUIsR0FDbkIsTUFBTUMsY0FBYyxDQUFDQyxLQUFLQyxNQUFNQyxNQUFNQztJQUNsQyxPQUFPTixRQUFRRSxXQUFXLEtBQUssYUFDekJGLFFBQVFFLFdBQVcsQ0FBQ0MsS0FBS0MsTUFBTUMsTUFBTUMsTUFDckNDLFFBQVFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRUgsS0FBSyxFQUFFLEVBQUVELEtBQUssRUFBRSxFQUFFRCxJQUFJLENBQUM7QUFDbkQ7QUFDQSxJQUFJTSxLQUFLQyxXQUFXQyxlQUFlO0FBQ25DLElBQUlDLEtBQUtGLFdBQVdHLFdBQVc7QUFDL0IsbUJBQW1CLEdBQ25CLElBQUksT0FBT0osT0FBTyxhQUFhO0lBQzNCLFlBQVk7SUFDWkcsS0FBSyxNQUFNQztRQUtQQyxpQkFBaUJDLENBQUMsRUFBRVQsRUFBRSxFQUFFO1lBQ3BCLElBQUksQ0FBQ1UsUUFBUSxDQUFDQyxJQUFJLENBQUNYO1FBQ3ZCOztpQkFMQVUsV0FBVyxFQUFFO2lCQUViRSxVQUFVOztJQUlkO0lBQ0EsWUFBWTtJQUNaVCxLQUFLLE1BQU1FO1FBQ1BRLGFBQWM7aUJBR2RDLFNBQVMsSUFBSVI7WUFGVFM7UUFDSjtRQUVBQyxNQUFNQyxNQUFNLEVBQUU7WUFDVixJQUFJLElBQUksQ0FBQ0gsTUFBTSxDQUFDRixPQUFPLEVBQ25CO1lBQ0osWUFBWTtZQUNaLElBQUksQ0FBQ0UsTUFBTSxDQUFDRyxNQUFNLEdBQUdB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S0FBSyxJQUFJLENBQUMsQ0FBQ3hHLFFBQVE7WUFDekIsSUFBSXlHO1lBQ0osTUFBUUEsT0FBT0QsSUFBSUUsUUFBVTtnQkFDekIsSUFBSSxDQUFDLENBQUN0SCxZQUFZLE1BQU1xSDtZQUM1QjtRQUNKO0lBQ0o7QUFDSixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2phbWlpZnVuZC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9scnUtY2FjaGUvZGlzdC9lc20vaW5kZXguanM/OWQyZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgTFJVQ2FjaGVcbiAqL1xuY29uc3QgcGVyZiA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ29iamVjdCcgJiZcbiAgICBwZXJmb3JtYW5jZSAmJlxuICAgIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbidcbiAgICA/IHBlcmZvcm1hbmNlXG4gICAgOiBEYXRlO1xuY29uc3Qgd2FybmVkID0gbmV3IFNldCgpO1xuLyogYzggaWdub3JlIHN0YXJ0ICovXG5jb25zdCBQUk9DRVNTID0gKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiAhIXByb2Nlc3MgPyBwcm9jZXNzIDoge30pO1xuLyogYzggaWdub3JlIHN0YXJ0ICovXG5jb25zdCBlbWl0V2FybmluZyA9IChtc2csIHR5cGUsIGNvZGUsIGZuKSA9PiB7XG4gICAgdHlwZW9mIFBST0NFU1MuZW1pdFdhcm5pbmcgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBQUk9DRVNTLmVtaXRXYXJuaW5nKG1zZywgdHlwZSwgY29kZSwgZm4pXG4gICAgICAgIDogY29uc29sZS5lcnJvcihgWyR7Y29kZX1dICR7dHlwZX06ICR7bXNnfWApO1xufTtcbmxldCBBQyA9IGdsb2JhbFRoaXMuQWJvcnRDb250cm9sbGVyO1xubGV0IEFTID0gZ2xvYmFsVGhpcy5BYm9ydFNpZ25hbDtcbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuaWYgKHR5cGVvZiBBQyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvL0B0cy1pZ25vcmVcbiAgICBBUyA9IGNsYXNzIEFib3J0U2lnbmFsIHtcbiAgICAgICAgb25hYm9ydDtcbiAgICAgICAgX29uYWJvcnQgPSBbXTtcbiAgICAgICAgcmVhc29uO1xuICAgICAgICBhYm9ydGVkID0gZmFsc2U7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoXywgZm4pIHtcbiAgICAgICAgICAgIHRoaXMuX29uYWJvcnQucHVzaChmbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vQHRzLWlnbm9yZVxuICAgIEFDID0gY2xhc3MgQWJvcnRDb250cm9sbGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB3YXJuQUNQb2x5ZmlsbCgpO1xuICAgICAgICB9XG4gICAgICAgIHNpZ25hbCA9IG5ldyBBUygpO1xuICAgICAgICBhYm9ydChyZWFzb24pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNpZ25hbC5hYm9ydGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy5zaWduYWwucmVhc29uID0gcmVhc29uO1xuICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICB0aGlzLnNpZ25hbC5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgZm9yIChjb25zdCBmbiBvZiB0aGlzLnNpZ25hbC5fb25hYm9ydCkge1xuICAgICAgICAgICAgICAgIGZuKHJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNpZ25hbC5vbmFib3J0Py4ocmVhc29uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IHByaW50QUNQb2x5ZmlsbFdhcm5pbmcgPSBQUk9DRVNTLmVudj8uTFJVX0NBQ0hFX0lHTk9SRV9BQ19XQVJOSU5HICE9PSAnMSc7XG4gICAgY29uc3Qgd2FybkFDUG9seWZpbGwgPSAoKSA9PiB7XG4gICAgICAgIGlmICghcHJpbnRBQ1BvbHlmaWxsV2FybmluZylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcHJpbnRBQ1BvbHlmaWxsV2FybmluZyA9IGZhbHNlO1xuICAgICAgICBlbWl0V2FybmluZygnQWJvcnRDb250cm9sbGVyIGlzIG5vdCBkZWZpbmVkLiBJZiB1c2luZyBscnUtY2FjaGUgaW4gJyArXG4gICAgICAgICAgICAnbm9kZSAxNCwgbG9hZCBhbiBBYm9ydENvbnRyb2xsZXIgcG9seWZpbGwgZnJvbSB0aGUgJyArXG4gICAgICAgICAgICAnYG5vZGUtYWJvcnQtY29udHJvbGxlcmAgcGFja2FnZS4gQSBtaW5pbWFsIHBvbHlmaWxsIGlzICcgK1xuICAgICAgICAgICAgJ3Byb3ZpZGVkIGZvciB1c2UgYnkgTFJVQ2FjaGUuZmV0Y2goKSwgYnV0IGl0IHNob3VsZCBub3QgYmUgJyArXG4gICAgICAgICAgICAncmVsaWVkIHVwb24gaW4gb3RoZXIgY29udGV4dHMgKGVnLCBwYXNzaW5nIGl0IHRvIG90aGVyIEFQSXMgdGhhdCAnICtcbiAgICAgICAgICAgICd1c2UgQWJvcnRDb250cm9sbGVyL0Fib3J0U2lnbmFsIG1pZ2h0IGhhdmUgdW5kZXNpcmFibGUgZWZmZWN0cykuICcgK1xuICAgICAgICAgICAgJ1lvdSBtYXkgZGlzYWJsZSB0aGlzIHdpdGggTFJVX0NBQ0hFX0lHTk9SRV9BQ19XQVJOSU5HPTEgaW4gdGhlIGVudi4nLCAnTk9fQUJPUlRfQ09OVFJPTExFUicsICdFTk9UU1VQJywgd2FybkFDUG9seWZpbGwpO1xuICAgIH07XG59XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuY29uc3Qgc2hvdWxkV2FybiA9IChjb2RlKSA9PiAhd2FybmVkLmhhcyhjb2RlKTtcbmNvbnN0IFRZUEUgPSBTeW1ib2woJ3R5cGUnKTtcbmNvbnN0IGlzUG9zSW50ID0gKG4pID0+IG4gJiYgbiA9PT0gTWF0aC5mbG9vcihuKSAmJiBuID4gMCAmJiBpc0Zpbml0ZShuKTtcbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuLy8gVGhpcyBpcyBhIGxpdHRsZSBiaXQgcmlkaWN1bG91cywgdGJoLlxuLy8gVGhlIG1heGltdW0gYXJyYXkgbGVuZ3RoIGlzIDJeMzItMSBvciB0aGVyZWFib3V0cyBvbiBtb3N0IEpTIGltcGxzLlxuLy8gQW5kIHdlbGwgYmVmb3JlIHRoYXQgcG9pbnQsIHlvdSdyZSBjYWNoaW5nIHRoZSBlbnRpcmUgd29ybGQsIEkgbWVhbixcbi8vIHRoYXQncyB+MzJHQiBvZiBqdXN0IGludGVnZXJzIGZvciB0aGUgbmV4dC9wcmV2IGxpbmtzLCBwbHVzIHdoYXRldmVyXG4vLyBlbHNlIHRvIGhvbGQgdGhhdCBtYW55IGtleXMgYW5kIHZhbHVlcy4gIEp1c3QgZmlsbGluZyB0aGUgbWVtb3J5IHdpdGhcbi8vIHplcm9lcyBhdCBpbml0IHRpbWUgaXMgYnJ1dGFsIHdoZW4geW91IGdldCB0aGF0IGJpZy5cbi8vIEJ1dCB3aHkgbm90IGJlIGNvbXBsZXRlP1xuLy8gTWF5YmUgaW4gdGhlIGZ1dHVyZSwgdGhlc2UgbGltaXRzIHdpbGwgaGF2ZSBleHBhbmRlZC5cbmNvbnN0IGdldFVpbnRBcnJheSA9IChtYXgpID0+ICFpc1Bvc0ludChtYXgpXG4gICAgPyBudWxsXG4gICAgOiBtYXggPD0gTWF0aC5wb3coMiwgOClcbiAgICAgICAgPyBVaW50OEFycmF5XG4gICAgICAgIDogbWF4IDw9IE1hdGgucG93KDIsIDE2KVxuICAgICAgICAgICAgPyBVaW50MTZBcnJheVxuICAgICAgICAgICAgOiBtYXggPD0gTWF0aC5wb3coMiwgMzIpXG4gICAgICAgICAgICAgICAgPyBVaW50MzJBcnJheVxuICAgICAgICAgICAgICAgIDogbWF4IDw9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG4gICAgICAgICAgICAgICAgICAgID8gWmVyb0FycmF5XG4gICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbi8qIGM4IGlnbm9yZSBzdG9wICovXG5jbGFzcyBaZXJvQXJyYXkgZXh0ZW5kcyBBcnJheSB7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSkge1xuICAgICAgICBzdXBlcihzaXplKTtcbiAgICAgICAgdGhpcy5maWxsKDApO1xuICAgIH1cbn1cbmNsYXNzIFN0YWNrIHtcbiAgICBoZWFwO1xuICAgIGxlbmd0aDtcbiAgICAvLyBwcml2YXRlIGNvbnN0cnVjdG9yXG4gICAgc3RhdGljICNjb25zdHJ1Y3RpbmcgPSBmYWxzZTtcbiAgICBzdGF0aWMgY3JlYXRlKG1heCkge1xuICAgICAgICBjb25zdCBIZWFwQ2xzID0gZ2V0VWludEFycmF5KG1heCk7XG4gICAgICAgIGlmICghSGVhcENscylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgU3RhY2suI2NvbnN0cnVjdGluZyA9IHRydWU7XG4gICAgICAgIGNvbnN0IHMgPSBuZXcgU3RhY2sobWF4LCBIZWFwQ2xzKTtcbiAgICAgICAgU3RhY2suI2NvbnN0cnVjdGluZyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgY29uc3RydWN0b3IobWF4LCBIZWFwQ2xzKSB7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoIVN0YWNrLiNjb25zdHJ1Y3RpbmcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2luc3RhbnRpYXRlIFN0YWNrIHVzaW5nIFN0YWNrLmNyZWF0ZShuKScpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIHRoaXMuaGVhcCA9IG5ldyBIZWFwQ2xzKG1heCk7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgcHVzaChuKSB7XG4gICAgICAgIHRoaXMuaGVhcFt0aGlzLmxlbmd0aCsrXSA9IG47XG4gICAgfVxuICAgIHBvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhcFstLXRoaXMubGVuZ3RoXTtcbiAgICB9XG59XG4vKipcbiAqIERlZmF1bHQgZXhwb3J0LCB0aGUgdGhpbmcgeW91J3JlIHVzaW5nIHRoaXMgbW9kdWxlIHRvIGdldC5cbiAqXG4gKiBUaGUgYEtgIGFuZCBgVmAgdHlwZXMgZGVmaW5lIHRoZSBrZXkgYW5kIHZhbHVlIHR5cGVzLCByZXNwZWN0aXZlbHkuIFRoZVxuICogb3B0aW9uYWwgYEZDYCB0eXBlIGRlZmluZXMgdGhlIHR5cGUgb2YgdGhlIGBjb250ZXh0YCBvYmplY3QgcGFzc2VkIHRvXG4gKiBgY2FjaGUuZmV0Y2goKWAgYW5kIGBjYWNoZS5tZW1vKClgLlxuICpcbiAqIEtleXMgYW5kIHZhbHVlcyAqKm11c3Qgbm90KiogYmUgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICpcbiAqIEFsbCBwcm9wZXJ0aWVzIGZyb20gdGhlIG9wdGlvbnMgb2JqZWN0ICh3aXRoIHRoZSBleGNlcHRpb24gb2YgYG1heGAsXG4gKiBgbWF4U2l6ZWAsIGBmZXRjaE1ldGhvZGAsIGBtZW1vTWV0aG9kYCwgYGRpc3Bvc2VgIGFuZCBgZGlzcG9zZUFmdGVyYCkgYXJlXG4gKiBhZGRlZCBhcyBub3JtYWwgcHVibGljIG1lbWJlcnMuIChUaGUgbGlzdGVkIG9wdGlvbnMgYXJlIHJlYWQtb25seSBnZXR0ZXJzLilcbiAqXG4gKiBDaGFuZ2luZyBhbnkgb2YgdGhlc2Ugd2lsbCBhbHRlciB0aGUgZGVmYXVsdHMgZm9yIHN1YnNlcXVlbnQgbWV0aG9kIGNhbGxzLlxuICovXG5leHBvcnQgY2xhc3MgTFJVQ2FjaGUge1xuICAgIC8vIG9wdGlvbnMgdGhhdCBjYW5ub3QgYmUgY2hhbmdlZCB3aXRob3V0IGRpc2FzdGVyXG4gICAgI21heDtcbiAgICAjbWF4U2l6ZTtcbiAgICAjZGlzcG9zZTtcbiAgICAjZGlzcG9zZUFmdGVyO1xuICAgICNmZXRjaE1ldGhvZDtcbiAgICAjbWVtb01ldGhvZDtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UudHRsfVxuICAgICAqL1xuICAgIHR0bDtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UudHRsUmVzb2x1dGlvbn1cbiAgICAgKi9cbiAgICB0dGxSZXNvbHV0aW9uO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS50dGxBdXRvcHVyZ2V9XG4gICAgICovXG4gICAgdHRsQXV0b3B1cmdlO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS51cGRhdGVBZ2VPbkdldH1cbiAgICAgKi9cbiAgICB1cGRhdGVBZ2VPbkdldDtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UudXBkYXRlQWdlT25IYXN9XG4gICAgICovXG4gICAgdXBkYXRlQWdlT25IYXM7XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLmFsbG93U3RhbGV9XG4gICAgICovXG4gICAgYWxsb3dTdGFsZTtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2Uubm9EaXNwb3NlT25TZXR9XG4gICAgICovXG4gICAgbm9EaXNwb3NlT25TZXQ7XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLm5vVXBkYXRlVFRMfVxuICAgICAqL1xuICAgIG5vVXBkYXRlVFRMO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5tYXhFbnRyeVNpemV9XG4gICAgICovXG4gICAgbWF4RW50cnlTaXplO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5zaXplQ2FsY3VsYXRpb259XG4gICAgICovXG4gICAgc2l6ZUNhbGN1bGF0aW9uO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5ub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb259XG4gICAgICovXG4gICAgbm9EZWxldGVPbkZldGNoUmVqZWN0aW9uO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5ub0RlbGV0ZU9uU3RhbGVHZXR9XG4gICAgICovXG4gICAgbm9EZWxldGVPblN0YWxlR2V0O1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5hbGxvd1N0YWxlT25GZXRjaEFib3J0fVxuICAgICAqL1xuICAgIGFsbG93U3RhbGVPbkZldGNoQWJvcnQ7XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLmFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9ufVxuICAgICAqL1xuICAgIGFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5pZ25vcmVGZXRjaEFib3J0fVxuICAgICAqL1xuICAgIGlnbm9yZUZldGNoQWJvcnQ7XG4gICAgLy8gY29tcHV0ZWQgcHJvcGVydGllc1xuICAgICNzaXplO1xuICAgICNjYWxjdWxhdGVkU2l6ZTtcbiAgICAja2V5TWFwO1xuICAgICNrZXlMaXN0O1xuICAgICN2YWxMaXN0O1xuICAgICNuZXh0O1xuICAgICNwcmV2O1xuICAgICNoZWFkO1xuICAgICN0YWlsO1xuICAgICNmcmVlO1xuICAgICNkaXNwb3NlZDtcbiAgICAjc2l6ZXM7XG4gICAgI3N0YXJ0cztcbiAgICAjdHRscztcbiAgICAjaGFzRGlzcG9zZTtcbiAgICAjaGFzRmV0Y2hNZXRob2Q7XG4gICAgI2hhc0Rpc3Bvc2VBZnRlcjtcbiAgICAvKipcbiAgICAgKiBEbyBub3QgY2FsbCB0aGlzIG1ldGhvZCB1bmxlc3MgeW91IG5lZWQgdG8gaW5zcGVjdCB0aGVcbiAgICAgKiBpbm5lciB3b3JraW5ncyBvZiB0aGUgY2FjaGUuICBJZiBhbnl0aGluZyByZXR1cm5lZCBieSB0aGlzXG4gICAgICogb2JqZWN0IGlzIG1vZGlmaWVkIGluIGFueSB3YXksIHN0cmFuZ2UgYnJlYWthZ2UgbWF5IG9jY3VyLlxuICAgICAqXG4gICAgICogVGhlc2UgZmllbGRzIGFyZSBwcml2YXRlIGZvciBhIHJlYXNvbiFcbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyB1bnNhZmVFeHBvc2VJbnRlcm5hbHMoYykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gcHJvcGVydGllc1xuICAgICAgICAgICAgc3RhcnRzOiBjLiNzdGFydHMsXG4gICAgICAgICAgICB0dGxzOiBjLiN0dGxzLFxuICAgICAgICAgICAgc2l6ZXM6IGMuI3NpemVzLFxuICAgICAgICAgICAga2V5TWFwOiBjLiNrZXlNYXAsXG4gICAgICAgICAgICBrZXlMaXN0OiBjLiNrZXlMaXN0LFxuICAgICAgICAgICAgdmFsTGlzdDogYy4jdmFsTGlzdCxcbiAgICAgICAgICAgIG5leHQ6IGMuI25leHQsXG4gICAgICAgICAgICBwcmV2OiBjLiNwcmV2LFxuICAgICAgICAgICAgZ2V0IGhlYWQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMuI2hlYWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IHRhaWwoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMuI3RhaWw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJlZTogYy4jZnJlZSxcbiAgICAgICAgICAgIC8vIG1ldGhvZHNcbiAgICAgICAgICAgIGlzQmFja2dyb3VuZEZldGNoOiAocCkgPT4gYy4jaXNCYWNrZ3JvdW5kRmV0Y2gocCksXG4gICAgICAgICAgICBiYWNrZ3JvdW5kRmV0Y2g6IChrLCBpbmRleCwgb3B0aW9ucywgY29udGV4dCkgPT4gYy4jYmFja2dyb3VuZEZldGNoKGssIGluZGV4LCBvcHRpb25zLCBjb250ZXh0KSxcbiAgICAgICAgICAgIG1vdmVUb1RhaWw6IChpbmRleCkgPT4gYy4jbW92ZVRvVGFpbChpbmRleCksXG4gICAgICAgICAgICBpbmRleGVzOiAob3B0aW9ucykgPT4gYy4jaW5kZXhlcyhvcHRpb25zKSxcbiAgICAgICAgICAgIHJpbmRleGVzOiAob3B0aW9ucykgPT4gYy4jcmluZGV4ZXMob3B0aW9ucyksXG4gICAgICAgICAgICBpc1N0YWxlOiAoaW5kZXgpID0+IGMuI2lzU3RhbGUoaW5kZXgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBQcm90ZWN0ZWQgcmVhZC1vbmx5IG1lbWJlcnNcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UubWF4fSAocmVhZC1vbmx5KVxuICAgICAqL1xuICAgIGdldCBtYXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNtYXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5tYXhTaXplfSAocmVhZC1vbmx5KVxuICAgICAqL1xuICAgIGdldCBtYXhTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jbWF4U2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHRvdGFsIGNvbXB1dGVkIHNpemUgb2YgaXRlbXMgaW4gdGhlIGNhY2hlIChyZWFkLW9ubHkpXG4gICAgICovXG4gICAgZ2V0IGNhbGN1bGF0ZWRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY2FsY3VsYXRlZFNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgaXRlbXMgc3RvcmVkIGluIHRoZSBjYWNoZSAocmVhZC1vbmx5KVxuICAgICAqL1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jc2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLmZldGNoTWV0aG9kfSAocmVhZC1vbmx5KVxuICAgICAqL1xuICAgIGdldCBmZXRjaE1ldGhvZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2ZldGNoTWV0aG9kO1xuICAgIH1cbiAgICBnZXQgbWVtb01ldGhvZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI21lbW9NZXRob2Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5kaXNwb3NlfSAocmVhZC1vbmx5KVxuICAgICAqL1xuICAgIGdldCBkaXNwb3NlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZGlzcG9zZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLmRpc3Bvc2VBZnRlcn0gKHJlYWQtb25seSlcbiAgICAgKi9cbiAgICBnZXQgZGlzcG9zZUFmdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZGlzcG9zZUFmdGVyO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgbWF4ID0gMCwgdHRsLCB0dGxSZXNvbHV0aW9uID0gMSwgdHRsQXV0b3B1cmdlLCB1cGRhdGVBZ2VPbkdldCwgdXBkYXRlQWdlT25IYXMsIGFsbG93U3RhbGUsIGRpc3Bvc2UsIGRpc3Bvc2VBZnRlciwgbm9EaXNwb3NlT25TZXQsIG5vVXBkYXRlVFRMLCBtYXhTaXplID0gMCwgbWF4RW50cnlTaXplID0gMCwgc2l6ZUNhbGN1bGF0aW9uLCBmZXRjaE1ldGhvZCwgbWVtb01ldGhvZCwgbm9EZWxldGVPbkZldGNoUmVqZWN0aW9uLCBub0RlbGV0ZU9uU3RhbGVHZXQsIGFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uLCBhbGxvd1N0YWxlT25GZXRjaEFib3J0LCBpZ25vcmVGZXRjaEFib3J0LCB9ID0gb3B0aW9ucztcbiAgICAgICAgaWYgKG1heCAhPT0gMCAmJiAhaXNQb3NJbnQobWF4KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4IG9wdGlvbiBtdXN0IGJlIGEgbm9ubmVnYXRpdmUgaW50ZWdlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFVpbnRBcnJheSA9IG1heCA/IGdldFVpbnRBcnJheShtYXgpIDogQXJyYXk7XG4gICAgICAgIGlmICghVWludEFycmF5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbWF4IHZhbHVlOiAnICsgbWF4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNtYXggPSBtYXg7XG4gICAgICAgIHRoaXMuI21heFNpemUgPSBtYXhTaXplO1xuICAgICAgICB0aGlzLm1heEVudHJ5U2l6ZSA9IG1heEVudHJ5U2l6ZSB8fCB0aGlzLiNtYXhTaXplO1xuICAgICAgICB0aGlzLnNpemVDYWxjdWxhdGlvbiA9IHNpemVDYWxjdWxhdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZUNhbGN1bGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuI21heFNpemUgJiYgIXRoaXMubWF4RW50cnlTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2Fubm90IHNldCBzaXplQ2FsY3VsYXRpb24gd2l0aG91dCBzZXR0aW5nIG1heFNpemUgb3IgbWF4RW50cnlTaXplJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuc2l6ZUNhbGN1bGF0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZUNhbGN1bGF0aW9uIHNldCB0byBub24tZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWVtb01ldGhvZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0eXBlb2YgbWVtb01ldGhvZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWVtb01ldGhvZCBtdXN0IGJlIGEgZnVuY3Rpb24gaWYgZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI21lbW9NZXRob2QgPSBtZW1vTWV0aG9kO1xuICAgICAgICBpZiAoZmV0Y2hNZXRob2QgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdHlwZW9mIGZldGNoTWV0aG9kICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmZXRjaE1ldGhvZCBtdXN0IGJlIGEgZnVuY3Rpb24gaWYgc3BlY2lmaWVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jZmV0Y2hNZXRob2QgPSBmZXRjaE1ldGhvZDtcbiAgICAgICAgdGhpcy4jaGFzRmV0Y2hNZXRob2QgPSAhIWZldGNoTWV0aG9kO1xuICAgICAgICB0aGlzLiNrZXlNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI2tleUxpc3QgPSBuZXcgQXJyYXkobWF4KS5maWxsKHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuI3ZhbExpc3QgPSBuZXcgQXJyYXkobWF4KS5maWxsKHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuI25leHQgPSBuZXcgVWludEFycmF5KG1heCk7XG4gICAgICAgIHRoaXMuI3ByZXYgPSBuZXcgVWludEFycmF5KG1heCk7XG4gICAgICAgIHRoaXMuI2hlYWQgPSAwO1xuICAgICAgICB0aGlzLiN0YWlsID0gMDtcbiAgICAgICAgdGhpcy4jZnJlZSA9IFN0YWNrLmNyZWF0ZShtYXgpO1xuICAgICAgICB0aGlzLiNzaXplID0gMDtcbiAgICAgICAgdGhpcy4jY2FsY3VsYXRlZFNpemUgPSAwO1xuICAgICAgICBpZiAodHlwZW9mIGRpc3Bvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2UgPSBkaXNwb3NlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGlzcG9zZUFmdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLiNkaXNwb3NlQWZ0ZXIgPSBkaXNwb3NlQWZ0ZXI7XG4gICAgICAgICAgICB0aGlzLiNkaXNwb3NlZCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jZGlzcG9zZUFmdGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy4jZGlzcG9zZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jaGFzRGlzcG9zZSA9ICEhdGhpcy4jZGlzcG9zZTtcbiAgICAgICAgdGhpcy4jaGFzRGlzcG9zZUFmdGVyID0gISF0aGlzLiNkaXNwb3NlQWZ0ZXI7XG4gICAgICAgIHRoaXMubm9EaXNwb3NlT25TZXQgPSAhIW5vRGlzcG9zZU9uU2V0O1xuICAgICAgICB0aGlzLm5vVXBkYXRlVFRMID0gISFub1VwZGF0ZVRUTDtcbiAgICAgICAgdGhpcy5ub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb24gPSAhIW5vRGVsZXRlT25GZXRjaFJlamVjdGlvbjtcbiAgICAgICAgdGhpcy5hbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbiA9ICEhYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb247XG4gICAgICAgIHRoaXMuYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydCA9ICEhYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydDtcbiAgICAgICAgdGhpcy5pZ25vcmVGZXRjaEFib3J0ID0gISFpZ25vcmVGZXRjaEFib3J0O1xuICAgICAgICAvLyBOQjogbWF4RW50cnlTaXplIGlzIHNldCB0byBtYXhTaXplIGlmIGl0J3Mgc2V0XG4gICAgICAgIGlmICh0aGlzLm1heEVudHJ5U2l6ZSAhPT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI21heFNpemUgIT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUG9zSW50KHRoaXMuI21heFNpemUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heFNpemUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgaWYgc3BlY2lmaWVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1Bvc0ludCh0aGlzLm1heEVudHJ5U2l6ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhFbnRyeVNpemUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgaWYgc3BlY2lmaWVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNpbml0aWFsaXplU2l6ZVRyYWNraW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbGxvd1N0YWxlID0gISFhbGxvd1N0YWxlO1xuICAgICAgICB0aGlzLm5vRGVsZXRlT25TdGFsZUdldCA9ICEhbm9EZWxldGVPblN0YWxlR2V0O1xuICAgICAgICB0aGlzLnVwZGF0ZUFnZU9uR2V0ID0gISF1cGRhdGVBZ2VPbkdldDtcbiAgICAgICAgdGhpcy51cGRhdGVBZ2VPbkhhcyA9ICEhdXBkYXRlQWdlT25IYXM7XG4gICAgICAgIHRoaXMudHRsUmVzb2x1dGlvbiA9XG4gICAgICAgICAgICBpc1Bvc0ludCh0dGxSZXNvbHV0aW9uKSB8fCB0dGxSZXNvbHV0aW9uID09PSAwXG4gICAgICAgICAgICAgICAgPyB0dGxSZXNvbHV0aW9uXG4gICAgICAgICAgICAgICAgOiAxO1xuICAgICAgICB0aGlzLnR0bEF1dG9wdXJnZSA9ICEhdHRsQXV0b3B1cmdlO1xuICAgICAgICB0aGlzLnR0bCA9IHR0bCB8fCAwO1xuICAgICAgICBpZiAodGhpcy50dGwpIHtcbiAgICAgICAgICAgIGlmICghaXNQb3NJbnQodGhpcy50dGwpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndHRsIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGlmIHNwZWNpZmllZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jaW5pdGlhbGl6ZVRUTFRyYWNraW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG8gbm90IGFsbG93IGNvbXBsZXRlbHkgdW5ib3VuZGVkIGNhY2hlc1xuICAgICAgICBpZiAodGhpcy4jbWF4ID09PSAwICYmIHRoaXMudHRsID09PSAwICYmIHRoaXMuI21heFNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0F0IGxlYXN0IG9uZSBvZiBtYXgsIG1heFNpemUsIG9yIHR0bCBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy50dGxBdXRvcHVyZ2UgJiYgIXRoaXMuI21heCAmJiAhdGhpcy4jbWF4U2l6ZSkge1xuICAgICAgICAgICAgY29uc3QgY29kZSA9ICdMUlVfQ0FDSEVfVU5CT1VOREVEJztcbiAgICAgICAgICAgIGlmIChzaG91bGRXYXJuKGNvZGUpKSB7XG4gICAgICAgICAgICAgICAgd2FybmVkLmFkZChjb2RlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSAnVFRMIGNhY2hpbmcgd2l0aG91dCB0dGxBdXRvcHVyZ2UsIG1heCwgb3IgbWF4U2l6ZSBjYW4gJyArXG4gICAgICAgICAgICAgICAgICAgICdyZXN1bHQgaW4gdW5ib3VuZGVkIG1lbW9yeSBjb25zdW1wdGlvbi4nO1xuICAgICAgICAgICAgICAgIGVtaXRXYXJuaW5nKG1zZywgJ1VuYm91bmRlZENhY2hlV2FybmluZycsIGNvZGUsIExSVUNhY2hlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBtcyBsZWZ0IGluIHRoZSBpdGVtJ3MgVFRMLiBJZiBpdGVtIGlzIG5vdCBpbiBjYWNoZSxcbiAgICAgKiByZXR1cm5zIGAwYC4gUmV0dXJucyBgSW5maW5pdHlgIGlmIGl0ZW0gaXMgaW4gY2FjaGUgd2l0aG91dCBhIGRlZmluZWQgVFRMLlxuICAgICAqL1xuICAgIGdldFJlbWFpbmluZ1RUTChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2tleU1hcC5oYXMoa2V5KSA/IEluZmluaXR5IDogMDtcbiAgICB9XG4gICAgI2luaXRpYWxpemVUVExUcmFja2luZygpIHtcbiAgICAgICAgY29uc3QgdHRscyA9IG5ldyBaZXJvQXJyYXkodGhpcy4jbWF4KTtcbiAgICAgICAgY29uc3Qgc3RhcnRzID0gbmV3IFplcm9BcnJheSh0aGlzLiNtYXgpO1xuICAgICAgICB0aGlzLiN0dGxzID0gdHRscztcbiAgICAgICAgdGhpcy4jc3RhcnRzID0gc3RhcnRzO1xuICAgICAgICB0aGlzLiNzZXRJdGVtVFRMID0gKGluZGV4LCB0dGwsIHN0YXJ0ID0gcGVyZi5ub3coKSkgPT4ge1xuICAgICAgICAgICAgc3RhcnRzW2luZGV4XSA9IHR0bCAhPT0gMCA/IHN0YXJ0IDogMDtcbiAgICAgICAgICAgIHR0bHNbaW5kZXhdID0gdHRsO1xuICAgICAgICAgICAgaWYgKHR0bCAhPT0gMCAmJiB0aGlzLnR0bEF1dG9wdXJnZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI2lzU3RhbGUoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNkZWxldGUodGhpcy4ja2V5TGlzdFtpbmRleF0sICdleHBpcmUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHR0bCArIDEpO1xuICAgICAgICAgICAgICAgIC8vIHVucmVmKCkgbm90IHN1cHBvcnRlZCBvbiBhbGwgcGxhdGZvcm1zXG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICAgICAgaWYgKHQudW5yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdC51bnJlZigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLiN1cGRhdGVJdGVtQWdlID0gaW5kZXggPT4ge1xuICAgICAgICAgICAgc3RhcnRzW2luZGV4XSA9IHR0bHNbaW5kZXhdICE9PSAwID8gcGVyZi5ub3coKSA6IDA7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuI3N0YXR1c1RUTCA9IChzdGF0dXMsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAodHRsc1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0dGwgPSB0dGxzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IHN0YXJ0c1tpbmRleF07XG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICBpZiAoIXR0bCB8fCAhc3RhcnQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBzdGF0dXMudHRsID0gdHRsO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHN0YXR1cy5ub3cgPSBjYWNoZWROb3cgfHwgZ2V0Tm93KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWdlID0gc3RhdHVzLm5vdyAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgIHN0YXR1cy5yZW1haW5pbmdUVEwgPSB0dGwgLSBhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIGRlYm91bmNlIGNhbGxzIHRvIHBlcmYubm93KCkgdG8gMXMgc28gd2UncmUgbm90IGhpdHRpbmdcbiAgICAgICAgLy8gdGhhdCBjb3N0bHkgY2FsbCByZXBlYXRlZGx5LlxuICAgICAgICBsZXQgY2FjaGVkTm93ID0gMDtcbiAgICAgICAgY29uc3QgZ2V0Tm93ID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbiA9IHBlcmYubm93KCk7XG4gICAgICAgICAgICBpZiAodGhpcy50dGxSZXNvbHV0aW9uID4gMCkge1xuICAgICAgICAgICAgICAgIGNhY2hlZE5vdyA9IG47XG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IHNldFRpbWVvdXQoKCkgPT4gKGNhY2hlZE5vdyA9IDApLCB0aGlzLnR0bFJlc29sdXRpb24pO1xuICAgICAgICAgICAgICAgIC8vIG5vdCBhdmFpbGFibGUgb24gYWxsIHBsYXRmb3Jtc1xuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgICAgIGlmICh0LnVucmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHQudW5yZWYoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldFJlbWFpbmluZ1RUTCA9IGtleSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuI2tleU1hcC5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0dGwgPSB0dGxzW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gc3RhcnRzW2luZGV4XTtcbiAgICAgICAgICAgIGlmICghdHRsIHx8ICFzdGFydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFnZSA9IChjYWNoZWROb3cgfHwgZ2V0Tm93KCkpIC0gc3RhcnQ7XG4gICAgICAgICAgICByZXR1cm4gdHRsIC0gYWdlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLiNpc1N0YWxlID0gaW5kZXggPT4ge1xuICAgICAgICAgICAgY29uc3QgcyA9IHN0YXJ0c1tpbmRleF07XG4gICAgICAgICAgICBjb25zdCB0ID0gdHRsc1tpbmRleF07XG4gICAgICAgICAgICByZXR1cm4gISF0ICYmICEhcyAmJiAoY2FjaGVkTm93IHx8IGdldE5vdygpKSAtIHMgPiB0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBjb25kaXRpb25hbGx5IHNldCBwcml2YXRlIG1ldGhvZHMgcmVsYXRlZCB0byBUVExcbiAgICAjdXBkYXRlSXRlbUFnZSA9ICgpID0+IHsgfTtcbiAgICAjc3RhdHVzVFRMID0gKCkgPT4geyB9O1xuICAgICNzZXRJdGVtVFRMID0gKCkgPT4geyB9O1xuICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgI2lzU3RhbGUgPSAoKSA9PiBmYWxzZTtcbiAgICAjaW5pdGlhbGl6ZVNpemVUcmFja2luZygpIHtcbiAgICAgICAgY29uc3Qgc2l6ZXMgPSBuZXcgWmVyb0FycmF5KHRoaXMuI21heCk7XG4gICAgICAgIHRoaXMuI2NhbGN1bGF0ZWRTaXplID0gMDtcbiAgICAgICAgdGhpcy4jc2l6ZXMgPSBzaXplcztcbiAgICAgICAgdGhpcy4jcmVtb3ZlSXRlbVNpemUgPSBpbmRleCA9PiB7XG4gICAgICAgICAgICB0aGlzLiNjYWxjdWxhdGVkU2l6ZSAtPSBzaXplc1tpbmRleF07XG4gICAgICAgICAgICBzaXplc1tpbmRleF0gPSAwO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLiNyZXF1aXJlU2l6ZSA9IChrLCB2LCBzaXplLCBzaXplQ2FsY3VsYXRpb24pID0+IHtcbiAgICAgICAgICAgIC8vIHByb3Zpc2lvbmFsbHkgYWNjZXB0IGJhY2tncm91bmQgZmV0Y2hlcy5cbiAgICAgICAgICAgIC8vIGFjdHVhbCB2YWx1ZSBzaXplIHdpbGwgYmUgY2hlY2tlZCB3aGVuIHRoZXkgcmV0dXJuLlxuICAgICAgICAgICAgaWYgKHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzUG9zSW50KHNpemUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNpemVDYWxjdWxhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNpemVDYWxjdWxhdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZUNhbGN1bGF0aW9uIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSBzaXplQ2FsY3VsYXRpb24odiwgayk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNQb3NJbnQoc2l6ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemVDYWxjdWxhdGlvbiByZXR1cm4gaW52YWxpZCAoZXhwZWN0IHBvc2l0aXZlIGludGVnZXIpJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc2l6ZSB2YWx1ZSAobXVzdCBiZSBwb3NpdGl2ZSBpbnRlZ2VyKS4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnV2hlbiBtYXhTaXplIG9yIG1heEVudHJ5U2l6ZSBpcyB1c2VkLCBzaXplQ2FsY3VsYXRpb24gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3Igc2l6ZSBtdXN0IGJlIHNldC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy4jYWRkSXRlbVNpemUgPSAoaW5kZXgsIHNpemUsIHN0YXR1cykgPT4ge1xuICAgICAgICAgICAgc2l6ZXNbaW5kZXhdID0gc2l6ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLiNtYXhTaXplKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4U2l6ZSA9IHRoaXMuI21heFNpemUgLSBzaXplc1tpbmRleF07XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuI2NhbGN1bGF0ZWRTaXplID4gbWF4U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNldmljdCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNjYWxjdWxhdGVkU2l6ZSArPSBzaXplc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmVudHJ5U2l6ZSA9IHNpemU7XG4gICAgICAgICAgICAgICAgc3RhdHVzLnRvdGFsQ2FsY3VsYXRlZFNpemUgPSB0aGlzLiNjYWxjdWxhdGVkU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgI3JlbW92ZUl0ZW1TaXplID0gX2kgPT4geyB9O1xuICAgICNhZGRJdGVtU2l6ZSA9IChfaSwgX3MsIF9zdCkgPT4geyB9O1xuICAgICNyZXF1aXJlU2l6ZSA9IChfaywgX3YsIHNpemUsIHNpemVDYWxjdWxhdGlvbikgPT4ge1xuICAgICAgICBpZiAoc2l6ZSB8fCBzaXplQ2FsY3VsYXRpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Nhbm5vdCBzZXQgc2l6ZSB3aXRob3V0IHNldHRpbmcgbWF4U2l6ZSBvciBtYXhFbnRyeVNpemUgb24gY2FjaGUnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgICojaW5kZXhlcyh7IGFsbG93U3RhbGUgPSB0aGlzLmFsbG93U3RhbGUgfSA9IHt9KSB7XG4gICAgICAgIGlmICh0aGlzLiNzaXplKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy4jdGFpbDsgdHJ1ZTspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuI2lzVmFsaWRJbmRleChpKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFsbG93U3RhbGUgfHwgIXRoaXMuI2lzU3RhbGUoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IHRoaXMuI2hlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpID0gdGhpcy4jcHJldltpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgKiNyaW5kZXhlcyh7IGFsbG93U3RhbGUgPSB0aGlzLmFsbG93U3RhbGUgfSA9IHt9KSB7XG4gICAgICAgIGlmICh0aGlzLiNzaXplKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy4jaGVhZDsgdHJ1ZTspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuI2lzVmFsaWRJbmRleChpKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFsbG93U3RhbGUgfHwgIXRoaXMuI2lzU3RhbGUoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IHRoaXMuI3RhaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpID0gdGhpcy4jbmV4dFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgI2lzVmFsaWRJbmRleChpbmRleCkge1xuICAgICAgICByZXR1cm4gKGluZGV4ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHRoaXMuI2tleU1hcC5nZXQodGhpcy4ja2V5TGlzdFtpbmRleF0pID09PSBpbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGdlbmVyYXRvciB5aWVsZGluZyBgW2tleSwgdmFsdWVdYCBwYWlycyxcbiAgICAgKiBpbiBvcmRlciBmcm9tIG1vc3QgcmVjZW50bHkgdXNlZCB0byBsZWFzdCByZWNlbnRseSB1c2VkLlxuICAgICAqL1xuICAgICplbnRyaWVzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy4jaW5kZXhlcygpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jdmFsTGlzdFtpXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgdGhpcy4ja2V5TGlzdFtpXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHRoaXMuI3ZhbExpc3RbaV0pKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgW3RoaXMuI2tleUxpc3RbaV0sIHRoaXMuI3ZhbExpc3RbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludmVyc2Ugb3JkZXIgdmVyc2lvbiBvZiB7QGxpbmsgTFJVQ2FjaGUuZW50cmllc31cbiAgICAgKlxuICAgICAqIFJldHVybiBhIGdlbmVyYXRvciB5aWVsZGluZyBgW2tleSwgdmFsdWVdYCBwYWlycyxcbiAgICAgKiBpbiBvcmRlciBmcm9tIGxlYXN0IHJlY2VudGx5IHVzZWQgdG8gbW9zdCByZWNlbnRseSB1c2VkLlxuICAgICAqL1xuICAgICpyZW50cmllcygpIHtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHRoaXMuI3JpbmRleGVzKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiN2YWxMaXN0W2ldICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLiNrZXlMaXN0W2ldICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godGhpcy4jdmFsTGlzdFtpXSkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBbdGhpcy4ja2V5TGlzdFtpXSwgdGhpcy4jdmFsTGlzdFtpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIHlpZWxkaW5nIHRoZSBrZXlzIGluIHRoZSBjYWNoZSxcbiAgICAgKiBpbiBvcmRlciBmcm9tIG1vc3QgcmVjZW50bHkgdXNlZCB0byBsZWFzdCByZWNlbnRseSB1c2VkLlxuICAgICAqL1xuICAgICprZXlzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy4jaW5kZXhlcygpKSB7XG4gICAgICAgICAgICBjb25zdCBrID0gdGhpcy4ja2V5TGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChrICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godGhpcy4jdmFsTGlzdFtpXSkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludmVyc2Ugb3JkZXIgdmVyc2lvbiBvZiB7QGxpbmsgTFJVQ2FjaGUua2V5c31cbiAgICAgKlxuICAgICAqIFJldHVybiBhIGdlbmVyYXRvciB5aWVsZGluZyB0aGUga2V5cyBpbiB0aGUgY2FjaGUsXG4gICAgICogaW4gb3JkZXIgZnJvbSBsZWFzdCByZWNlbnRseSB1c2VkIHRvIG1vc3QgcmVjZW50bHkgdXNlZC5cbiAgICAgKi9cbiAgICAqcmtleXMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLiNyaW5kZXhlcygpKSB7XG4gICAgICAgICAgICBjb25zdCBrID0gdGhpcy4ja2V5TGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChrICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godGhpcy4jdmFsTGlzdFtpXSkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGdlbmVyYXRvciB5aWVsZGluZyB0aGUgdmFsdWVzIGluIHRoZSBjYWNoZSxcbiAgICAgKiBpbiBvcmRlciBmcm9tIG1vc3QgcmVjZW50bHkgdXNlZCB0byBsZWFzdCByZWNlbnRseSB1c2VkLlxuICAgICAqL1xuICAgICp2YWx1ZXMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLiNpbmRleGVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2ldO1xuICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh0aGlzLiN2YWxMaXN0W2ldKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuI3ZhbExpc3RbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52ZXJzZSBvcmRlciB2ZXJzaW9uIG9mIHtAbGluayBMUlVDYWNoZS52YWx1ZXN9XG4gICAgICpcbiAgICAgKiBSZXR1cm4gYSBnZW5lcmF0b3IgeWllbGRpbmcgdGhlIHZhbHVlcyBpbiB0aGUgY2FjaGUsXG4gICAgICogaW4gb3JkZXIgZnJvbSBsZWFzdCByZWNlbnRseSB1c2VkIHRvIG1vc3QgcmVjZW50bHkgdXNlZC5cbiAgICAgKi9cbiAgICAqcnZhbHVlcygpIHtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHRoaXMuI3JpbmRleGVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2ldO1xuICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh0aGlzLiN2YWxMaXN0W2ldKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuI3ZhbExpc3RbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSXRlcmF0aW5nIG92ZXIgdGhlIGNhY2hlIGl0c2VsZiB5aWVsZHMgdGhlIHNhbWUgcmVzdWx0cyBhc1xuICAgICAqIHtAbGluayBMUlVDYWNoZS5lbnRyaWVzfVxuICAgICAqL1xuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgU3RyaW5nIHZhbHVlIHRoYXQgaXMgdXNlZCBpbiB0aGUgY3JlYXRpb24gb2YgdGhlIGRlZmF1bHQgc3RyaW5nXG4gICAgICogZGVzY3JpcHRpb24gb2YgYW4gb2JqZWN0LiBDYWxsZWQgYnkgdGhlIGJ1aWx0LWluIG1ldGhvZFxuICAgICAqIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAgICAgKi9cbiAgICBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9ICdMUlVDYWNoZSc7XG4gICAgLyoqXG4gICAgICogRmluZCBhIHZhbHVlIGZvciB3aGljaCB0aGUgc3VwcGxpZWQgZm4gbWV0aG9kIHJldHVybnMgYSB0cnV0aHkgdmFsdWUsXG4gICAgICogc2ltaWxhciB0byBgQXJyYXkuZmluZCgpYC4gZm4gaXMgY2FsbGVkIGFzIGBmbih2YWx1ZSwga2V5LCBjYWNoZSlgLlxuICAgICAqL1xuICAgIGZpbmQoZm4sIGdldE9wdGlvbnMgPSB7fSkge1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy4jaW5kZXhlcygpKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpXTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godilcbiAgICAgICAgICAgICAgICA/IHYuX19zdGFsZVdoaWxlRmV0Y2hpbmdcbiAgICAgICAgICAgICAgICA6IHY7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChmbih2YWx1ZSwgdGhpcy4ja2V5TGlzdFtpXSwgdGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQodGhpcy4ja2V5TGlzdFtpXSwgZ2V0T3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbCB0aGUgc3VwcGxpZWQgZnVuY3Rpb24gb24gZWFjaCBpdGVtIGluIHRoZSBjYWNoZSwgaW4gb3JkZXIgZnJvbSBtb3N0XG4gICAgICogcmVjZW50bHkgdXNlZCB0byBsZWFzdCByZWNlbnRseSB1c2VkLlxuICAgICAqXG4gICAgICogYGZuYCBpcyBjYWxsZWQgYXMgYGZuKHZhbHVlLCBrZXksIGNhY2hlKWAuXG4gICAgICpcbiAgICAgKiBJZiBgdGhpc3BgIGlzIHByb3ZpZGVkLCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBpbiB0aGUgYHRoaXNgLWNvbnRleHQgb2ZcbiAgICAgKiB0aGUgcHJvdmlkZWQgb2JqZWN0LCBvciB0aGUgY2FjaGUgaWYgbm8gYHRoaXNwYCBvYmplY3QgaXMgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBEb2VzIG5vdCB1cGRhdGUgYWdlIG9yIHJlY2VudHkgb2YgdXNlLCBvciBpdGVyYXRlIG92ZXIgc3RhbGUgdmFsdWVzLlxuICAgICAqL1xuICAgIGZvckVhY2goZm4sIHRoaXNwID0gdGhpcykge1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy4jaW5kZXhlcygpKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpXTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godilcbiAgICAgICAgICAgICAgICA/IHYuX19zdGFsZVdoaWxlRmV0Y2hpbmdcbiAgICAgICAgICAgICAgICA6IHY7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGZuLmNhbGwodGhpc3AsIHZhbHVlLCB0aGlzLiNrZXlMaXN0W2ldLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgc2FtZSBhcyB7QGxpbmsgTFJVQ2FjaGUuZm9yRWFjaH0gYnV0IGl0ZW1zIGFyZSBpdGVyYXRlZCBvdmVyIGluXG4gICAgICogcmV2ZXJzZSBvcmRlci4gIChpZSwgbGVzcyByZWNlbnRseSB1c2VkIGl0ZW1zIGFyZSBpdGVyYXRlZCBvdmVyIGZpcnN0LilcbiAgICAgKi9cbiAgICByZm9yRWFjaChmbiwgdGhpc3AgPSB0aGlzKSB7XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLiNyaW5kZXhlcygpKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpXTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godilcbiAgICAgICAgICAgICAgICA/IHYuX19zdGFsZVdoaWxlRmV0Y2hpbmdcbiAgICAgICAgICAgICAgICA6IHY7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGZuLmNhbGwodGhpc3AsIHZhbHVlLCB0aGlzLiNrZXlMaXN0W2ldLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYW55IHN0YWxlIGVudHJpZXMuIFJldHVybnMgdHJ1ZSBpZiBhbnl0aGluZyB3YXMgcmVtb3ZlZCxcbiAgICAgKiBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgcHVyZ2VTdGFsZSgpIHtcbiAgICAgICAgbGV0IGRlbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHRoaXMuI3JpbmRleGVzKHsgYWxsb3dTdGFsZTogdHJ1ZSB9KSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2lzU3RhbGUoaSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNkZWxldGUodGhpcy4ja2V5TGlzdFtpXSwgJ2V4cGlyZScpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWxldGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGV4dGVuZGVkIGluZm8gYWJvdXQgYSBnaXZlbiBlbnRyeSwgdG8gZ2V0IGl0cyB2YWx1ZSwgc2l6ZSwgYW5kXG4gICAgICogVFRMIGluZm8gc2ltdWx0YW5lb3VzbHkuIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgdGhlIGtleSBpcyBub3QgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIFVubGlrZSB7QGxpbmsgTFJVQ2FjaGUjZHVtcH0sIHdoaWNoIGlzIGRlc2lnbmVkIHRvIGJlIHBvcnRhYmxlIGFuZCBzdXJ2aXZlXG4gICAgICogc2VyaWFsaXphdGlvbiwgdGhlIGBzdGFydGAgdmFsdWUgaXMgYWx3YXlzIHRoZSBjdXJyZW50IHRpbWVzdGFtcCwgYW5kIHRoZVxuICAgICAqIGB0dGxgIGlzIGEgY2FsY3VsYXRlZCByZW1haW5pbmcgdGltZSB0byBsaXZlIChuZWdhdGl2ZSBpZiBleHBpcmVkKS5cbiAgICAgKlxuICAgICAqIEFsd2F5cyByZXR1cm5zIHN0YWxlIHZhbHVlcywgaWYgdGhlaXIgaW5mbyBpcyBmb3VuZCBpbiB0aGUgY2FjaGUsIHNvIGJlXG4gICAgICogc3VyZSB0byBjaGVjayBmb3IgZXhwaXJhdGlvbnMgKGllLCBhIG5lZ2F0aXZlIHtAbGluayBMUlVDYWNoZS5FbnRyeSN0dGx9KVxuICAgICAqIGlmIHJlbGV2YW50LlxuICAgICAqL1xuICAgIGluZm8oa2V5KSB7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLiNrZXlNYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmIChpID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KVxuICAgICAgICAgICAgPyB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nXG4gICAgICAgICAgICA6IHY7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgZW50cnkgPSB7IHZhbHVlIH07XG4gICAgICAgIGlmICh0aGlzLiN0dGxzICYmIHRoaXMuI3N0YXJ0cykge1xuICAgICAgICAgICAgY29uc3QgdHRsID0gdGhpcy4jdHRsc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy4jc3RhcnRzW2ldO1xuICAgICAgICAgICAgaWYgKHR0bCAmJiBzdGFydCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbWFpbiA9IHR0bCAtIChwZXJmLm5vdygpIC0gc3RhcnQpO1xuICAgICAgICAgICAgICAgIGVudHJ5LnR0bCA9IHJlbWFpbjtcbiAgICAgICAgICAgICAgICBlbnRyeS5zdGFydCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI3NpemVzKSB7XG4gICAgICAgICAgICBlbnRyeS5zaXplID0gdGhpcy4jc2l6ZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgW2tleSwge0BsaW5rIExSVUNhY2hlLkVudHJ5fV0gdHVwbGVzIHdoaWNoIGNhbiBiZVxuICAgICAqIHBhc3NlZCB0byB7QGxpbmsgTFJMVUNhY2hlI2xvYWR9LlxuICAgICAqXG4gICAgICogVGhlIGBzdGFydGAgZmllbGRzIGFyZSBjYWxjdWxhdGVkIHJlbGF0aXZlIHRvIGEgcG9ydGFibGUgYERhdGUubm93KClgXG4gICAgICogdGltZXN0YW1wLCBldmVuIGlmIGBwZXJmb3JtYW5jZS5ub3coKWAgaXMgYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogU3RhbGUgZW50cmllcyBhcmUgYWx3YXlzIGluY2x1ZGVkIGluIHRoZSBgZHVtcGAsIGV2ZW4gaWZcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UuYWxsb3dTdGFsZX0gaXMgZmFsc2UuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIHJldHVybnMgYW4gYWN0dWFsIGFycmF5LCBub3QgYSBnZW5lcmF0b3IsIHNvIGl0IGNhbiBiZSBtb3JlXG4gICAgICogZWFzaWx5IHBhc3NlZCBhcm91bmQuXG4gICAgICovXG4gICAgZHVtcCgpIHtcbiAgICAgICAgY29uc3QgYXJyID0gW107XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLiNpbmRleGVzKHsgYWxsb3dTdGFsZTogdHJ1ZSB9KSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy4ja2V5TGlzdFtpXTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2ldO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KVxuICAgICAgICAgICAgICAgID8gdi5fX3N0YWxlV2hpbGVGZXRjaGluZ1xuICAgICAgICAgICAgICAgIDogdjtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGtleSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgZW50cnkgPSB7IHZhbHVlIH07XG4gICAgICAgICAgICBpZiAodGhpcy4jdHRscyAmJiB0aGlzLiNzdGFydHMpIHtcbiAgICAgICAgICAgICAgICBlbnRyeS50dGwgPSB0aGlzLiN0dGxzW2ldO1xuICAgICAgICAgICAgICAgIC8vIGFsd2F5cyBkdW1wIHRoZSBzdGFydCByZWxhdGl2ZSB0byBhIHBvcnRhYmxlIHRpbWVzdGFtcFxuICAgICAgICAgICAgICAgIC8vIGl0J3Mgb2sgZm9yIHRoaXMgdG8gYmUgYSBiaXQgc2xvdywgaXQncyBhIHJhcmUgb3BlcmF0aW9uLlxuICAgICAgICAgICAgICAgIGNvbnN0IGFnZSA9IHBlcmYubm93KCkgLSB0aGlzLiNzdGFydHNbaV07XG4gICAgICAgICAgICAgICAgZW50cnkuc3RhcnQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLSBhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuI3NpemVzKSB7XG4gICAgICAgICAgICAgICAgZW50cnkuc2l6ZSA9IHRoaXMuI3NpemVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJyLnVuc2hpZnQoW2tleSwgZW50cnldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgY2FjaGUgYW5kIGxvYWQgaW4gdGhlIGl0ZW1zIGluIGVudHJpZXMgaW4gdGhlIG9yZGVyIGxpc3RlZC5cbiAgICAgKlxuICAgICAqIFRoZSBzaGFwZSBvZiB0aGUgcmVzdWx0aW5nIGNhY2hlIG1heSBiZSBkaWZmZXJlbnQgaWYgdGhlIHNhbWUgb3B0aW9ucyBhcmVcbiAgICAgKiBub3QgdXNlZCBpbiBib3RoIGNhY2hlcy5cbiAgICAgKlxuICAgICAqIFRoZSBgc3RhcnRgIGZpZWxkcyBhcmUgYXNzdW1lZCB0byBiZSBjYWxjdWxhdGVkIHJlbGF0aXZlIHRvIGEgcG9ydGFibGVcbiAgICAgKiBgRGF0ZS5ub3coKWAgdGltZXN0YW1wLCBldmVuIGlmIGBwZXJmb3JtYW5jZS5ub3coKWAgaXMgYXZhaWxhYmxlLlxuICAgICAqL1xuICAgIGxvYWQoYXJyKSB7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBlbnRyeV0gb2YgYXJyKSB7XG4gICAgICAgICAgICBpZiAoZW50cnkuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAvLyBlbnRyeS5zdGFydCBpcyBhIHBvcnRhYmxlIHRpbWVzdGFtcCwgYnV0IHdlIG1heSBiZSB1c2luZ1xuICAgICAgICAgICAgICAgIC8vIG5vZGUncyBwZXJmb3JtYW5jZS5ub3coKSwgc28gY2FsY3VsYXRlIHRoZSBvZmZzZXQsIHNvIHRoYXRcbiAgICAgICAgICAgICAgICAvLyB3ZSBnZXQgdGhlIGludGVuZGVkIHJlbWFpbmluZyBUVEwsIG5vIG1hdHRlciBob3cgbG9uZyBpdCdzXG4gICAgICAgICAgICAgICAgLy8gYmVlbiBvbiBpY2UuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBpdCdzIG9rIGZvciB0aGlzIHRvIGJlIGEgYml0IHNsb3csIGl0J3MgYSByYXJlIG9wZXJhdGlvbi5cbiAgICAgICAgICAgICAgICBjb25zdCBhZ2UgPSBEYXRlLm5vdygpIC0gZW50cnkuc3RhcnQ7XG4gICAgICAgICAgICAgICAgZW50cnkuc3RhcnQgPSBwZXJmLm5vdygpIC0gYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCBlbnRyeS52YWx1ZSwgZW50cnkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIHZhbHVlIHRvIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIE5vdGU6IGlmIGB1bmRlZmluZWRgIGlzIHNwZWNpZmllZCBhcyBhIHZhbHVlLCB0aGlzIGlzIGFuIGFsaWFzIGZvclxuICAgICAqIHtAbGluayBMUlVDYWNoZSNkZWxldGV9XG4gICAgICpcbiAgICAgKiBGaWVsZHMgb24gdGhlIHtAbGluayBMUlVDYWNoZS5TZXRPcHRpb25zfSBvcHRpb25zIHBhcmFtIHdpbGwgb3ZlcnJpZGVcbiAgICAgKiB0aGVpciBjb3JyZXNwb25kaW5nIHZhbHVlcyBpbiB0aGUgY29uc3RydWN0b3Igb3B0aW9ucyBmb3IgdGhlIHNjb3BlXG4gICAgICogb2YgdGhpcyBzaW5nbGUgYHNldCgpYCBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBJZiBgc3RhcnRgIGlzIHByb3ZpZGVkLCB0aGVuIHRoYXQgd2lsbCBzZXQgdGhlIGVmZmVjdGl2ZSBzdGFydFxuICAgICAqIHRpbWUgZm9yIHRoZSBUVEwgY2FsY3VsYXRpb24uIE5vdGUgdGhhdCB0aGlzIG11c3QgYmUgYSBwcmV2aW91c1xuICAgICAqIHZhbHVlIG9mIGBwZXJmb3JtYW5jZS5ub3coKWAgaWYgc3VwcG9ydGVkLCBvciBhIHByZXZpb3VzIHZhbHVlIG9mXG4gICAgICogYERhdGUubm93KClgIGlmIG5vdC5cbiAgICAgKlxuICAgICAqIE9wdGlvbnMgb2JqZWN0IG1heSBhbHNvIGluY2x1ZGUgYHNpemVgLCB3aGljaCB3aWxsIHByZXZlbnRcbiAgICAgKiBjYWxsaW5nIHRoZSBgc2l6ZUNhbGN1bGF0aW9uYCBmdW5jdGlvbiBhbmQganVzdCB1c2UgdGhlIHNwZWNpZmllZFxuICAgICAqIG51bWJlciBpZiBpdCBpcyBhIHBvc2l0aXZlIGludGVnZXIsIGFuZCBgbm9EaXNwb3NlT25TZXRgIHdoaWNoXG4gICAgICogd2lsbCBwcmV2ZW50IGNhbGxpbmcgYSBgZGlzcG9zZWAgZnVuY3Rpb24gaW4gdGhlIGNhc2Ugb2ZcbiAgICAgKiBvdmVyd3JpdGVzLlxuICAgICAqXG4gICAgICogSWYgdGhlIGBzaXplYCAob3IgcmV0dXJuIHZhbHVlIG9mIGBzaXplQ2FsY3VsYXRpb25gKSBmb3IgYSBnaXZlblxuICAgICAqIGVudHJ5IGlzIGdyZWF0ZXIgdGhhbiBgbWF4RW50cnlTaXplYCwgdGhlbiB0aGUgaXRlbSB3aWxsIG5vdCBiZVxuICAgICAqIGFkZGVkIHRvIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIFdpbGwgdXBkYXRlIHRoZSByZWNlbmN5IG9mIHRoZSBlbnRyeS5cbiAgICAgKlxuICAgICAqIElmIHRoZSB2YWx1ZSBpcyBgdW5kZWZpbmVkYCwgdGhlbiB0aGlzIGlzIGFuIGFsaWFzIGZvclxuICAgICAqIGBjYWNoZS5kZWxldGUoa2V5KWAuIGB1bmRlZmluZWRgIGlzIG5ldmVyIHN0b3JlZCBpbiB0aGUgY2FjaGUuXG4gICAgICovXG4gICAgc2V0KGssIHYsIHNldE9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZShrKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdHRsID0gdGhpcy50dGwsIHN0YXJ0LCBub0Rpc3Bvc2VPblNldCA9IHRoaXMubm9EaXNwb3NlT25TZXQsIHNpemVDYWxjdWxhdGlvbiA9IHRoaXMuc2l6ZUNhbGN1bGF0aW9uLCBzdGF0dXMsIH0gPSBzZXRPcHRpb25zO1xuICAgICAgICBsZXQgeyBub1VwZGF0ZVRUTCA9IHRoaXMubm9VcGRhdGVUVEwgfSA9IHNldE9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLiNyZXF1aXJlU2l6ZShrLCB2LCBzZXRPcHRpb25zLnNpemUgfHwgMCwgc2l6ZUNhbGN1bGF0aW9uKTtcbiAgICAgICAgLy8gaWYgdGhlIGl0ZW0gZG9lc24ndCBmaXQsIGRvbid0IGRvIGFueXRoaW5nXG4gICAgICAgIC8vIE5COiBtYXhFbnRyeVNpemUgc2V0IHRvIG1heFNpemUgYnkgZGVmYXVsdFxuICAgICAgICBpZiAodGhpcy5tYXhFbnRyeVNpemUgJiYgc2l6ZSA+IHRoaXMubWF4RW50cnlTaXplKSB7XG4gICAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLnNldCA9ICdtaXNzJztcbiAgICAgICAgICAgICAgICBzdGF0dXMubWF4RW50cnlTaXplRXhjZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaGF2ZSB0byBkZWxldGUsIGluIGNhc2Ugc29tZXRoaW5nIGlzIHRoZXJlIGFscmVhZHkuXG4gICAgICAgICAgICB0aGlzLiNkZWxldGUoaywgJ3NldCcpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy4jc2l6ZSA9PT0gMCA/IHVuZGVmaW5lZCA6IHRoaXMuI2tleU1hcC5nZXQoayk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBhZGRpdGlvblxuICAgICAgICAgICAgaW5kZXggPSAodGhpcy4jc2l6ZSA9PT0gMFxuICAgICAgICAgICAgICAgID8gdGhpcy4jdGFpbFxuICAgICAgICAgICAgICAgIDogdGhpcy4jZnJlZS5sZW5ndGggIT09IDBcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLiNmcmVlLnBvcCgpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy4jc2l6ZSA9PT0gdGhpcy4jbWF4XG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuI2V2aWN0KGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLiNzaXplKTtcbiAgICAgICAgICAgIHRoaXMuI2tleUxpc3RbaW5kZXhdID0gaztcbiAgICAgICAgICAgIHRoaXMuI3ZhbExpc3RbaW5kZXhdID0gdjtcbiAgICAgICAgICAgIHRoaXMuI2tleU1hcC5zZXQoaywgaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy4jbmV4dFt0aGlzLiN0YWlsXSA9IGluZGV4O1xuICAgICAgICAgICAgdGhpcy4jcHJldltpbmRleF0gPSB0aGlzLiN0YWlsO1xuICAgICAgICAgICAgdGhpcy4jdGFpbCA9IGluZGV4O1xuICAgICAgICAgICAgdGhpcy4jc2l6ZSsrO1xuICAgICAgICAgICAgdGhpcy4jYWRkSXRlbVNpemUoaW5kZXgsIHNpemUsIHN0YXR1cyk7XG4gICAgICAgICAgICBpZiAoc3RhdHVzKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5zZXQgPSAnYWRkJztcbiAgICAgICAgICAgIG5vVXBkYXRlVFRMID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB1cGRhdGVcbiAgICAgICAgICAgIHRoaXMuI21vdmVUb1RhaWwoaW5kZXgpO1xuICAgICAgICAgICAgY29uc3Qgb2xkVmFsID0gdGhpcy4jdmFsTGlzdFtpbmRleF07XG4gICAgICAgICAgICBpZiAodiAhPT0gb2xkVmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI2hhc0ZldGNoTWV0aG9kICYmIHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKG9sZFZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsLl9fYWJvcnRDb250cm9sbGVyLmFib3J0KG5ldyBFcnJvcigncmVwbGFjZWQnKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgX19zdGFsZVdoaWxlRmV0Y2hpbmc6IHMgfSA9IG9sZFZhbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMgIT09IHVuZGVmaW5lZCAmJiAhbm9EaXNwb3NlT25TZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZT8uKHMsIGssICdzZXQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlZD8ucHVzaChbcywgaywgJ3NldCddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghbm9EaXNwb3NlT25TZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2U/LihvbGRWYWwsIGssICdzZXQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZUFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlZD8ucHVzaChbb2xkVmFsLCBrLCAnc2V0J10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuI3JlbW92ZUl0ZW1TaXplKGluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLiNhZGRJdGVtU2l6ZShpbmRleCwgc2l6ZSwgc3RhdHVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLiN2YWxMaXN0W2luZGV4XSA9IHY7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuc2V0ID0gJ3JlcGxhY2UnO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IG9sZFZhbCAmJiB0aGlzLiNpc0JhY2tncm91bmRGZXRjaChvbGRWYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG9sZFZhbC5fX3N0YWxlV2hpbGVGZXRjaGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBvbGRWYWw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLm9sZFZhbHVlID0gb2xkVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLnNldCA9ICd1cGRhdGUnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0dGwgIT09IDAgJiYgIXRoaXMuI3R0bHMpIHtcbiAgICAgICAgICAgIHRoaXMuI2luaXRpYWxpemVUVExUcmFja2luZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiN0dGxzKSB7XG4gICAgICAgICAgICBpZiAoIW5vVXBkYXRlVFRMKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jc2V0SXRlbVRUTChpbmRleCwgdHRsLCBzdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdHVzKVxuICAgICAgICAgICAgICAgIHRoaXMuI3N0YXR1c1RUTChzdGF0dXMsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vRGlzcG9zZU9uU2V0ICYmIHRoaXMuI2hhc0Rpc3Bvc2VBZnRlciAmJiB0aGlzLiNkaXNwb3NlZCkge1xuICAgICAgICAgICAgY29uc3QgZHQgPSB0aGlzLiNkaXNwb3NlZDtcbiAgICAgICAgICAgIGxldCB0YXNrO1xuICAgICAgICAgICAgd2hpbGUgKCh0YXNrID0gZHQ/LnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZUFmdGVyPy4oLi4udGFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2aWN0IHRoZSBsZWFzdCByZWNlbnRseSB1c2VkIGl0ZW0sIHJldHVybmluZyBpdHMgdmFsdWUgb3JcbiAgICAgKiBgdW5kZWZpbmVkYCBpZiBjYWNoZSBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBwb3AoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy4jc2l6ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IHRoaXMuI3ZhbExpc3RbdGhpcy4jaGVhZF07XG4gICAgICAgICAgICAgICAgdGhpcy4jZXZpY3QodHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbC5fX3N0YWxlV2hpbGVGZXRjaGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbC5fX3N0YWxlV2hpbGVGZXRjaGluZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlQWZ0ZXIgJiYgdGhpcy4jZGlzcG9zZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkdCA9IHRoaXMuI2Rpc3Bvc2VkO1xuICAgICAgICAgICAgICAgIGxldCB0YXNrO1xuICAgICAgICAgICAgICAgIHdoaWxlICgodGFzayA9IGR0Py5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlQWZ0ZXI/LiguLi50YXNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgI2V2aWN0KGZyZWUpIHtcbiAgICAgICAgY29uc3QgaGVhZCA9IHRoaXMuI2hlYWQ7XG4gICAgICAgIGNvbnN0IGsgPSB0aGlzLiNrZXlMaXN0W2hlYWRdO1xuICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtoZWFkXTtcbiAgICAgICAgaWYgKHRoaXMuI2hhc0ZldGNoTWV0aG9kICYmIHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpKSB7XG4gICAgICAgICAgICB2Ll9fYWJvcnRDb250cm9sbGVyLmFib3J0KG5ldyBFcnJvcignZXZpY3RlZCcpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLiNoYXNEaXNwb3NlIHx8IHRoaXMuI2hhc0Rpc3Bvc2VBZnRlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlPy4odiwgaywgJ2V2aWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZUFmdGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZWQ/LnB1c2goW3YsIGssICdldmljdCddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNyZW1vdmVJdGVtU2l6ZShoZWFkKTtcbiAgICAgICAgLy8gaWYgd2UgYXJlbid0IGFib3V0IHRvIHVzZSB0aGUgaW5kZXgsIHRoZW4gbnVsbCB0aGVzZSBvdXRcbiAgICAgICAgaWYgKGZyZWUpIHtcbiAgICAgICAgICAgIHRoaXMuI2tleUxpc3RbaGVhZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLiN2YWxMaXN0W2hlYWRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy4jZnJlZS5wdXNoKGhlYWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiNzaXplID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLiNoZWFkID0gdGhpcy4jdGFpbCA9IDA7XG4gICAgICAgICAgICB0aGlzLiNmcmVlLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNoZWFkID0gdGhpcy4jbmV4dFtoZWFkXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNrZXlNYXAuZGVsZXRlKGspO1xuICAgICAgICB0aGlzLiNzaXplLS07XG4gICAgICAgIHJldHVybiBoZWFkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIGtleSBpcyBpbiB0aGUgY2FjaGUsIHdpdGhvdXQgdXBkYXRpbmcgdGhlIHJlY2VuY3kgb2YgdXNlLlxuICAgICAqIFdpbGwgcmV0dXJuIGZhbHNlIGlmIHRoZSBpdGVtIGlzIHN0YWxlLCBldmVuIHRob3VnaCBpdCBpcyB0ZWNobmljYWxseVxuICAgICAqIGluIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIENoZWNrIGlmIGEga2V5IGlzIGluIHRoZSBjYWNoZSwgd2l0aG91dCB1cGRhdGluZyB0aGUgcmVjZW5jeSBvZlxuICAgICAqIHVzZS4gQWdlIGlzIHVwZGF0ZWQgaWYge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLnVwZGF0ZUFnZU9uSGFzfSBpcyBzZXRcbiAgICAgKiB0byBgdHJ1ZWAgaW4gZWl0aGVyIHRoZSBvcHRpb25zIG9yIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIFdpbGwgcmV0dXJuIGBmYWxzZWAgaWYgdGhlIGl0ZW0gaXMgc3RhbGUsIGV2ZW4gdGhvdWdoIGl0IGlzIHRlY2huaWNhbGx5IGluXG4gICAgICogdGhlIGNhY2hlLiBUaGUgZGlmZmVyZW5jZSBjYW4gYmUgZGV0ZXJtaW5lZCAoaWYgaXQgbWF0dGVycykgYnkgdXNpbmcgYVxuICAgICAqIGBzdGF0dXNgIGFyZ3VtZW50LCBhbmQgaW5zcGVjdGluZyB0aGUgYGhhc2AgZmllbGQuXG4gICAgICpcbiAgICAgKiBXaWxsIG5vdCB1cGRhdGUgaXRlbSBhZ2UgdW5sZXNzXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLnVwZGF0ZUFnZU9uSGFzfSBpcyBzZXQuXG4gICAgICovXG4gICAgaGFzKGssIGhhc09wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IHVwZGF0ZUFnZU9uSGFzID0gdGhpcy51cGRhdGVBZ2VPbkhhcywgc3RhdHVzIH0gPSBoYXNPcHRpb25zO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuI2tleU1hcC5nZXQoayk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpbmRleF07XG4gICAgICAgICAgICBpZiAodGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godikgJiZcbiAgICAgICAgICAgICAgICB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuI2lzU3RhbGUoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZUFnZU9uSGFzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3VwZGF0ZUl0ZW1BZ2UoaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5oYXMgPSAnaGl0JztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jc3RhdHVzVFRMKHN0YXR1cywgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5oYXMgPSAnc3RhbGUnO1xuICAgICAgICAgICAgICAgIHRoaXMuI3N0YXR1c1RUTChzdGF0dXMsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgIHN0YXR1cy5oYXMgPSAnbWlzcyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaWtlIHtAbGluayBMUlVDYWNoZSNnZXR9IGJ1dCBkb2Vzbid0IHVwZGF0ZSByZWNlbmN5IG9yIGRlbGV0ZSBzdGFsZVxuICAgICAqIGl0ZW1zLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdW5kZWZpbmVkYCBpZiB0aGUgaXRlbSBpcyBzdGFsZSwgdW5sZXNzXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLmFsbG93U3RhbGV9IGlzIHNldC5cbiAgICAgKi9cbiAgICBwZWVrKGssIHBlZWtPcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBhbGxvd1N0YWxlID0gdGhpcy5hbGxvd1N0YWxlIH0gPSBwZWVrT3B0aW9ucztcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLiNrZXlNYXAuZ2V0KGspO1xuICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgKCFhbGxvd1N0YWxlICYmIHRoaXMuI2lzU3RhbGUoaW5kZXgpKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2luZGV4XTtcbiAgICAgICAgLy8gZWl0aGVyIHN0YWxlIGFuZCBhbGxvd2VkLCBvciBmb3JjaW5nIGEgcmVmcmVzaCBvZiBub24tc3RhbGUgdmFsdWVcbiAgICAgICAgcmV0dXJuIHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpID8gdi5fX3N0YWxlV2hpbGVGZXRjaGluZyA6IHY7XG4gICAgfVxuICAgICNiYWNrZ3JvdW5kRmV0Y2goaywgaW5kZXgsIG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgdiA9IGluZGV4ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiB0aGlzLiN2YWxMaXN0W2luZGV4XTtcbiAgICAgICAgaWYgKHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpKSB7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhYyA9IG5ldyBBQygpO1xuICAgICAgICBjb25zdCB7IHNpZ25hbCB9ID0gb3B0aW9ucztcbiAgICAgICAgLy8gd2hlbi9pZiBvdXIgQUMgc2lnbmFscywgdGhlbiBzdG9wIGxpc3RlbmluZyB0byB0aGVpcnMuXG4gICAgICAgIHNpZ25hbD8uYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiBhYy5hYm9ydChzaWduYWwucmVhc29uKSwge1xuICAgICAgICAgICAgc2lnbmFsOiBhYy5zaWduYWwsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBmZXRjaE9wdHMgPSB7XG4gICAgICAgICAgICBzaWduYWw6IGFjLnNpZ25hbCxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjYiA9ICh2LCB1cGRhdGVDYWNoZSA9IGZhbHNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGFib3J0ZWQgfSA9IGFjLnNpZ25hbDtcbiAgICAgICAgICAgIGNvbnN0IGlnbm9yZUFib3J0ID0gb3B0aW9ucy5pZ25vcmVGZXRjaEFib3J0ICYmIHYgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXR1cykge1xuICAgICAgICAgICAgICAgIGlmIChhYm9ydGVkICYmICF1cGRhdGVDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnN0YXR1cy5mZXRjaEFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnN0YXR1cy5mZXRjaEVycm9yID0gYWMuc2lnbmFsLnJlYXNvbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlnbm9yZUFib3J0KVxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zdGF0dXMuZmV0Y2hBYm9ydElnbm9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zdGF0dXMuZmV0Y2hSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFib3J0ZWQgJiYgIWlnbm9yZUFib3J0ICYmICF1cGRhdGVDYWNoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaEZhaWwoYWMuc2lnbmFsLnJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlaXRoZXIgd2UgZGlkbid0IGFib3J0LCBhbmQgYXJlIHN0aWxsIGhlcmUsIG9yIHdlIGRpZCwgYW5kIGlnbm9yZWRcbiAgICAgICAgICAgIGNvbnN0IGJmID0gcDtcbiAgICAgICAgICAgIGlmICh0aGlzLiN2YWxMaXN0W2luZGV4XSA9PT0gcCkge1xuICAgICAgICAgICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJmLl9fc3RhbGVXaGlsZUZldGNoaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiN2YWxMaXN0W2luZGV4XSA9IGJmLl9fc3RhbGVXaGlsZUZldGNoaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jZGVsZXRlKGssICdmZXRjaCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdGF0dXMpXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnN0YXR1cy5mZXRjaFVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldChrLCB2LCBmZXRjaE9wdHMub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGViID0gKGVyKSA9PiB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnN0YXR1cy5mZXRjaFJlamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnN0YXR1cy5mZXRjaEVycm9yID0gZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hGYWlsKGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmV0Y2hGYWlsID0gKGVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGFib3J0ZWQgfSA9IGFjLnNpZ25hbDtcbiAgICAgICAgICAgIGNvbnN0IGFsbG93U3RhbGVBYm9ydGVkID0gYWJvcnRlZCAmJiBvcHRpb25zLmFsbG93U3RhbGVPbkZldGNoQWJvcnQ7XG4gICAgICAgICAgICBjb25zdCBhbGxvd1N0YWxlID0gYWxsb3dTdGFsZUFib3J0ZWQgfHwgb3B0aW9ucy5hbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IG5vRGVsZXRlID0gYWxsb3dTdGFsZSB8fCBvcHRpb25zLm5vRGVsZXRlT25GZXRjaFJlamVjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGJmID0gcDtcbiAgICAgICAgICAgIGlmICh0aGlzLiN2YWxMaXN0W2luZGV4XSA9PT0gcCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFsbG93IHN0YWxlIG9uIGZldGNoIHJlamVjdGlvbnMsIHRoZW4gd2UgbmVlZCB0byBlbnN1cmUgdGhhdFxuICAgICAgICAgICAgICAgIC8vIHRoZSBzdGFsZSB2YWx1ZSBpcyBub3QgcmVtb3ZlZCBmcm9tIHRoZSBjYWNoZSB3aGVuIHRoZSBmZXRjaCBmYWlscy5cbiAgICAgICAgICAgICAgICBjb25zdCBkZWwgPSAhbm9EZWxldGUgfHwgYmYuX19zdGFsZVdoaWxlRmV0Y2hpbmcgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAoZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2RlbGV0ZShrLCAnZmV0Y2gnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWFsbG93U3RhbGVBYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0aWxsIHJlcGxhY2UgdGhlICpwcm9taXNlKiB3aXRoIHRoZSBzdGFsZSB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luY2Ugd2UgYXJlIGRvbmUgd2l0aCB0aGUgcHJvbWlzZSBhdCB0aGlzIHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAvLyBsZWF2ZSBpdCB1bnRvdWNoZWQgaWYgd2UncmUgc3RpbGwgd2FpdGluZyBmb3IgYW5cbiAgICAgICAgICAgICAgICAgICAgLy8gYWJvcnRlZCBiYWNrZ3JvdW5kIGZldGNoIHRoYXQgaGFzbid0IHlldCByZXR1cm5lZC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jdmFsTGlzdFtpbmRleF0gPSBiZi5fX3N0YWxlV2hpbGVGZXRjaGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxsb3dTdGFsZSkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXR1cyAmJiBiZi5fX3N0YWxlV2hpbGVGZXRjaGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RhdHVzLnJldHVybmVkU3RhbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYmYuX19zdGFsZVdoaWxlRmV0Y2hpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiZi5fX3JldHVybmVkID09PSBiZikge1xuICAgICAgICAgICAgICAgIHRocm93IGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwY2FsbCA9IChyZXMsIHJlaikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZm1wID0gdGhpcy4jZmV0Y2hNZXRob2Q/LihrLCB2LCBmZXRjaE9wdHMpO1xuICAgICAgICAgICAgaWYgKGZtcCAmJiBmbXAgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgZm1wLnRoZW4odiA9PiByZXModiA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogdiksIHJlaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZ25vcmVkLCB3ZSBnbyB1bnRpbCB3ZSBmaW5pc2gsIHJlZ2FyZGxlc3MuXG4gICAgICAgICAgICAvLyBkZWZlciBjaGVjayB1bnRpbCB3ZSBhcmUgYWN0dWFsbHkgYWJvcnRpbmcsXG4gICAgICAgICAgICAvLyBzbyBmZXRjaE1ldGhvZCBjYW4gb3ZlcnJpZGUuXG4gICAgICAgICAgICBhYy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmlnbm9yZUZldGNoQWJvcnQgfHxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5hbGxvd1N0YWxlT25GZXRjaEFib3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGl0IGV2ZW50dWFsbHkgcmVzb2x2ZXMsIHVwZGF0ZSB0aGUgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFsbG93U3RhbGVPbkZldGNoQWJvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IHYgPT4gY2IodiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3RhdHVzKVxuICAgICAgICAgICAgb3B0aW9ucy5zdGF0dXMuZmV0Y2hEaXNwYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgcCA9IG5ldyBQcm9taXNlKHBjYWxsKS50aGVuKGNiLCBlYik7XG4gICAgICAgIGNvbnN0IGJmID0gT2JqZWN0LmFzc2lnbihwLCB7XG4gICAgICAgICAgICBfX2Fib3J0Q29udHJvbGxlcjogYWMsXG4gICAgICAgICAgICBfX3N0YWxlV2hpbGVGZXRjaGluZzogdixcbiAgICAgICAgICAgIF9fcmV0dXJuZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBpbnRlcm5hbCwgZG9uJ3QgZXhwb3NlIHN0YXR1cy5cbiAgICAgICAgICAgIHRoaXMuc2V0KGssIGJmLCB7IC4uLmZldGNoT3B0cy5vcHRpb25zLCBzdGF0dXM6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy4ja2V5TWFwLmdldChrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI3ZhbExpc3RbaW5kZXhdID0gYmY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJmO1xuICAgIH1cbiAgICAjaXNCYWNrZ3JvdW5kRmV0Y2gocCkge1xuICAgICAgICBpZiAoIXRoaXMuI2hhc0ZldGNoTWV0aG9kKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBiID0gcDtcbiAgICAgICAgcmV0dXJuICghIWIgJiZcbiAgICAgICAgICAgIGIgaW5zdGFuY2VvZiBQcm9taXNlICYmXG4gICAgICAgICAgICBiLmhhc093blByb3BlcnR5KCdfX3N0YWxlV2hpbGVGZXRjaGluZycpICYmXG4gICAgICAgICAgICBiLl9fYWJvcnRDb250cm9sbGVyIGluc3RhbmNlb2YgQUMpO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaChrLCBmZXRjaE9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IFxuICAgICAgICAvLyBnZXQgb3B0aW9uc1xuICAgICAgICBhbGxvd1N0YWxlID0gdGhpcy5hbGxvd1N0YWxlLCB1cGRhdGVBZ2VPbkdldCA9IHRoaXMudXBkYXRlQWdlT25HZXQsIG5vRGVsZXRlT25TdGFsZUdldCA9IHRoaXMubm9EZWxldGVPblN0YWxlR2V0LCBcbiAgICAgICAgLy8gc2V0IG9wdGlvbnNcbiAgICAgICAgdHRsID0gdGhpcy50dGwsIG5vRGlzcG9zZU9uU2V0ID0gdGhpcy5ub0Rpc3Bvc2VPblNldCwgc2l6ZSA9IDAsIHNpemVDYWxjdWxhdGlvbiA9IHRoaXMuc2l6ZUNhbGN1bGF0aW9uLCBub1VwZGF0ZVRUTCA9IHRoaXMubm9VcGRhdGVUVEwsIFxuICAgICAgICAvLyBmZXRjaCBleGNsdXNpdmUgb3B0aW9uc1xuICAgICAgICBub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb24gPSB0aGlzLm5vRGVsZXRlT25GZXRjaFJlamVjdGlvbiwgYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb24gPSB0aGlzLmFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uLCBpZ25vcmVGZXRjaEFib3J0ID0gdGhpcy5pZ25vcmVGZXRjaEFib3J0LCBhbGxvd1N0YWxlT25GZXRjaEFib3J0ID0gdGhpcy5hbGxvd1N0YWxlT25GZXRjaEFib3J0LCBjb250ZXh0LCBmb3JjZVJlZnJlc2ggPSBmYWxzZSwgc3RhdHVzLCBzaWduYWwsIH0gPSBmZXRjaE9wdGlvbnM7XG4gICAgICAgIGlmICghdGhpcy4jaGFzRmV0Y2hNZXRob2QpIHtcbiAgICAgICAgICAgIGlmIChzdGF0dXMpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmZldGNoID0gJ2dldCc7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoaywge1xuICAgICAgICAgICAgICAgIGFsbG93U3RhbGUsXG4gICAgICAgICAgICAgICAgdXBkYXRlQWdlT25HZXQsXG4gICAgICAgICAgICAgICAgbm9EZWxldGVPblN0YWxlR2V0LFxuICAgICAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhbGxvd1N0YWxlLFxuICAgICAgICAgICAgdXBkYXRlQWdlT25HZXQsXG4gICAgICAgICAgICBub0RlbGV0ZU9uU3RhbGVHZXQsXG4gICAgICAgICAgICB0dGwsXG4gICAgICAgICAgICBub0Rpc3Bvc2VPblNldCxcbiAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICBzaXplQ2FsY3VsYXRpb24sXG4gICAgICAgICAgICBub1VwZGF0ZVRUTCxcbiAgICAgICAgICAgIG5vRGVsZXRlT25GZXRjaFJlamVjdGlvbixcbiAgICAgICAgICAgIGFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uLFxuICAgICAgICAgICAgYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydCxcbiAgICAgICAgICAgIGlnbm9yZUZldGNoQWJvcnQsXG4gICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICBzaWduYWwsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuI2tleU1hcC5nZXQoayk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoc3RhdHVzKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5mZXRjaCA9ICdtaXNzJztcbiAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLiNiYWNrZ3JvdW5kRmV0Y2goaywgaW5kZXgsIG9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIChwLl9fcmV0dXJuZWQgPSBwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGluIGNhY2hlLCBtYXliZSBhbHJlYWR5IGZldGNoaW5nXG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpbmRleF07XG4gICAgICAgICAgICBpZiAodGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFsZSA9IGFsbG93U3RhbGUgJiYgdi5fX3N0YWxlV2hpbGVGZXRjaGluZyAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmZldGNoID0gJ2luZmxpZ2h0JztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnJldHVybmVkU3RhbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhbGUgPyB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nIDogKHYuX19yZXR1cm5lZCA9IHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgd2UgZm9yY2UgYSByZWZyZXNoLCB0aGF0IG1lYW5zIGRvIE5PVCBzZXJ2ZSB0aGUgY2FjaGVkIHZhbHVlLFxuICAgICAgICAgICAgLy8gdW5sZXNzIHdlIGFyZSBhbHJlYWR5IGluIHRoZSBwcm9jZXNzIG9mIHJlZnJlc2hpbmcgdGhlIGNhY2hlLlxuICAgICAgICAgICAgY29uc3QgaXNTdGFsZSA9IHRoaXMuI2lzU3RhbGUoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKCFmb3JjZVJlZnJlc2ggJiYgIWlzU3RhbGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzKVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZmV0Y2ggPSAnaGl0JztcbiAgICAgICAgICAgICAgICB0aGlzLiNtb3ZlVG9UYWlsKGluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlQWdlT25HZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jdXBkYXRlSXRlbUFnZShpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3N0YXR1c1RUTChzdGF0dXMsIGluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG9rLCBpdCBpcyBzdGFsZSBvciBhIGZvcmNlZCByZWZyZXNoLCBhbmQgbm90IGFscmVhZHkgZmV0Y2hpbmcuXG4gICAgICAgICAgICAvLyByZWZyZXNoIHRoZSBjYWNoZS5cbiAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLiNiYWNrZ3JvdW5kRmV0Y2goaywgaW5kZXgsIG9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICAgICAgY29uc3QgaGFzU3RhbGUgPSBwLl9fc3RhbGVXaGlsZUZldGNoaW5nICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBzdGFsZVZhbCA9IGhhc1N0YWxlICYmIGFsbG93U3RhbGU7XG4gICAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmZldGNoID0gaXNTdGFsZSA/ICdzdGFsZScgOiAncmVmcmVzaCc7XG4gICAgICAgICAgICAgICAgaWYgKHN0YWxlVmFsICYmIGlzU3RhbGUpXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5yZXR1cm5lZFN0YWxlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdGFsZVZhbCA/IHAuX19zdGFsZVdoaWxlRmV0Y2hpbmcgOiAocC5fX3JldHVybmVkID0gcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZm9yY2VGZXRjaChrLCBmZXRjaE9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB2ID0gYXdhaXQgdGhpcy5mZXRjaChrLCBmZXRjaE9wdGlvbnMpO1xuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmZXRjaCgpIHJldHVybmVkIHVuZGVmaW5lZCcpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgbWVtbyhrLCBtZW1vT3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG1lbW9NZXRob2QgPSB0aGlzLiNtZW1vTWV0aG9kO1xuICAgICAgICBpZiAoIW1lbW9NZXRob2QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gbWVtb01ldGhvZCBwcm92aWRlZCB0byBjb25zdHJ1Y3RvcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY29udGV4dCwgZm9yY2VSZWZyZXNoLCAuLi5vcHRpb25zIH0gPSBtZW1vT3B0aW9ucztcbiAgICAgICAgY29uc3QgdiA9IHRoaXMuZ2V0KGssIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIWZvcmNlUmVmcmVzaCAmJiB2ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY29uc3QgdnYgPSBtZW1vTWV0aG9kKGssIHYsIHtcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXQoaywgdnYsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdnY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHZhbHVlIGZyb20gdGhlIGNhY2hlLiBXaWxsIHVwZGF0ZSB0aGUgcmVjZW5jeSBvZiB0aGUgY2FjaGVcbiAgICAgKiBlbnRyeSBmb3VuZC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBrZXkgaXMgbm90IGZvdW5kLCBnZXQoKSB3aWxsIHJldHVybiBgdW5kZWZpbmVkYC5cbiAgICAgKi9cbiAgICBnZXQoaywgZ2V0T3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgYWxsb3dTdGFsZSA9IHRoaXMuYWxsb3dTdGFsZSwgdXBkYXRlQWdlT25HZXQgPSB0aGlzLnVwZGF0ZUFnZU9uR2V0LCBub0RlbGV0ZU9uU3RhbGVHZXQgPSB0aGlzLm5vRGVsZXRlT25TdGFsZUdldCwgc3RhdHVzLCB9ID0gZ2V0T3B0aW9ucztcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLiNrZXlNYXAuZ2V0KGspO1xuICAgICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiN2YWxMaXN0W2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IGZldGNoaW5nID0gdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godmFsdWUpO1xuICAgICAgICAgICAgaWYgKHN0YXR1cylcbiAgICAgICAgICAgICAgICB0aGlzLiNzdGF0dXNUVEwoc3RhdHVzLCBpbmRleCk7XG4gICAgICAgICAgICBpZiAodGhpcy4jaXNTdGFsZShpbmRleCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzKVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZ2V0ID0gJ3N0YWxlJztcbiAgICAgICAgICAgICAgICAvLyBkZWxldGUgb25seSBpZiBub3QgYW4gaW4tZmxpZ2h0IGJhY2tncm91bmQgZmV0Y2hcbiAgICAgICAgICAgICAgICBpZiAoIWZldGNoaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9EZWxldGVPblN0YWxlR2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNkZWxldGUoaywgJ2V4cGlyZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgJiYgYWxsb3dTdGFsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5yZXR1cm5lZFN0YWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFsbG93U3RhbGUgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93U3RhbGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLl9fc3RhbGVXaGlsZUZldGNoaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5yZXR1cm5lZFN0YWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWxsb3dTdGFsZSA/IHZhbHVlLl9fc3RhbGVXaGlsZUZldGNoaW5nIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMpXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5nZXQgPSAnaGl0JztcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSdyZSBjdXJyZW50bHkgZmV0Y2hpbmcgaXQsIHdlIGRvbid0IGFjdHVhbGx5IGhhdmUgaXQgeWV0XG4gICAgICAgICAgICAgICAgLy8gaXQncyBub3Qgc3RhbGUsIHdoaWNoIG1lYW5zIHRoaXMgaXNuJ3QgYSBzdGFsZVdoaWxlUmVmZXRjaGluZy5cbiAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIG5vdCBzdGFsZSwgYW5kIGZldGNoaW5nLCBBTkQgaGFzIGEgX19zdGFsZVdoaWxlRmV0Y2hpbmdcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZSwgdGhlbiB0aGF0IG1lYW5zIHRoZSB1c2VyIGZldGNoZWQgd2l0aCB7Zm9yY2VSZWZyZXNoOnRydWV9LFxuICAgICAgICAgICAgICAgIC8vIHNvIGl0J3Mgc2FmZSB0byByZXR1cm4gdGhhdCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAoZmV0Y2hpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLl9fc3RhbGVXaGlsZUZldGNoaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiNtb3ZlVG9UYWlsKGluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlQWdlT25HZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jdXBkYXRlSXRlbUFnZShpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgIHN0YXR1cy5nZXQgPSAnbWlzcyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgI2Nvbm5lY3QocCwgbikge1xuICAgICAgICB0aGlzLiNwcmV2W25dID0gcDtcbiAgICAgICAgdGhpcy4jbmV4dFtwXSA9IG47XG4gICAgfVxuICAgICNtb3ZlVG9UYWlsKGluZGV4KSB7XG4gICAgICAgIC8vIGlmIHRhaWwgYWxyZWFkeSwgbm90aGluZyB0byBkb1xuICAgICAgICAvLyBpZiBoZWFkLCBtb3ZlIGhlYWQgdG8gbmV4dFtpbmRleF1cbiAgICAgICAgLy8gZWxzZVxuICAgICAgICAvLyAgIG1vdmUgbmV4dFtwcmV2W2luZGV4XV0gdG8gbmV4dFtpbmRleF0gKGhlYWQgaGFzIG5vIHByZXYpXG4gICAgICAgIC8vICAgbW92ZSBwcmV2W25leHRbaW5kZXhdXSB0byBwcmV2W2luZGV4XVxuICAgICAgICAvLyBwcmV2W2luZGV4XSA9IHRhaWxcbiAgICAgICAgLy8gbmV4dFt0YWlsXSA9IGluZGV4XG4gICAgICAgIC8vIHRhaWwgPSBpbmRleFxuICAgICAgICBpZiAoaW5kZXggIT09IHRoaXMuI3RhaWwpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdGhpcy4jaGVhZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2hlYWQgPSB0aGlzLiNuZXh0W2luZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuI2Nvbm5lY3QodGhpcy4jcHJldltpbmRleF0sIHRoaXMuI25leHRbaW5kZXhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI2Nvbm5lY3QodGhpcy4jdGFpbCwgaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy4jdGFpbCA9IGluZGV4O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYSBrZXkgb3V0IG9mIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUga2V5IHdhcyBkZWxldGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZGVsZXRlKGspIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2RlbGV0ZShrLCAnZGVsZXRlJyk7XG4gICAgfVxuICAgICNkZWxldGUoaywgcmVhc29uKSB7XG4gICAgICAgIGxldCBkZWxldGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLiNzaXplICE9PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuI2tleU1hcC5nZXQoayk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNzaXplID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2NsZWFyKHJlYXNvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNyZW1vdmVJdGVtU2l6ZShpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2Ll9fYWJvcnRDb250cm9sbGVyLmFib3J0KG5ldyBFcnJvcignZGVsZXRlZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLiNoYXNEaXNwb3NlIHx8IHRoaXMuI2hhc0Rpc3Bvc2VBZnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlPy4odiwgaywgcmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlZD8ucHVzaChbdiwgaywgcmVhc29uXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy4ja2V5TWFwLmRlbGV0ZShrKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4ja2V5TGlzdFtpbmRleF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3ZhbExpc3RbaW5kZXhdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IHRoaXMuI3RhaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI3RhaWwgPSB0aGlzLiNwcmV2W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpbmRleCA9PT0gdGhpcy4jaGVhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jaGVhZCA9IHRoaXMuI25leHRbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGkgPSB0aGlzLiNwcmV2W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI25leHRbcGldID0gdGhpcy4jbmV4dFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuaSA9IHRoaXMuI25leHRbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jcHJldltuaV0gPSB0aGlzLiNwcmV2W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiNzaXplLS07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2ZyZWUucHVzaChpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlQWZ0ZXIgJiYgdGhpcy4jZGlzcG9zZWQ/Lmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgZHQgPSB0aGlzLiNkaXNwb3NlZDtcbiAgICAgICAgICAgIGxldCB0YXNrO1xuICAgICAgICAgICAgd2hpbGUgKCh0YXNrID0gZHQ/LnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZUFmdGVyPy4oLi4udGFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlbGV0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBjYWNoZSBlbnRpcmVseSwgdGhyb3dpbmcgYXdheSBhbGwgdmFsdWVzLlxuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY2xlYXIoJ2RlbGV0ZScpO1xuICAgIH1cbiAgICAjY2xlYXIocmVhc29uKSB7XG4gICAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgdGhpcy4jcmluZGV4ZXMoeyBhbGxvd1N0YWxlOiB0cnVlIH0pKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpbmRleF07XG4gICAgICAgICAgICBpZiAodGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godikpIHtcbiAgICAgICAgICAgICAgICB2Ll9fYWJvcnRDb250cm9sbGVyLmFib3J0KG5ldyBFcnJvcignZGVsZXRlZCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGsgPSB0aGlzLiNrZXlMaXN0W2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlPy4odiwgaywgcmVhc29uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2VBZnRlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlZD8ucHVzaChbdiwgaywgcmVhc29uXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2tleU1hcC5jbGVhcigpO1xuICAgICAgICB0aGlzLiN2YWxMaXN0LmZpbGwodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy4ja2V5TGlzdC5maWxsKHVuZGVmaW5lZCk7XG4gICAgICAgIGlmICh0aGlzLiN0dGxzICYmIHRoaXMuI3N0YXJ0cykge1xuICAgICAgICAgICAgdGhpcy4jdHRscy5maWxsKDApO1xuICAgICAgICAgICAgdGhpcy4jc3RhcnRzLmZpbGwoMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI3NpemVzKSB7XG4gICAgICAgICAgICB0aGlzLiNzaXplcy5maWxsKDApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2hlYWQgPSAwO1xuICAgICAgICB0aGlzLiN0YWlsID0gMDtcbiAgICAgICAgdGhpcy4jZnJlZS5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLiNjYWxjdWxhdGVkU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuI3NpemUgPSAwO1xuICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZUFmdGVyICYmIHRoaXMuI2Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICBjb25zdCBkdCA9IHRoaXMuI2Rpc3Bvc2VkO1xuICAgICAgICAgICAgbGV0IHRhc2s7XG4gICAgICAgICAgICB3aGlsZSAoKHRhc2sgPSBkdD8uc2hpZnQoKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlQWZ0ZXI/LiguLi50YXNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJwZXJmIiwicGVyZm9ybWFuY2UiLCJub3ciLCJEYXRlIiwid2FybmVkIiwiU2V0IiwiUFJPQ0VTUyIsInByb2Nlc3MiLCJlbWl0V2FybmluZyIsIm1zZyIsInR5cGUiLCJjb2RlIiwiZm4iLCJjb25zb2xlIiwiZXJyb3IiLCJBQyIsImdsb2JhbFRoaXMiLCJBYm9ydENvbnRyb2xsZXIiLCJBUyIsIkFib3J0U2lnbmFsIiwiYWRkRXZlbnRMaXN0ZW5lciIsIl8iLCJfb25hYm9ydCIsInB1c2giLCJhYm9ydGVkIiwiY29uc3RydWN0b3IiLCJzaWduYWwiLCJ3YXJuQUNQb2x5ZmlsbCIsImFib3J0IiwicmVhc29uIiwib25hYm9ydCIsInByaW50QUNQb2x5ZmlsbFdhcm5pbmciLCJlbnYiLCJMUlVfQ0FDSEVfSUdOT1JFX0FDX1dBUk5JTkciLCJzaG91bGRXYXJuIiwiaGFzIiwiVFlQRSIsIlN5bWJvbCIsImlzUG9zSW50IiwibiIsIk1hdGgiLCJmbG9vciIsImlzRmluaXRlIiwiZ2V0VWludEFycmF5IiwibWF4IiwicG93IiwiVWludDhBcnJheSIsIlVpbnQxNkFycmF5IiwiVWludDMyQXJyYXkiLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwiWmVyb0FycmF5IiwiQXJyYXkiLCJzaXplIiwiZmlsbCIsIlN0YWNrIiwiY29uc3RydWN0aW5nIiwiY3JlYXRlIiwiSGVhcENscyIsInMiLCJUeXBlRXJyb3IiLCJoZWFwIiwibGVuZ3RoIiwicG9wIiwiTFJVQ2FjaGUiLCJ0b1N0cmluZ1RhZyIsIm1heFNpemUiLCJkaXNwb3NlIiwiZGlzcG9zZUFmdGVyIiwiZmV0Y2hNZXRob2QiLCJtZW1vTWV0aG9kIiwiY2FsY3VsYXRlZFNpemUiLCJrZXlNYXAiLCJrZXlMaXN0IiwidmFsTGlzdCIsIm5leHQiLCJwcmV2IiwiaGVhZCIsInRhaWwiLCJmcmVlIiwiZGlzcG9zZWQiLCJzaXplcyIsInN0YXJ0cyIsInR0bHMiLCJoYXNEaXNwb3NlIiwiaGFzRmV0Y2hNZXRob2QiLCJoYXNEaXNwb3NlQWZ0ZXIiLCJ1bnNhZmVFeHBvc2VJbnRlcm5hbHMiLCJjIiwiaXNCYWNrZ3JvdW5kRmV0Y2giLCJwIiwiYmFja2dyb3VuZEZldGNoIiwiayIsImluZGV4Iiwib3B0aW9ucyIsImNvbnRleHQiLCJtb3ZlVG9UYWlsIiwiaW5kZXhlcyIsInJpbmRleGVzIiwiaXNTdGFsZSIsInVwZGF0ZUl0ZW1BZ2UiLCJzdGF0dXNUVEwiLCJzZXRJdGVtVFRMIiwicmVtb3ZlSXRlbVNpemUiLCJfaSIsImFkZEl0ZW1TaXplIiwiX3MiLCJfc3QiLCJyZXF1aXJlU2l6ZSIsIl9rIiwiX3YiLCJzaXplQ2FsY3VsYXRpb24iLCJ0dGwiLCJ0dGxSZXNvbHV0aW9uIiwidHRsQXV0b3B1cmdlIiwidXBkYXRlQWdlT25HZXQiLCJ1cGRhdGVBZ2VPbkhhcyIsImFsbG93U3RhbGUiLCJub0Rpc3Bvc2VPblNldCIsIm5vVXBkYXRlVFRMIiwibWF4RW50cnlTaXplIiwibm9EZWxldGVPbkZldGNoUmVqZWN0aW9uIiwibm9EZWxldGVPblN0YWxlR2V0IiwiYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb24iLCJhbGxvd1N0YWxlT25GZXRjaEFib3J0IiwiaWdub3JlRmV0Y2hBYm9ydCIsIlVpbnRBcnJheSIsIkVycm9yIiwidW5kZWZpbmVkIiwiTWFwIiwiaW5pdGlhbGl6ZVNpemVUcmFja2luZyIsImluaXRpYWxpemVUVExUcmFja2luZyIsImFkZCIsImdldFJlbWFpbmluZ1RUTCIsImtleSIsIkluZmluaXR5Iiwic3RhcnQiLCJ0Iiwic2V0VGltZW91dCIsImRlbGV0ZSIsInVucmVmIiwic3RhdHVzIiwiY2FjaGVkTm93IiwiZ2V0Tm93IiwiYWdlIiwicmVtYWluaW5nVFRMIiwiZ2V0IiwidiIsImV2aWN0IiwiZW50cnlTaXplIiwidG90YWxDYWxjdWxhdGVkU2l6ZSIsImkiLCJpc1ZhbGlkSW5kZXgiLCJlbnRyaWVzIiwicmVudHJpZXMiLCJrZXlzIiwicmtleXMiLCJ2YWx1ZXMiLCJydmFsdWVzIiwiaXRlcmF0b3IiLCJmaW5kIiwiZ2V0T3B0aW9ucyIsInZhbHVlIiwiX19zdGFsZVdoaWxlRmV0Y2hpbmciLCJmb3JFYWNoIiwidGhpc3AiLCJjYWxsIiwicmZvckVhY2giLCJwdXJnZVN0YWxlIiwiZGVsZXRlZCIsImluZm8iLCJlbnRyeSIsInJlbWFpbiIsImR1bXAiLCJhcnIiLCJ1bnNoaWZ0IiwibG9hZCIsImNsZWFyIiwic2V0Iiwic2V0T3B0aW9ucyIsIm1heEVudHJ5U2l6ZUV4Y2VlZGVkIiwib2xkVmFsIiwiX19hYm9ydENvbnRyb2xsZXIiLCJvbGRWYWx1ZSIsImR0IiwidGFzayIsInNoaWZ0IiwidmFsIiwiaGFzT3B0aW9ucyIsInBlZWsiLCJwZWVrT3B0aW9ucyIsImFjIiwiZmV0Y2hPcHRzIiwiY2IiLCJ1cGRhdGVDYWNoZSIsImlnbm9yZUFib3J0IiwiZmV0Y2hBYm9ydGVkIiwiZmV0Y2hFcnJvciIsImZldGNoQWJvcnRJZ25vcmVkIiwiZmV0Y2hSZXNvbHZlZCIsImZldGNoRmFpbCIsImJmIiwiZmV0Y2hVcGRhdGVkIiwiZWIiLCJlciIsImZldGNoUmVqZWN0ZWQiLCJhbGxvd1N0YWxlQWJvcnRlZCIsIm5vRGVsZXRlIiwiZGVsIiwicmV0dXJuZWRTdGFsZSIsIl9fcmV0dXJuZWQiLCJwY2FsbCIsInJlcyIsInJlaiIsImZtcCIsIlByb21pc2UiLCJ0aGVuIiwiZmV0Y2hEaXNwYXRjaGVkIiwiT2JqZWN0IiwiYXNzaWduIiwiYiIsImhhc093blByb3BlcnR5IiwiZmV0Y2giLCJmZXRjaE9wdGlvbnMiLCJmb3JjZVJlZnJlc2giLCJzdGFsZSIsImhhc1N0YWxlIiwic3RhbGVWYWwiLCJmb3JjZUZldGNoIiwibWVtbyIsIm1lbW9PcHRpb25zIiwidnYiLCJmZXRjaGluZyIsImNvbm5lY3QiLCJwaSIsIm5pIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/lru-cache/dist/esm/index.js\n");

/***/ })

};
;