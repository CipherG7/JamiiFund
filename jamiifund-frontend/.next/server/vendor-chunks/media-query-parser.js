"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/media-query-parser";
exports.ids = ["vendor-chunks/media-query-parser"];
exports.modules = {

/***/ "(ssr)/./node_modules/media-query-parser/dist/media-query-parser.esm.js":
/*!************************************************************************!*\
  !*** ./node_modules/media-query-parser/dist/media-query-parser.esm.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   consumeEscape: () => (/* binding */ consumeEscape),\n/* harmony export */   consumeIdent: () => (/* binding */ consumeIdent),\n/* harmony export */   consumeIdentLike: () => (/* binding */ consumeIdentLike),\n/* harmony export */   consumeIdentUnsafe: () => (/* binding */ consumeIdentUnsafe),\n/* harmony export */   consumeNumber: () => (/* binding */ consumeNumber),\n/* harmony export */   consumeNumeric: () => (/* binding */ consumeNumeric),\n/* harmony export */   consumeString: () => (/* binding */ consumeString),\n/* harmony export */   consumeUrl: () => (/* binding */ consumeUrl),\n/* harmony export */   lexicalAnalysis: () => (/* binding */ lexicalAnalysis),\n/* harmony export */   removeWhitespace: () => (/* binding */ removeWhitespace),\n/* harmony export */   syntacticAnalysis: () => (/* binding */ syntacticAnalysis),\n/* harmony export */   toAST: () => (/* binding */ toAST),\n/* harmony export */   toUnflattenedAST: () => (/* binding */ toUnflattenedAST),\n/* harmony export */   tokenizeMediaCondition: () => (/* binding */ tokenizeMediaCondition),\n/* harmony export */   tokenizeMediaFeature: () => (/* binding */ tokenizeMediaFeature),\n/* harmony export */   tokenizeMediaQuery: () => (/* binding */ tokenizeMediaQuery),\n/* harmony export */   tokenizeRange: () => (/* binding */ tokenizeRange),\n/* harmony export */   wouldStartIdentifier: () => (/* binding */ wouldStartIdentifier)\n/* harmony export */ });\n/*! @license MediaQueryParser - MIT License - Tom Golden (github@tbjgolden.com) */ /*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ var __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nfunction __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __read(o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);\n    } catch (error) {\n        e = {\n            error: error\n        };\n    } finally{\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        } finally{\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n}\nvar weirdNewlines = /(\\u000D|\\u000C|\\u000D\\u000A)/g;\nvar nullOrSurrogates = /[\\u0000\\uD800-\\uDFFF]/g;\nvar commentRegex = /(\\/\\*)[\\s\\S]*?(\\*\\/)/g;\nvar lexicalAnalysis = function lexicalAnalysis(str, index) {\n    if (index === void 0) {\n        index = 0;\n    }\n    str = str.replace(weirdNewlines, \"\\n\").replace(nullOrSurrogates, \"ï¿½\");\n    str = str.replace(commentRegex, \"\");\n    var tokens = [];\n    for(; index < str.length; index += 1){\n        var code = str.charCodeAt(index);\n        if (code === 0x0009 || code === 0x0020 || code === 0x000a) {\n            var code_1 = str.charCodeAt(++index);\n            while(code_1 === 0x0009 || code_1 === 0x0020 || code_1 === 0x000a){\n                code_1 = str.charCodeAt(++index);\n            }\n            index -= 1;\n            tokens.push({\n                type: \"<whitespace-token>\"\n            });\n        } else if (code === 0x0022) {\n            var result = consumeString(str, index);\n            if (result === null) {\n                return null;\n            }\n            var _a = __read(result, 2), lastIndex = _a[0], value = _a[1];\n            tokens.push({\n                type: \"<string-token>\",\n                value: value\n            });\n            index = lastIndex;\n        } else if (code === 0x0023) {\n            if (index + 1 < str.length) {\n                var nextCode = str.charCodeAt(index + 1);\n                if (nextCode === 0x005f || nextCode >= 0x0041 && nextCode <= 0x005a || nextCode >= 0x0061 && nextCode <= 0x007a || nextCode >= 0x0080 || nextCode >= 0x0030 && nextCode <= 0x0039 || nextCode === 0x005c && index + 2 < str.length && str.charCodeAt(index + 2) !== 0x000a) {\n                    var flag = wouldStartIdentifier(str, index + 1) ? \"id\" : \"unrestricted\";\n                    var result = consumeIdentUnsafe(str, index + 1);\n                    if (result !== null) {\n                        var _b = __read(result, 2), lastIndex = _b[0], value = _b[1];\n                        tokens.push({\n                            type: \"<hash-token>\",\n                            value: value.toLowerCase(),\n                            flag: flag\n                        });\n                        index = lastIndex;\n                        continue;\n                    }\n                }\n            }\n            tokens.push({\n                type: \"<delim-token>\",\n                value: code\n            });\n        } else if (code === 0x0027) {\n            var result = consumeString(str, index);\n            if (result === null) {\n                return null;\n            }\n            var _c = __read(result, 2), lastIndex = _c[0], value = _c[1];\n            tokens.push({\n                type: \"<string-token>\",\n                value: value\n            });\n            index = lastIndex;\n        } else if (code === 0x0028) {\n            tokens.push({\n                type: \"<(-token>\"\n            });\n        } else if (code === 0x0029) {\n            tokens.push({\n                type: \"<)-token>\"\n            });\n        } else if (code === 0x002b) {\n            var plusNumeric = consumeNumeric(str, index);\n            if (plusNumeric === null) {\n                tokens.push({\n                    type: \"<delim-token>\",\n                    value: code\n                });\n            } else {\n                var _d = __read(plusNumeric, 2), lastIndex = _d[0], tokenTuple = _d[1];\n                if (tokenTuple[0] === \"<dimension-token>\") {\n                    tokens.push({\n                        type: \"<dimension-token>\",\n                        value: tokenTuple[1],\n                        unit: tokenTuple[2].toLowerCase(),\n                        flag: \"number\"\n                    });\n                } else if (tokenTuple[0] === \"<number-token>\") {\n                    tokens.push({\n                        type: tokenTuple[0],\n                        value: tokenTuple[1],\n                        flag: tokenTuple[2]\n                    });\n                } else {\n                    tokens.push({\n                        type: tokenTuple[0],\n                        value: tokenTuple[1],\n                        flag: \"number\"\n                    });\n                }\n                index = lastIndex;\n            }\n        } else if (code === 0x002c) {\n            tokens.push({\n                type: \"<comma-token>\"\n            });\n        } else if (code === 0x002d) {\n            var minusNumeric = consumeNumeric(str, index);\n            if (minusNumeric !== null) {\n                var _e = __read(minusNumeric, 2), lastIndex = _e[0], tokenTuple = _e[1];\n                if (tokenTuple[0] === \"<dimension-token>\") {\n                    tokens.push({\n                        type: \"<dimension-token>\",\n                        value: tokenTuple[1],\n                        unit: tokenTuple[2].toLowerCase(),\n                        flag: \"number\"\n                    });\n                } else if (tokenTuple[0] === \"<number-token>\") {\n                    tokens.push({\n                        type: tokenTuple[0],\n                        value: tokenTuple[1],\n                        flag: tokenTuple[2]\n                    });\n                } else {\n                    tokens.push({\n                        type: tokenTuple[0],\n                        value: tokenTuple[1],\n                        flag: \"number\"\n                    });\n                }\n                index = lastIndex;\n                continue;\n            }\n            if (index + 2 < str.length) {\n                var nextCode = str.charCodeAt(index + 1);\n                var nextNextCode = str.charCodeAt(index + 2);\n                if (nextCode === 0x002d && nextNextCode === 0x003e) {\n                    tokens.push({\n                        type: \"<CDC-token>\"\n                    });\n                    index += 2;\n                    continue;\n                }\n            }\n            var result = consumeIdentLike(str, index);\n            if (result !== null) {\n                var _f = __read(result, 3), lastIndex = _f[0], value = _f[1], type = _f[2];\n                tokens.push({\n                    type: type,\n                    value: value\n                });\n                index = lastIndex;\n                continue;\n            }\n            tokens.push({\n                type: \"<delim-token>\",\n                value: code\n            });\n        } else if (code === 0x002e) {\n            var minusNumeric = consumeNumeric(str, index);\n            if (minusNumeric === null) {\n                tokens.push({\n                    type: \"<delim-token>\",\n                    value: code\n                });\n            } else {\n                var _g = __read(minusNumeric, 2), lastIndex = _g[0], tokenTuple = _g[1];\n                if (tokenTuple[0] === \"<dimension-token>\") {\n                    tokens.push({\n                        type: \"<dimension-token>\",\n                        value: tokenTuple[1],\n                        unit: tokenTuple[2].toLowerCase(),\n                        flag: \"number\"\n                    });\n                } else if (tokenTuple[0] === \"<number-token>\") {\n                    tokens.push({\n                        type: tokenTuple[0],\n                        value: tokenTuple[1],\n                        flag: tokenTuple[2]\n                    });\n                } else {\n                    tokens.push({\n                        type: tokenTuple[0],\n                        value: tokenTuple[1],\n                        flag: \"number\"\n                    });\n                }\n                index = lastIndex;\n                continue;\n            }\n        } else if (code === 0x003a) {\n            tokens.push({\n                type: \"<colon-token>\"\n            });\n        } else if (code === 0x003b) {\n            tokens.push({\n                type: \"<semicolon-token>\"\n            });\n        } else if (code === 0x003c) {\n            if (index + 3 < str.length) {\n                var nextCode = str.charCodeAt(index + 1);\n                var nextNextCode = str.charCodeAt(index + 2);\n                var nextNextNextCode = str.charCodeAt(index + 3);\n                if (nextCode === 0x0021 && nextNextCode === 0x002d && nextNextNextCode === 0x002d) {\n                    tokens.push({\n                        type: \"<CDO-token>\"\n                    });\n                    index += 3;\n                    continue;\n                }\n            }\n            tokens.push({\n                type: \"<delim-token>\",\n                value: code\n            });\n        } else if (code === 0x0040) {\n            var result = consumeIdent(str, index + 1);\n            if (result !== null) {\n                var _h = __read(result, 2), lastIndex = _h[0], value = _h[1];\n                tokens.push({\n                    type: \"<at-keyword-token>\",\n                    value: value.toLowerCase()\n                });\n                index = lastIndex;\n                continue;\n            }\n            tokens.push({\n                type: \"<delim-token>\",\n                value: code\n            });\n        } else if (code === 0x005b) {\n            tokens.push({\n                type: \"<[-token>\"\n            });\n        } else if (code === 0x005c) {\n            var result = consumeEscape(str, index);\n            if (result === null) {\n                return null;\n            }\n            var _j = __read(result, 2), lastIndex = _j[0], value = _j[1];\n            str = str.slice(0, index) + value + str.slice(lastIndex + 1);\n            index -= 1;\n        } else if (code === 0x005d) {\n            tokens.push({\n                type: \"<]-token>\"\n            });\n        } else if (code === 0x007b) {\n            tokens.push({\n                type: \"<{-token>\"\n            });\n        } else if (code === 0x007d) {\n            tokens.push({\n                type: \"<}-token>\"\n            });\n        } else if (code >= 0x0030 && code <= 0x0039) {\n            var result = consumeNumeric(str, index);\n            var _k = __read(result, 2), lastIndex = _k[0], tokenTuple = _k[1];\n            if (tokenTuple[0] === \"<dimension-token>\") {\n                tokens.push({\n                    type: \"<dimension-token>\",\n                    value: tokenTuple[1],\n                    unit: tokenTuple[2].toLowerCase(),\n                    flag: \"number\"\n                });\n            } else if (tokenTuple[0] === \"<number-token>\") {\n                tokens.push({\n                    type: tokenTuple[0],\n                    value: tokenTuple[1],\n                    flag: tokenTuple[2]\n                });\n            } else {\n                tokens.push({\n                    type: tokenTuple[0],\n                    value: tokenTuple[1],\n                    flag: \"number\"\n                });\n            }\n            index = lastIndex;\n        } else if (code === 0x005f || code >= 0x0041 && code <= 0x005a || code >= 0x0061 && code <= 0x007a || code >= 0x0080) {\n            var result = consumeIdentLike(str, index);\n            if (result === null) {\n                return null;\n            }\n            var _l = __read(result, 3), lastIndex = _l[0], value = _l[1], type = _l[2];\n            tokens.push({\n                type: type,\n                value: value\n            });\n            index = lastIndex;\n        } else {\n            tokens.push({\n                type: \"<delim-token>\",\n                value: code\n            });\n        }\n    }\n    tokens.push({\n        type: \"<EOF-token>\"\n    });\n    return tokens;\n};\nvar consumeString = function consumeString(str, index) {\n    if (str.length <= index + 1) return null;\n    var firstCode = str.charCodeAt(index);\n    var charCodes = [];\n    for(var i = index + 1; i < str.length; i += 1){\n        var code = str.charCodeAt(i);\n        if (code === firstCode) {\n            return [\n                i,\n                String.fromCharCode.apply(null, charCodes)\n            ];\n        } else if (code === 0x005c) {\n            var result = consumeEscape(str, i);\n            if (result === null) return null;\n            var _a = __read(result, 2), lastIndex = _a[0], charCode = _a[1];\n            charCodes.push(charCode);\n            i = lastIndex;\n        } else if (code === 0x000a) {\n            return null;\n        } else {\n            charCodes.push(code);\n        }\n    }\n    return null;\n};\nvar wouldStartIdentifier = function wouldStartIdentifier(str, index) {\n    if (str.length <= index) return false;\n    var code = str.charCodeAt(index);\n    if (code === 0x002d) {\n        if (str.length <= index + 1) return false;\n        var nextCode = str.charCodeAt(index + 1);\n        if (nextCode === 0x002d || nextCode === 0x005f || nextCode >= 0x0041 && nextCode <= 0x005a || nextCode >= 0x0061 && nextCode <= 0x007a || nextCode >= 0x0080) {\n            return true;\n        } else if (nextCode === 0x005c) {\n            if (str.length <= index + 2) return false;\n            var nextNextCode = str.charCodeAt(index + 2);\n            return nextNextCode !== 0x000a;\n        } else {\n            return false;\n        }\n    } else if (code === 0x005f || code >= 0x0041 && code <= 0x005a || code >= 0x0061 && code <= 0x007a || code >= 0x0080) {\n        return true;\n    } else if (code === 0x005c) {\n        if (str.length <= index + 1) return false;\n        var nextCode = str.charCodeAt(index + 1);\n        return nextCode !== 0x000a;\n    } else {\n        return false;\n    }\n};\nvar consumeEscape = function consumeEscape(str, index) {\n    if (str.length <= index + 1) return null;\n    if (str.charCodeAt(index) !== 0x005c) return null;\n    var code = str.charCodeAt(index + 1);\n    if (code === 0x000a) {\n        return null;\n    } else if (code >= 0x0030 && code <= 0x0039 || code >= 0x0041 && code <= 0x0046 || code >= 0x0061 && code <= 0x0066) {\n        var hexCharCodes = [\n            code\n        ];\n        var min = Math.min(index + 7, str.length);\n        var i = index + 2;\n        for(; i < min; i += 1){\n            var code_2 = str.charCodeAt(i);\n            if (code_2 >= 0x0030 && code_2 <= 0x0039 || code_2 >= 0x0041 && code_2 <= 0x0046 || code_2 >= 0x0061 && code_2 <= 0x0066) {\n                hexCharCodes.push(code_2);\n            } else {\n                break;\n            }\n        }\n        if (i < str.length) {\n            var code_3 = str.charCodeAt(i);\n            if (code_3 === 0x0009 || code_3 === 0x0020 || code_3 === 0x000a) {\n                i += 1;\n            }\n        }\n        return [\n            i - 1,\n            parseInt(String.fromCharCode.apply(null, hexCharCodes), 16)\n        ];\n    } else {\n        return [\n            index + 1,\n            code\n        ];\n    }\n};\nvar consumeNumeric = function consumeNumeric(str, index) {\n    var numberResult = consumeNumber(str, index);\n    if (numberResult === null) return null;\n    var _a = __read(numberResult, 3), numberEndIndex = _a[0], numberValue = _a[1], numberFlag = _a[2];\n    var identResult = consumeIdent(str, numberEndIndex + 1);\n    if (identResult !== null) {\n        var _b = __read(identResult, 2), identEndIndex = _b[0], identValue = _b[1];\n        return [\n            identEndIndex,\n            [\n                \"<dimension-token>\",\n                numberValue,\n                identValue\n            ]\n        ];\n    }\n    if (numberEndIndex + 1 < str.length && str.charCodeAt(numberEndIndex + 1) === 0x0025) {\n        return [\n            numberEndIndex + 1,\n            [\n                \"<percentage-token>\",\n                numberValue\n            ]\n        ];\n    }\n    return [\n        numberEndIndex,\n        [\n            \"<number-token>\",\n            numberValue,\n            numberFlag\n        ]\n    ];\n};\nvar consumeNumber = function consumeNumber(str, index) {\n    if (str.length <= index) return null;\n    var flag = \"integer\";\n    var numberChars = [];\n    var firstCode = str.charCodeAt(index);\n    if (firstCode === 0x002b || firstCode === 0x002d) {\n        index += 1;\n        if (firstCode === 0x002d) numberChars.push(0x002d);\n    }\n    while(index < str.length){\n        var code = str.charCodeAt(index);\n        if (code >= 0x0030 && code <= 0x0039) {\n            numberChars.push(code);\n            index += 1;\n        } else {\n            break;\n        }\n    }\n    if (index + 1 < str.length) {\n        var nextCode = str.charCodeAt(index);\n        var nextNextCode = str.charCodeAt(index + 1);\n        if (nextCode === 0x002e && nextNextCode >= 0x0030 && nextNextCode <= 0x0039) {\n            numberChars.push(nextCode, nextNextCode);\n            flag = \"number\";\n            index += 2;\n            while(index < str.length){\n                var code = str.charCodeAt(index);\n                if (code >= 0x0030 && code <= 0x0039) {\n                    numberChars.push(code);\n                    index += 1;\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n    if (index + 1 < str.length) {\n        var nextCode = str.charCodeAt(index);\n        var nextNextCode = str.charCodeAt(index + 1);\n        var nextNextNextCode = str.charCodeAt(index + 2);\n        if (nextCode === 0x0045 || nextCode === 0x0065) {\n            var nextNextIsDigit = nextNextCode >= 0x0030 && nextNextCode <= 0x0039;\n            if (nextNextIsDigit || (nextNextCode === 0x002b || nextNextCode === 0x002d) && nextNextNextCode >= 0x0030 && nextNextNextCode <= 0x0039) {\n                flag = \"number\";\n                if (nextNextIsDigit) {\n                    numberChars.push(0x0045, nextNextCode);\n                    index += 2;\n                } else if (nextNextCode === 0x002d) {\n                    numberChars.push(0x0045, 0x002d, nextNextNextCode);\n                    index += 3;\n                } else {\n                    numberChars.push(0x0045, nextNextNextCode);\n                    index += 3;\n                }\n                while(index < str.length){\n                    var code = str.charCodeAt(index);\n                    if (code >= 0x0030 && code <= 0x0039) {\n                        numberChars.push(code);\n                        index += 1;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    var numberString = String.fromCharCode.apply(null, numberChars);\n    var value = flag === \"number\" ? parseFloat(numberString) : parseInt(numberString);\n    if (value === -0) value = 0;\n    return Number.isNaN(value) ? null : [\n        index - 1,\n        value,\n        flag\n    ];\n};\nvar consumeIdentUnsafe = function consumeIdentUnsafe(str, index) {\n    if (str.length <= index) {\n        return null;\n    }\n    var identChars = [];\n    for(var code = str.charCodeAt(index); index < str.length; code = str.charCodeAt(++index)){\n        if (code === 0x002d || code === 0x005f || code >= 0x0041 && code <= 0x005a || code >= 0x0061 && code <= 0x007a || code >= 0x0080 || code >= 0x0030 && code <= 0x0039) {\n            identChars.push(code);\n            continue;\n        } else {\n            var result = consumeEscape(str, index);\n            if (result !== null) {\n                var _a = __read(result, 2), lastIndex = _a[0], code_4 = _a[1];\n                identChars.push(code_4);\n                index = lastIndex;\n                continue;\n            }\n        }\n        break;\n    }\n    return index === 0 ? null : [\n        index - 1,\n        String.fromCharCode.apply(null, identChars)\n    ];\n};\nvar consumeIdent = function consumeIdent(str, index) {\n    if (str.length <= index || !wouldStartIdentifier(str, index)) {\n        return null;\n    }\n    var identChars = [];\n    for(var code = str.charCodeAt(index); index < str.length; code = str.charCodeAt(++index)){\n        if (code === 0x002d || code === 0x005f || code >= 0x0041 && code <= 0x005a || code >= 0x0061 && code <= 0x007a || code >= 0x0080 || code >= 0x0030 && code <= 0x0039) {\n            identChars.push(code);\n            continue;\n        } else {\n            var result = consumeEscape(str, index);\n            if (result !== null) {\n                var _a = __read(result, 2), lastIndex = _a[0], code_5 = _a[1];\n                identChars.push(code_5);\n                index = lastIndex;\n                continue;\n            }\n        }\n        break;\n    }\n    return [\n        index - 1,\n        String.fromCharCode.apply(null, identChars)\n    ];\n};\nvar consumeUrl = function consumeUrl(str, index) {\n    var code = str.charCodeAt(index);\n    while(code === 0x0009 || code === 0x0020 || code === 0x000a){\n        code = str.charCodeAt(++index);\n    }\n    var urlChars = [];\n    var hasFinishedWord = false;\n    while(index < str.length){\n        if (code === 0x0029) {\n            return [\n                index,\n                String.fromCharCode.apply(null, urlChars)\n            ];\n        } else if (code === 0x0022 || code === 0x0027 || code === 0x0028) {\n            return null;\n        } else if (code === 0x0009 || code === 0x0020 || code === 0x000a) {\n            if (!hasFinishedWord && urlChars.length !== 0) hasFinishedWord = true;\n        } else if (code === 0x005c) {\n            var result = consumeEscape(str, index);\n            if (result === null || hasFinishedWord) return null;\n            var _a = __read(result, 2), lastIndex = _a[0], value = _a[1];\n            urlChars.push(value);\n            index = lastIndex;\n        } else {\n            if (hasFinishedWord) return null;\n            urlChars.push(code);\n        }\n        code = str.charCodeAt(++index);\n    }\n    return null;\n};\nvar consumeIdentLike = function consumeIdentLike(str, index) {\n    var result = consumeIdent(str, index);\n    if (result === null) return null;\n    var _a = __read(result, 2), lastIndex = _a[0], value = _a[1];\n    if (value.toLowerCase() === \"url\") {\n        if (str.length > lastIndex + 1) {\n            var nextCode = str.charCodeAt(lastIndex + 1);\n            if (nextCode === 0x0028) {\n                for(var offset = 2; lastIndex + offset < str.length; offset += 1){\n                    var nextNextCode = str.charCodeAt(lastIndex + offset);\n                    if (nextNextCode === 0x0022 || nextNextCode === 0x0027) {\n                        return [\n                            lastIndex + 1,\n                            value.toLowerCase(),\n                            \"<function-token>\"\n                        ];\n                    } else if (nextNextCode !== 0x0009 && nextNextCode !== 0x0020 && nextNextCode !== 0x000a) {\n                        var result_1 = consumeUrl(str, lastIndex + offset);\n                        if (result_1 === null) return null;\n                        var _b = __read(result_1, 2), lastUrlIndex = _b[0], value_1 = _b[1];\n                        return [\n                            lastUrlIndex,\n                            value_1,\n                            \"<url-token>\"\n                        ];\n                    }\n                }\n                return [\n                    lastIndex + 1,\n                    value.toLowerCase(),\n                    \"<function-token>\"\n                ];\n            }\n        }\n    } else if (str.length > lastIndex + 1) {\n        var nextCode = str.charCodeAt(lastIndex + 1);\n        if (nextCode === 0x0028) {\n            return [\n                lastIndex + 1,\n                value.toLowerCase(),\n                \"<function-token>\"\n            ];\n        }\n    }\n    return [\n        lastIndex,\n        value.toLowerCase(),\n        \"<ident-token>\"\n    ];\n};\nvar simplifyAST = function simplifyAST(ast) {\n    for(var i = ast.length - 1; i >= 0; i--){\n        ast[i] = simplifyMediaQuery(ast[i]);\n    }\n    return ast;\n};\nvar simplifyMediaQuery = function simplifyMediaQuery(mediaQuery) {\n    if (mediaQuery.mediaCondition === null) return mediaQuery;\n    var mediaCondition = simplifyMediaCondition(mediaQuery.mediaCondition);\n    if (mediaCondition.operator === null && mediaCondition.children.length === 1 && \"children\" in mediaCondition.children[0]) {\n        mediaCondition = mediaCondition.children[0];\n    }\n    return {\n        mediaPrefix: mediaQuery.mediaPrefix,\n        mediaType: mediaQuery.mediaType,\n        mediaCondition: mediaCondition\n    };\n};\nvar simplifyMediaCondition = function simplifyMediaCondition(mediaCondition) {\n    for(var i = mediaCondition.children.length - 1; i >= 0; i--){\n        var unsimplifiedChild = mediaCondition.children[i];\n        if (!(\"context\" in unsimplifiedChild)) {\n            var child = simplifyMediaCondition(unsimplifiedChild);\n            if (child.operator === null && child.children.length === 1) {\n                mediaCondition.children[i] = child.children[0];\n            } else if (child.operator === mediaCondition.operator && (child.operator === \"and\" || child.operator === \"or\")) {\n                var spliceArgs = [\n                    i,\n                    1\n                ];\n                for(var i_1 = 0; i_1 < child.children.length; i_1++){\n                    spliceArgs.push(child.children[i_1]);\n                }\n                mediaCondition.children.splice.apply(mediaCondition.children, spliceArgs);\n            }\n        }\n    }\n    return mediaCondition;\n};\nvar createError = function createError(message, err) {\n    if (err instanceof Error) {\n        return new Error(\"\".concat(err.message.trim(), \"\\n\").concat(message.trim()));\n    } else {\n        return new Error(message.trim());\n    }\n};\nvar toAST = function toAST(str) {\n    return simplifyAST(toUnflattenedAST(str));\n};\nvar toUnflattenedAST = function toUnflattenedAST(str) {\n    var tokenList = lexicalAnalysis(str.trim());\n    if (tokenList === null) {\n        throw createError(\"Failed tokenizing\");\n    }\n    var startIndex = 0;\n    var endIndex = tokenList.length - 1;\n    if (tokenList[0].type === \"<at-keyword-token>\" && tokenList[0].value === \"media\") {\n        if (tokenList[1].type !== \"<whitespace-token>\") {\n            throw createError(\"Expected whitespace after media\");\n        }\n        startIndex = 2;\n        for(var i = 2; i < tokenList.length - 1; i++){\n            var token = tokenList[i];\n            if (token.type === \"<{-token>\") {\n                endIndex = i;\n                break;\n            } else if (token.type === \"<semicolon-token>\") {\n                throw createError(\"Expected '{' in media query but found ';'\");\n            }\n        }\n    }\n    tokenList = tokenList.slice(startIndex, endIndex);\n    return syntacticAnalysis(tokenList);\n};\nvar removeWhitespace = function removeWhitespace(tokenList) {\n    var newTokenList = [];\n    var before = false;\n    for(var i = 0; i < tokenList.length; i++){\n        if (tokenList[i].type === \"<whitespace-token>\") {\n            before = true;\n            if (newTokenList.length > 0) {\n                newTokenList[newTokenList.length - 1].wsAfter = true;\n            }\n        } else {\n            newTokenList.push(__assign(__assign({}, tokenList[i]), {\n                wsBefore: before,\n                wsAfter: false\n            }));\n            before = false;\n        }\n    }\n    return newTokenList;\n};\nvar syntacticAnalysis = function syntacticAnalysis(tokenList) {\n    var e_1, _a;\n    var mediaQueryList = [\n        []\n    ];\n    for(var i = 0; i < tokenList.length; i++){\n        var token = tokenList[i];\n        if (token.type === \"<comma-token>\") {\n            mediaQueryList.push([]);\n        } else {\n            mediaQueryList[mediaQueryList.length - 1].push(token);\n        }\n    }\n    var mediaQueries = mediaQueryList.map(removeWhitespace);\n    if (mediaQueries.length === 1 && mediaQueries[0].length === 0) {\n        return [\n            {\n                mediaCondition: null,\n                mediaPrefix: null,\n                mediaType: \"all\"\n            }\n        ];\n    } else {\n        var mediaQueryTokens = mediaQueries.map(function(mediaQueryTokens) {\n            if (mediaQueryTokens.length === 0) {\n                return null;\n            } else {\n                return tokenizeMediaQuery(mediaQueryTokens);\n            }\n        });\n        var nonNullMediaQueryTokens = [];\n        try {\n            for(var mediaQueryTokens_1 = __values(mediaQueryTokens), mediaQueryTokens_1_1 = mediaQueryTokens_1.next(); !mediaQueryTokens_1_1.done; mediaQueryTokens_1_1 = mediaQueryTokens_1.next()){\n                var mediaQueryToken = mediaQueryTokens_1_1.value;\n                if (mediaQueryToken !== null) {\n                    nonNullMediaQueryTokens.push(mediaQueryToken);\n                }\n            }\n        } catch (e_1_1) {\n            e_1 = {\n                error: e_1_1\n            };\n        } finally{\n            try {\n                if (mediaQueryTokens_1_1 && !mediaQueryTokens_1_1.done && (_a = mediaQueryTokens_1[\"return\"])) _a.call(mediaQueryTokens_1);\n            } finally{\n                if (e_1) throw e_1.error;\n            }\n        }\n        if (nonNullMediaQueryTokens.length === 0) {\n            throw createError(\"No valid media queries\");\n        }\n        return nonNullMediaQueryTokens;\n    }\n};\nvar tokenizeMediaQuery = function tokenizeMediaQuery(tokens) {\n    var firstToken = tokens[0];\n    if (firstToken.type === \"<(-token>\") {\n        try {\n            return {\n                mediaPrefix: null,\n                mediaType: \"all\",\n                mediaCondition: tokenizeMediaCondition(tokens, true)\n            };\n        } catch (err) {\n            throw createError(\"Expected media condition after '('\", err);\n        }\n    } else if (firstToken.type === \"<ident-token>\") {\n        var mediaPrefix = null;\n        var mediaType = void 0;\n        var value = firstToken.value;\n        if (value === \"only\" || value === \"not\") {\n            mediaPrefix = value;\n        }\n        var firstIndex = mediaPrefix === null ? 0 : 1;\n        if (tokens.length <= firstIndex) {\n            throw createError(\"Expected extra token in media query\");\n        }\n        var firstNonUnaryToken = tokens[firstIndex];\n        if (firstNonUnaryToken.type === \"<ident-token>\") {\n            var value_1 = firstNonUnaryToken.value;\n            if (value_1 === \"all\") {\n                mediaType = \"all\";\n            } else if (value_1 === \"print\" || value_1 === \"screen\") {\n                mediaType = value_1;\n            } else if (value_1 === \"tty\" || value_1 === \"tv\" || value_1 === \"projection\" || value_1 === \"handheld\" || value_1 === \"braille\" || value_1 === \"embossed\" || value_1 === \"aural\" || value_1 === \"speech\") {\n                mediaPrefix = mediaPrefix === \"not\" ? null : \"not\";\n                mediaType = \"all\";\n            } else {\n                throw createError(\"Unknown ident '\".concat(value_1, \"' in media query\"));\n            }\n        } else if (mediaPrefix === \"not\" && firstNonUnaryToken.type === \"<(-token>\") {\n            var tokensWithParens = [\n                {\n                    type: \"<(-token>\",\n                    wsBefore: false,\n                    wsAfter: false\n                }\n            ];\n            tokensWithParens.push.apply(tokensWithParens, tokens);\n            tokensWithParens.push({\n                type: \"<)-token>\",\n                wsBefore: false,\n                wsAfter: false\n            });\n            try {\n                return {\n                    mediaPrefix: null,\n                    mediaType: \"all\",\n                    mediaCondition: tokenizeMediaCondition(tokensWithParens, true)\n                };\n            } catch (err) {\n                throw createError(\"Expected media condition after '('\", err);\n            }\n        } else {\n            throw createError(\"Invalid media query\");\n        }\n        if (firstIndex + 1 === tokens.length) {\n            return {\n                mediaPrefix: mediaPrefix,\n                mediaType: mediaType,\n                mediaCondition: null\n            };\n        } else if (firstIndex + 4 < tokens.length) {\n            var secondNonUnaryToken = tokens[firstIndex + 1];\n            if (secondNonUnaryToken.type === \"<ident-token>\" && secondNonUnaryToken.value === \"and\") {\n                try {\n                    return {\n                        mediaPrefix: mediaPrefix,\n                        mediaType: mediaType,\n                        mediaCondition: tokenizeMediaCondition(tokens.slice(firstIndex + 2), false)\n                    };\n                } catch (err) {\n                    throw createError(\"Expected media condition after 'and'\", err);\n                }\n            } else {\n                throw createError(\"Expected 'and' after media prefix\");\n            }\n        } else {\n            throw createError(\"Expected media condition after media prefix\");\n        }\n    } else {\n        throw createError(\"Expected media condition or media prefix\");\n    }\n};\nvar tokenizeMediaCondition = function tokenizeMediaCondition(tokens, mayContainOr, previousOperator) {\n    if (previousOperator === void 0) {\n        previousOperator = null;\n    }\n    if (tokens.length < 3 || tokens[0].type !== \"<(-token>\" || tokens[tokens.length - 1].type !== \"<)-token>\") {\n        throw new Error(\"Invalid media condition\");\n    }\n    var endIndexOfFirstFeature = tokens.length - 1;\n    var maxDepth = 0;\n    var count = 0;\n    for(var i = 0; i < tokens.length; i++){\n        var token = tokens[i];\n        if (token.type === \"<(-token>\") {\n            count += 1;\n            maxDepth = Math.max(maxDepth, count);\n        } else if (token.type === \"<)-token>\") {\n            count -= 1;\n        }\n        if (count === 0) {\n            endIndexOfFirstFeature = i;\n            break;\n        }\n    }\n    if (count !== 0) {\n        throw new Error(\"Mismatched parens\\nInvalid media condition\");\n    }\n    var child;\n    var featureTokens = tokens.slice(0, endIndexOfFirstFeature + 1);\n    if (maxDepth === 1) {\n        child = tokenizeMediaFeature(featureTokens);\n    } else {\n        if (featureTokens[1].type === \"<ident-token>\" && featureTokens[1].value === \"not\") {\n            child = tokenizeMediaCondition(featureTokens.slice(2, -1), true, \"not\");\n        } else {\n            child = tokenizeMediaCondition(featureTokens.slice(1, -1), true);\n        }\n    }\n    if (endIndexOfFirstFeature === tokens.length - 1) {\n        return {\n            operator: previousOperator,\n            children: [\n                child\n            ]\n        };\n    } else {\n        var nextToken = tokens[endIndexOfFirstFeature + 1];\n        if (nextToken.type !== \"<ident-token>\") {\n            throw new Error(\"Invalid operator\\nInvalid media condition\");\n        } else if (previousOperator !== null && previousOperator !== nextToken.value) {\n            throw new Error(\"'\".concat(nextToken.value, \"' and '\").concat(previousOperator, \"' must not be at same level\\nInvalid media condition\"));\n        } else if (nextToken.value === \"or\" && !mayContainOr) {\n            throw new Error(\"Cannot use 'or' at top level of a media query\\nInvalid media condition\");\n        } else if (nextToken.value !== \"and\" && nextToken.value !== \"or\") {\n            throw new Error(\"Invalid operator: '\".concat(nextToken.value, \"'\\nInvalid media condition\"));\n        }\n        var siblings = tokenizeMediaCondition(tokens.slice(endIndexOfFirstFeature + 2), mayContainOr, nextToken.value);\n        return {\n            operator: nextToken.value,\n            children: [\n                child\n            ].concat(siblings.children)\n        };\n    }\n};\nvar tokenizeMediaFeature = function tokenizeMediaFeature(rawTokens) {\n    if (rawTokens.length < 3 || rawTokens[0].type !== \"<(-token>\" || rawTokens[rawTokens.length - 1].type !== \"<)-token>\") {\n        throw new Error(\"Invalid media feature\");\n    }\n    var tokens = [\n        rawTokens[0]\n    ];\n    for(var i = 1; i < rawTokens.length; i++){\n        if (i < rawTokens.length - 2) {\n            var a = rawTokens[i];\n            var b = rawTokens[i + 1];\n            var c = rawTokens[i + 2];\n            if (a.type === \"<number-token>\" && a.value > 0 && b.type === \"<delim-token>\" && b.value === 0x002f && c.type === \"<number-token>\" && c.value > 0) {\n                tokens.push({\n                    type: \"<ratio-token>\",\n                    numerator: a.value,\n                    denominator: c.value,\n                    wsBefore: a.wsBefore,\n                    wsAfter: c.wsAfter\n                });\n                i += 2;\n                continue;\n            }\n        }\n        tokens.push(rawTokens[i]);\n    }\n    var nextToken = tokens[1];\n    if (nextToken.type === \"<ident-token>\" && tokens.length === 3) {\n        return {\n            context: \"boolean\",\n            feature: nextToken.value\n        };\n    } else if (tokens.length === 5 && tokens[1].type === \"<ident-token>\" && tokens[2].type === \"<colon-token>\") {\n        var valueToken = tokens[3];\n        if (valueToken.type === \"<number-token>\" || valueToken.type === \"<dimension-token>\" || valueToken.type === \"<ratio-token>\" || valueToken.type === \"<ident-token>\") {\n            var feature = tokens[1].value;\n            var prefix = null;\n            var slice = feature.slice(0, 4);\n            if (slice === \"min-\") {\n                prefix = \"min\";\n                feature = feature.slice(4);\n            } else if (slice === \"max-\") {\n                prefix = \"max\";\n                feature = feature.slice(4);\n            }\n            valueToken.wsBefore;\n            valueToken.wsAfter;\n            var value = __rest(valueToken, [\n                \"wsBefore\",\n                \"wsAfter\"\n            ]);\n            return {\n                context: \"value\",\n                prefix: prefix,\n                feature: feature,\n                value: value\n            };\n        }\n    } else if (tokens.length >= 5) {\n        try {\n            var range = tokenizeRange(tokens);\n            return {\n                context: \"range\",\n                feature: range.featureName,\n                range: range\n            };\n        } catch (err) {\n            throw createError(\"Invalid media feature\", err);\n        }\n    }\n    throw new Error(\"Invalid media feature\");\n};\nvar tokenizeRange = function tokenizeRange(tokens) {\n    var _a, _b, _c, _d;\n    if (tokens.length < 5 || tokens[0].type !== \"<(-token>\" || tokens[tokens.length - 1].type !== \"<)-token>\") {\n        throw new Error(\"Invalid range\");\n    }\n    var range = {\n        leftToken: null,\n        leftOp: null,\n        featureName: \"\",\n        rightOp: null,\n        rightToken: null\n    };\n    var hasLeft = tokens[1].type === \"<number-token>\" || tokens[1].type === \"<dimension-token>\" || tokens[1].type === \"<ratio-token>\" || tokens[1].type === \"<ident-token>\" && tokens[1].value === \"infinite\";\n    if (tokens[2].type === \"<delim-token>\") {\n        if (tokens[2].value === 0x003c) {\n            if (tokens[3].type === \"<delim-token>\" && tokens[3].value === 0x003d && !tokens[3].wsBefore) {\n                range[hasLeft ? \"leftOp\" : \"rightOp\"] = \"<=\";\n            } else {\n                range[hasLeft ? \"leftOp\" : \"rightOp\"] = \"<\";\n            }\n        } else if (tokens[2].value === 0x003e) {\n            if (tokens[3].type === \"<delim-token>\" && tokens[3].value === 0x003d && !tokens[3].wsBefore) {\n                range[hasLeft ? \"leftOp\" : \"rightOp\"] = \">=\";\n            } else {\n                range[hasLeft ? \"leftOp\" : \"rightOp\"] = \">\";\n            }\n        } else if (tokens[2].value === 0x003d) {\n            range[hasLeft ? \"leftOp\" : \"rightOp\"] = \"=\";\n        } else {\n            throw new Error(\"Invalid range\");\n        }\n        if (hasLeft) {\n            range.leftToken = tokens[1];\n        } else if (tokens[1].type === \"<ident-token>\") {\n            range.featureName = tokens[1].value;\n        } else {\n            throw new Error(\"Invalid range\");\n        }\n        var tokenIndexAfterFirstOp = 2 + ((_b = (_a = range[hasLeft ? \"leftOp\" : \"rightOp\"]) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);\n        var tokenAfterFirstOp = tokens[tokenIndexAfterFirstOp];\n        if (hasLeft) {\n            if (tokenAfterFirstOp.type === \"<ident-token>\") {\n                range.featureName = tokenAfterFirstOp.value;\n                if (tokens.length >= 7) {\n                    var secondOpToken = tokens[tokenIndexAfterFirstOp + 1];\n                    var followingToken = tokens[tokenIndexAfterFirstOp + 2];\n                    if (secondOpToken.type === \"<delim-token>\") {\n                        var charCode = secondOpToken.value;\n                        if (charCode === 0x003c) {\n                            if (followingToken.type === \"<delim-token>\" && followingToken.value === 0x003d && !followingToken.wsBefore) {\n                                range.rightOp = \"<=\";\n                            } else {\n                                range.rightOp = \"<\";\n                            }\n                        } else if (charCode === 0x003e) {\n                            if (followingToken.type === \"<delim-token>\" && followingToken.value === 0x003d && !followingToken.wsBefore) {\n                                range.rightOp = \">=\";\n                            } else {\n                                range.rightOp = \">\";\n                            }\n                        } else {\n                            throw new Error(\"Invalid range\");\n                        }\n                        var tokenAfterSecondOp = tokens[tokenIndexAfterFirstOp + 1 + ((_d = (_c = range.rightOp) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0)];\n                        range.rightToken = tokenAfterSecondOp;\n                    } else {\n                        throw new Error(\"Invalid range\");\n                    }\n                } else if (tokenIndexAfterFirstOp + 2 !== tokens.length) {\n                    throw new Error(\"Invalid range\");\n                }\n            } else {\n                throw new Error(\"Invalid range\");\n            }\n        } else {\n            range.rightToken = tokenAfterFirstOp;\n        }\n        var validRange = null;\n        var lt = range.leftToken, leftOp = range.leftOp, featureName = range.featureName, rightOp = range.rightOp, rt = range.rightToken;\n        var leftToken = null;\n        if (lt !== null) {\n            if (lt.type === \"<ident-token>\") {\n                var type = lt.type, value = lt.value;\n                if (value === \"infinite\") {\n                    leftToken = {\n                        type: type,\n                        value: value\n                    };\n                }\n            } else if (lt.type === \"<number-token>\" || lt.type === \"<dimension-token>\" || lt.type === \"<ratio-token>\") {\n                lt.wsBefore;\n                lt.wsAfter;\n                var ltNoWS = __rest(lt, [\n                    \"wsBefore\",\n                    \"wsAfter\"\n                ]);\n                leftToken = ltNoWS;\n            }\n        }\n        var rightToken = null;\n        if (rt !== null) {\n            if (rt.type === \"<ident-token>\") {\n                var type = rt.type, value = rt.value;\n                if (value === \"infinite\") {\n                    rightToken = {\n                        type: type,\n                        value: value\n                    };\n                }\n            } else if (rt.type === \"<number-token>\" || rt.type === \"<dimension-token>\" || rt.type === \"<ratio-token>\") {\n                rt.wsBefore;\n                rt.wsAfter;\n                var rtNoWS = __rest(rt, [\n                    \"wsBefore\",\n                    \"wsAfter\"\n                ]);\n                rightToken = rtNoWS;\n            }\n        }\n        if (leftToken !== null && rightToken !== null) {\n            if ((leftOp === \"<\" || leftOp === \"<=\") && (rightOp === \"<\" || rightOp === \"<=\")) {\n                validRange = {\n                    leftToken: leftToken,\n                    leftOp: leftOp,\n                    featureName: featureName,\n                    rightOp: rightOp,\n                    rightToken: rightToken\n                };\n            } else if ((leftOp === \">\" || leftOp === \">=\") && (rightOp === \">\" || rightOp === \">=\")) {\n                validRange = {\n                    leftToken: leftToken,\n                    leftOp: leftOp,\n                    featureName: featureName,\n                    rightOp: rightOp,\n                    rightToken: rightToken\n                };\n            } else {\n                throw new Error(\"Invalid range\");\n            }\n        } else if (leftToken === null && leftOp === null && rightOp !== null && rightToken !== null) {\n            validRange = {\n                leftToken: leftToken,\n                leftOp: leftOp,\n                featureName: featureName,\n                rightOp: rightOp,\n                rightToken: rightToken\n            };\n        } else if (leftToken !== null && leftOp !== null && rightOp === null && rightToken === null) {\n            validRange = {\n                leftToken: leftToken,\n                leftOp: leftOp,\n                featureName: featureName,\n                rightOp: rightOp,\n                rightToken: rightToken\n            };\n        }\n        return validRange;\n    } else {\n        throw new Error(\"Invalid range\");\n    }\n};\n //# sourceMappingURL=media-query-parser.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWEtcXVlcnktcGFyc2VyL2Rpc3QvbWVkaWEtcXVlcnktcGFyc2VyLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxnRkFBZ0YsR0FFaEY7Ozs7Ozs7Ozs7Ozs7OEVBYThFLEdBRTlFLElBQUlBLFdBQVc7SUFDWEEsV0FBV0MsT0FBT0MsTUFBTSxJQUFJLFNBQVNGLFNBQVNHLENBQUM7UUFDM0MsSUFBSyxJQUFJQyxHQUFHQyxJQUFJLEdBQUdDLElBQUlDLFVBQVVDLE1BQU0sRUFBRUgsSUFBSUMsR0FBR0QsSUFBSztZQUNqREQsSUFBSUcsU0FBUyxDQUFDRixFQUFFO1lBQ2hCLElBQUssSUFBSUksS0FBS0wsRUFBRyxJQUFJSCxPQUFPUyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUixHQUFHSyxJQUFJTixDQUFDLENBQUNNLEVBQUUsR0FBR0wsQ0FBQyxDQUFDSyxFQUFFO1FBQ2hGO1FBQ0EsT0FBT047SUFDWDtJQUNBLE9BQU9ILFNBQVNhLEtBQUssQ0FBQyxJQUFJLEVBQUVOO0FBQ2hDO0FBRUEsU0FBU08sT0FBT1YsQ0FBQyxFQUFFVyxDQUFDO0lBQ2hCLElBQUlaLElBQUksQ0FBQztJQUNULElBQUssSUFBSU0sS0FBS0wsRUFBRyxJQUFJSCxPQUFPUyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUixHQUFHSyxNQUFNTSxFQUFFQyxPQUFPLENBQUNQLEtBQUssR0FDOUVOLENBQUMsQ0FBQ00sRUFBRSxHQUFHTCxDQUFDLENBQUNLLEVBQUU7SUFDZixJQUFJTCxLQUFLLFFBQVEsT0FBT0gsT0FBT2dCLHFCQUFxQixLQUFLLFlBQ3JELElBQUssSUFBSVosSUFBSSxHQUFHSSxJQUFJUixPQUFPZ0IscUJBQXFCLENBQUNiLElBQUlDLElBQUlJLEVBQUVELE1BQU0sRUFBRUgsSUFBSztRQUNwRSxJQUFJVSxFQUFFQyxPQUFPLENBQUNQLENBQUMsQ0FBQ0osRUFB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Q1RDLFlBQVlBO1lBQ2Q7UUFDRixPQUFPLElBQUlILGNBQWMsUUFBUUMsV0FBVyxRQUFRQyxZQUFZLFFBQVFDLGVBQWUsTUFBTTtZQUMzRk8sYUFBYTtnQkFDWFYsV0FBV0E7Z0JBQ1hDLFFBQVFBO2dCQUNSRixhQUFhQTtnQkFDYkcsU0FBU0E7Z0JBQ1RDLFlBQVlBO1lBQ2Q7UUFDRjtRQUVBLE9BQU9PO0lBQ1QsT0FBTztRQUNMLE1BQU0sSUFBSWpFLE1BQU07SUFDbEI7QUFDRjtBQUU2VCxDQUM3VCxrREFBa0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qYW1paWZ1bmQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbWVkaWEtcXVlcnktcGFyc2VyL2Rpc3QvbWVkaWEtcXVlcnktcGFyc2VyLmVzbS5qcz8wYjBjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBAbGljZW5zZSBNZWRpYVF1ZXJ5UGFyc2VyIC0gTUlUIExpY2Vuc2UgLSBUb20gR29sZGVuIChnaXRodWJAdGJqZ29sZGVuLmNvbSkgKi9cblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XG5cbnZhciB3ZWlyZE5ld2xpbmVzID0gLyhcXHUwMDBEfFxcdTAwMEN8XFx1MDAwRFxcdTAwMEEpL2c7XG52YXIgbnVsbE9yU3Vycm9nYXRlcyA9IC9bXFx1MDAwMFxcdUQ4MDAtXFx1REZGRl0vZztcbnZhciBjb21tZW50UmVnZXggPSAvKFxcL1xcKilbXFxzXFxTXSo/KFxcKlxcLykvZztcbnZhciBsZXhpY2FsQW5hbHlzaXMgPSBmdW5jdGlvbiBsZXhpY2FsQW5hbHlzaXMoc3RyLCBpbmRleCkge1xuICBpZiAoaW5kZXggPT09IHZvaWQgMCkge1xuICAgIGluZGV4ID0gMDtcbiAgfVxuXG4gIHN0ciA9IHN0ci5yZXBsYWNlKHdlaXJkTmV3bGluZXMsICdcXG4nKS5yZXBsYWNlKG51bGxPclN1cnJvZ2F0ZXMsIFwiXFx1RkZGRFwiKTtcbiAgc3RyID0gc3RyLnJlcGxhY2UoY29tbWVudFJlZ2V4LCAnJyk7XG4gIHZhciB0b2tlbnMgPSBbXTtcblxuICBmb3IgKDsgaW5kZXggPCBzdHIubGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgICBpZiAoY29kZSA9PT0gMHgwMDA5IHx8IGNvZGUgPT09IDB4MDAyMCB8fCBjb2RlID09PSAweDAwMGEpIHtcbiAgICAgIHZhciBjb2RlXzEgPSBzdHIuY2hhckNvZGVBdCgrK2luZGV4KTtcblxuICAgICAgd2hpbGUgKGNvZGVfMSA9PT0gMHgwMDA5IHx8IGNvZGVfMSA9PT0gMHgwMDIwIHx8IGNvZGVfMSA9PT0gMHgwMDBhKSB7XG4gICAgICAgIGNvZGVfMSA9IHN0ci5jaGFyQ29kZUF0KCsraW5kZXgpO1xuICAgICAgfVxuXG4gICAgICBpbmRleCAtPSAxO1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPHdoaXRlc3BhY2UtdG9rZW4+J1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwMjIpIHtcbiAgICAgIHZhciByZXN1bHQgPSBjb25zdW1lU3RyaW5nKHN0ciwgaW5kZXgpO1xuXG4gICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2EgPSBfX3JlYWQocmVzdWx0LCAyKSxcbiAgICAgICAgICBsYXN0SW5kZXggPSBfYVswXSxcbiAgICAgICAgICB2YWx1ZSA9IF9hWzFdO1xuXG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICc8c3RyaW5nLXRva2VuPicsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgICBpbmRleCA9IGxhc3RJbmRleDtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAyMykge1xuICAgICAgaWYgKGluZGV4ICsgMSA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5leHRDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcblxuICAgICAgICBpZiAobmV4dENvZGUgPT09IDB4MDA1ZiB8fCBuZXh0Q29kZSA+PSAweDAwNDEgJiYgbmV4dENvZGUgPD0gMHgwMDVhIHx8IG5leHRDb2RlID49IDB4MDA2MSAmJiBuZXh0Q29kZSA8PSAweDAwN2EgfHwgbmV4dENvZGUgPj0gMHgwMDgwIHx8IG5leHRDb2RlID49IDB4MDAzMCAmJiBuZXh0Q29kZSA8PSAweDAwMzkgfHwgbmV4dENvZGUgPT09IDB4MDA1YyAmJiBpbmRleCArIDIgPCBzdHIubGVuZ3RoICYmIHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMikgIT09IDB4MDAwYSkge1xuICAgICAgICAgIHZhciBmbGFnID0gd291bGRTdGFydElkZW50aWZpZXIoc3RyLCBpbmRleCArIDEpID8gJ2lkJyA6ICd1bnJlc3RyaWN0ZWQnO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBjb25zdW1lSWRlbnRVbnNhZmUoc3RyLCBpbmRleCArIDEpO1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIF9iID0gX19yZWFkKHJlc3VsdCwgMiksXG4gICAgICAgICAgICAgICAgbGFzdEluZGV4ID0gX2JbMF0sXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBfYlsxXTtcblxuICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiAnPGhhc2gtdG9rZW4+JyxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgIGZsYWc6IGZsYWdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPGRlbGltLXRva2VuPicsXG4gICAgICAgIHZhbHVlOiBjb2RlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAyNykge1xuICAgICAgdmFyIHJlc3VsdCA9IGNvbnN1bWVTdHJpbmcoc3RyLCBpbmRleCk7XG5cbiAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBfYyA9IF9fcmVhZChyZXN1bHQsIDIpLFxuICAgICAgICAgIGxhc3RJbmRleCA9IF9jWzBdLFxuICAgICAgICAgIHZhbHVlID0gX2NbMV07XG5cbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJzxzdHJpbmctdG9rZW4+JyxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICAgIGluZGV4ID0gbGFzdEluZGV4O1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDI4KSB7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICc8KC10b2tlbj4nXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAyOSkge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPCktdG9rZW4+J1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwMmIpIHtcbiAgICAgIHZhciBwbHVzTnVtZXJpYyA9IGNvbnN1bWVOdW1lcmljKHN0ciwgaW5kZXgpO1xuXG4gICAgICBpZiAocGx1c051bWVyaWMgPT09IG51bGwpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICc8ZGVsaW0tdG9rZW4+JyxcbiAgICAgICAgICB2YWx1ZTogY29kZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfZCA9IF9fcmVhZChwbHVzTnVtZXJpYywgMiksXG4gICAgICAgICAgICBsYXN0SW5kZXggPSBfZFswXSxcbiAgICAgICAgICAgIHRva2VuVHVwbGUgPSBfZFsxXTtcblxuICAgICAgICBpZiAodG9rZW5UdXBsZVswXSA9PT0gJzxkaW1lbnNpb24tdG9rZW4+Jykge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICc8ZGltZW5zaW9uLXRva2VuPicsXG4gICAgICAgICAgICB2YWx1ZTogdG9rZW5UdXBsZVsxXSxcbiAgICAgICAgICAgIHVuaXQ6IHRva2VuVHVwbGVbMl0udG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIGZsYWc6ICdudW1iZXInXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodG9rZW5UdXBsZVswXSA9PT0gJzxudW1iZXItdG9rZW4+Jykge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IHRva2VuVHVwbGVbMF0sXG4gICAgICAgICAgICB2YWx1ZTogdG9rZW5UdXBsZVsxXSxcbiAgICAgICAgICAgIGZsYWc6IHRva2VuVHVwbGVbMl1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiB0b2tlblR1cGxlWzBdLFxuICAgICAgICAgICAgdmFsdWU6IHRva2VuVHVwbGVbMV0sXG4gICAgICAgICAgICBmbGFnOiAnbnVtYmVyJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwMmMpIHtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJzxjb21tYS10b2tlbj4nXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAyZCkge1xuICAgICAgdmFyIG1pbnVzTnVtZXJpYyA9IGNvbnN1bWVOdW1lcmljKHN0ciwgaW5kZXgpO1xuXG4gICAgICBpZiAobWludXNOdW1lcmljICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBfZSA9IF9fcmVhZChtaW51c051bWVyaWMsIDIpLFxuICAgICAgICAgICAgbGFzdEluZGV4ID0gX2VbMF0sXG4gICAgICAgICAgICB0b2tlblR1cGxlID0gX2VbMV07XG5cbiAgICAgICAgaWYgKHRva2VuVHVwbGVbMF0gPT09ICc8ZGltZW5zaW9uLXRva2VuPicpIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnPGRpbWVuc2lvbi10b2tlbj4nLFxuICAgICAgICAgICAgdmFsdWU6IHRva2VuVHVwbGVbMV0sXG4gICAgICAgICAgICB1bml0OiB0b2tlblR1cGxlWzJdLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICBmbGFnOiAnbnVtYmVyJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRva2VuVHVwbGVbMF0gPT09ICc8bnVtYmVyLXRva2VuPicpIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiB0b2tlblR1cGxlWzBdLFxuICAgICAgICAgICAgdmFsdWU6IHRva2VuVHVwbGVbMV0sXG4gICAgICAgICAgICBmbGFnOiB0b2tlblR1cGxlWzJdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogdG9rZW5UdXBsZVswXSxcbiAgICAgICAgICAgIHZhbHVlOiB0b2tlblR1cGxlWzFdLFxuICAgICAgICAgICAgZmxhZzogJ251bWJlcidcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ICsgMiA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5leHRDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcbiAgICAgICAgdmFyIG5leHROZXh0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMik7XG5cbiAgICAgICAgaWYgKG5leHRDb2RlID09PSAweDAwMmQgJiYgbmV4dE5leHRDb2RlID09PSAweDAwM2UpIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnPENEQy10b2tlbj4nXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gY29uc3VtZUlkZW50TGlrZShzdHIsIGluZGV4KTtcblxuICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX2YgPSBfX3JlYWQocmVzdWx0LCAzKSxcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IF9mWzBdLFxuICAgICAgICAgICAgdmFsdWUgPSBfZlsxXSxcbiAgICAgICAgICAgIHR5cGUgPSBfZlsyXTtcblxuICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPGRlbGltLXRva2VuPicsXG4gICAgICAgIHZhbHVlOiBjb2RlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAyZSkge1xuICAgICAgdmFyIG1pbnVzTnVtZXJpYyA9IGNvbnN1bWVOdW1lcmljKHN0ciwgaW5kZXgpO1xuXG4gICAgICBpZiAobWludXNOdW1lcmljID09PSBudWxsKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnPGRlbGltLXRva2VuPicsXG4gICAgICAgICAgdmFsdWU6IGNvZGVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2cgPSBfX3JlYWQobWludXNOdW1lcmljLCAyKSxcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IF9nWzBdLFxuICAgICAgICAgICAgdG9rZW5UdXBsZSA9IF9nWzFdO1xuXG4gICAgICAgIGlmICh0b2tlblR1cGxlWzBdID09PSAnPGRpbWVuc2lvbi10b2tlbj4nKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJzxkaW1lbnNpb24tdG9rZW4+JyxcbiAgICAgICAgICAgIHZhbHVlOiB0b2tlblR1cGxlWzFdLFxuICAgICAgICAgICAgdW5pdDogdG9rZW5UdXBsZVsyXS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgZmxhZzogJ251bWJlcidcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0b2tlblR1cGxlWzBdID09PSAnPG51bWJlci10b2tlbj4nKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogdG9rZW5UdXBsZVswXSxcbiAgICAgICAgICAgIHZhbHVlOiB0b2tlblR1cGxlWzFdLFxuICAgICAgICAgICAgZmxhZzogdG9rZW5UdXBsZVsyXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IHRva2VuVHVwbGVbMF0sXG4gICAgICAgICAgICB2YWx1ZTogdG9rZW5UdXBsZVsxXSxcbiAgICAgICAgICAgIGZsYWc6ICdudW1iZXInXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwM2EpIHtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJzxjb2xvbi10b2tlbj4nXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAzYikge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPHNlbWljb2xvbi10b2tlbj4nXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAzYykge1xuICAgICAgaWYgKGluZGV4ICsgMyA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5leHRDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcbiAgICAgICAgdmFyIG5leHROZXh0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMik7XG4gICAgICAgIHZhciBuZXh0TmV4dE5leHRDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAzKTtcblxuICAgICAgICBpZiAobmV4dENvZGUgPT09IDB4MDAyMSAmJiBuZXh0TmV4dENvZGUgPT09IDB4MDAyZCAmJiBuZXh0TmV4dE5leHRDb2RlID09PSAweDAwMmQpIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnPENETy10b2tlbj4nXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaW5kZXggKz0gMztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICc8ZGVsaW0tdG9rZW4+JyxcbiAgICAgICAgdmFsdWU6IGNvZGVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDQwKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gY29uc3VtZUlkZW50KHN0ciwgaW5kZXggKyAxKTtcblxuICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX2ggPSBfX3JlYWQocmVzdWx0LCAyKSxcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IF9oWzBdLFxuICAgICAgICAgICAgdmFsdWUgPSBfaFsxXTtcblxuICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJzxhdC1rZXl3b3JkLXRva2VuPicsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLnRvTG93ZXJDYXNlKClcbiAgICAgICAgfSk7XG4gICAgICAgIGluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPGRlbGltLXRva2VuPicsXG4gICAgICAgIHZhbHVlOiBjb2RlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDA1Yikge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPFstdG9rZW4+J1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwNWMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBjb25zdW1lRXNjYXBlKHN0ciwgaW5kZXgpO1xuXG4gICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2ogPSBfX3JlYWQocmVzdWx0LCAyKSxcbiAgICAgICAgICBsYXN0SW5kZXggPSBfalswXSxcbiAgICAgICAgICB2YWx1ZSA9IF9qWzFdO1xuXG4gICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgaW5kZXgpICsgdmFsdWUgKyBzdHIuc2xpY2UobGFzdEluZGV4ICsgMSk7XG4gICAgICBpbmRleCAtPSAxO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDVkKSB7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICc8XS10b2tlbj4nXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDA3Yikge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPHstdG9rZW4+J1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwN2QpIHtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJzx9LXRva2VuPidcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZSA+PSAweDAwMzAgJiYgY29kZSA8PSAweDAwMzkpIHtcbiAgICAgIHZhciByZXN1bHQgPSBjb25zdW1lTnVtZXJpYyhzdHIsIGluZGV4KTtcblxuICAgICAgdmFyIF9rID0gX19yZWFkKHJlc3VsdCwgMiksXG4gICAgICAgICAgbGFzdEluZGV4ID0gX2tbMF0sXG4gICAgICAgICAgdG9rZW5UdXBsZSA9IF9rWzFdO1xuXG4gICAgICBpZiAodG9rZW5UdXBsZVswXSA9PT0gJzxkaW1lbnNpb24tdG9rZW4+Jykge1xuICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJzxkaW1lbnNpb24tdG9rZW4+JyxcbiAgICAgICAgICB2YWx1ZTogdG9rZW5UdXBsZVsxXSxcbiAgICAgICAgICB1bml0OiB0b2tlblR1cGxlWzJdLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgZmxhZzogJ251bWJlcidcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHRva2VuVHVwbGVbMF0gPT09ICc8bnVtYmVyLXRva2VuPicpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6IHRva2VuVHVwbGVbMF0sXG4gICAgICAgICAgdmFsdWU6IHRva2VuVHVwbGVbMV0sXG4gICAgICAgICAgZmxhZzogdG9rZW5UdXBsZVsyXVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiB0b2tlblR1cGxlWzBdLFxuICAgICAgICAgIHZhbHVlOiB0b2tlblR1cGxlWzFdLFxuICAgICAgICAgIGZsYWc6ICdudW1iZXInXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpbmRleCA9IGxhc3RJbmRleDtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDA1ZiB8fCBjb2RlID49IDB4MDA0MSAmJiBjb2RlIDw9IDB4MDA1YSB8fCBjb2RlID49IDB4MDA2MSAmJiBjb2RlIDw9IDB4MDA3YSB8fCBjb2RlID49IDB4MDA4MCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGNvbnN1bWVJZGVudExpa2Uoc3RyLCBpbmRleCk7XG5cbiAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBfbCA9IF9fcmVhZChyZXN1bHQsIDMpLFxuICAgICAgICAgIGxhc3RJbmRleCA9IF9sWzBdLFxuICAgICAgICAgIHZhbHVlID0gX2xbMV0sXG4gICAgICAgICAgdHlwZSA9IF9sWzJdO1xuXG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgICBpbmRleCA9IGxhc3RJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPGRlbGltLXRva2VuPicsXG4gICAgICAgIHZhbHVlOiBjb2RlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICB0b2tlbnMucHVzaCh7XG4gICAgdHlwZTogJzxFT0YtdG9rZW4+J1xuICB9KTtcbiAgcmV0dXJuIHRva2Vucztcbn07XG52YXIgY29uc3VtZVN0cmluZyA9IGZ1bmN0aW9uIGNvbnN1bWVTdHJpbmcoc3RyLCBpbmRleCkge1xuICBpZiAoc3RyLmxlbmd0aCA8PSBpbmRleCArIDEpIHJldHVybiBudWxsO1xuICB2YXIgZmlyc3RDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgpO1xuICB2YXIgY2hhckNvZGVzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IGluZGV4ICsgMTsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoY29kZSA9PT0gZmlyc3RDb2RlKSB7XG4gICAgICByZXR1cm4gW2ksIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY2hhckNvZGVzKV07XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwNWMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBjb25zdW1lRXNjYXBlKHN0ciwgaSk7XG4gICAgICBpZiAocmVzdWx0ID09PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICAgICAgdmFyIF9hID0gX19yZWFkKHJlc3VsdCwgMiksXG4gICAgICAgICAgbGFzdEluZGV4ID0gX2FbMF0sXG4gICAgICAgICAgY2hhckNvZGUgPSBfYVsxXTtcblxuICAgICAgY2hhckNvZGVzLnB1c2goY2hhckNvZGUpO1xuICAgICAgaSA9IGxhc3RJbmRleDtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAwYSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoYXJDb2Rlcy5wdXNoKGNvZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcbnZhciB3b3VsZFN0YXJ0SWRlbnRpZmllciA9IGZ1bmN0aW9uIHdvdWxkU3RhcnRJZGVudGlmaWVyKHN0ciwgaW5kZXgpIHtcbiAgaWYgKHN0ci5sZW5ndGggPD0gaW5kZXgpIHJldHVybiBmYWxzZTtcbiAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgaWYgKGNvZGUgPT09IDB4MDAyZCkge1xuICAgIGlmIChzdHIubGVuZ3RoIDw9IGluZGV4ICsgMSkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBuZXh0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG5cbiAgICBpZiAobmV4dENvZGUgPT09IDB4MDAyZCB8fCBuZXh0Q29kZSA9PT0gMHgwMDVmIHx8IG5leHRDb2RlID49IDB4MDA0MSAmJiBuZXh0Q29kZSA8PSAweDAwNWEgfHwgbmV4dENvZGUgPj0gMHgwMDYxICYmIG5leHRDb2RlIDw9IDB4MDA3YSB8fCBuZXh0Q29kZSA+PSAweDAwODApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAobmV4dENvZGUgPT09IDB4MDA1Yykge1xuICAgICAgaWYgKHN0ci5sZW5ndGggPD0gaW5kZXggKyAyKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgbmV4dE5leHRDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAyKTtcbiAgICAgIHJldHVybiBuZXh0TmV4dENvZGUgIT09IDB4MDAwYTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwNWYgfHwgY29kZSA+PSAweDAwNDEgJiYgY29kZSA8PSAweDAwNWEgfHwgY29kZSA+PSAweDAwNjEgJiYgY29kZSA8PSAweDAwN2EgfHwgY29kZSA+PSAweDAwODApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwNWMpIHtcbiAgICBpZiAoc3RyLmxlbmd0aCA8PSBpbmRleCArIDEpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgbmV4dENvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCArIDEpO1xuICAgIHJldHVybiBuZXh0Q29kZSAhPT0gMHgwMDBhO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbnZhciBjb25zdW1lRXNjYXBlID0gZnVuY3Rpb24gY29uc3VtZUVzY2FwZShzdHIsIGluZGV4KSB7XG4gIGlmIChzdHIubGVuZ3RoIDw9IGluZGV4ICsgMSkgcmV0dXJuIG51bGw7XG4gIGlmIChzdHIuY2hhckNvZGVBdChpbmRleCkgIT09IDB4MDA1YykgcmV0dXJuIG51bGw7XG4gIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcblxuICBpZiAoY29kZSA9PT0gMHgwMDBhKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAoY29kZSA+PSAweDAwMzAgJiYgY29kZSA8PSAweDAwMzkgfHwgY29kZSA+PSAweDAwNDEgJiYgY29kZSA8PSAweDAwNDYgfHwgY29kZSA+PSAweDAwNjEgJiYgY29kZSA8PSAweDAwNjYpIHtcbiAgICB2YXIgaGV4Q2hhckNvZGVzID0gW2NvZGVdO1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbihpbmRleCArIDcsIHN0ci5sZW5ndGgpO1xuICAgIHZhciBpID0gaW5kZXggKyAyO1xuXG4gICAgZm9yICg7IGkgPCBtaW47IGkgKz0gMSkge1xuICAgICAgdmFyIGNvZGVfMiA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICBpZiAoY29kZV8yID49IDB4MDAzMCAmJiBjb2RlXzIgPD0gMHgwMDM5IHx8IGNvZGVfMiA+PSAweDAwNDEgJiYgY29kZV8yIDw9IDB4MDA0NiB8fCBjb2RlXzIgPj0gMHgwMDYxICYmIGNvZGVfMiA8PSAweDAwNjYpIHtcbiAgICAgICAgaGV4Q2hhckNvZGVzLnB1c2goY29kZV8yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpIDwgc3RyLmxlbmd0aCkge1xuICAgICAgdmFyIGNvZGVfMyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICBpZiAoY29kZV8zID09PSAweDAwMDkgfHwgY29kZV8zID09PSAweDAwMjAgfHwgY29kZV8zID09PSAweDAwMGEpIHtcbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbaSAtIDEsIHBhcnNlSW50KFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgaGV4Q2hhckNvZGVzKSwgMTYpXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW2luZGV4ICsgMSwgY29kZV07XG4gIH1cbn07XG52YXIgY29uc3VtZU51bWVyaWMgPSBmdW5jdGlvbiBjb25zdW1lTnVtZXJpYyhzdHIsIGluZGV4KSB7XG4gIHZhciBudW1iZXJSZXN1bHQgPSBjb25zdW1lTnVtYmVyKHN0ciwgaW5kZXgpO1xuICBpZiAobnVtYmVyUmVzdWx0ID09PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICB2YXIgX2EgPSBfX3JlYWQobnVtYmVyUmVzdWx0LCAzKSxcbiAgICAgIG51bWJlckVuZEluZGV4ID0gX2FbMF0sXG4gICAgICBudW1iZXJWYWx1ZSA9IF9hWzFdLFxuICAgICAgbnVtYmVyRmxhZyA9IF9hWzJdO1xuXG4gIHZhciBpZGVudFJlc3VsdCA9IGNvbnN1bWVJZGVudChzdHIsIG51bWJlckVuZEluZGV4ICsgMSk7XG5cbiAgaWYgKGlkZW50UmVzdWx0ICE9PSBudWxsKSB7XG4gICAgdmFyIF9iID0gX19yZWFkKGlkZW50UmVzdWx0LCAyKSxcbiAgICAgICAgaWRlbnRFbmRJbmRleCA9IF9iWzBdLFxuICAgICAgICBpZGVudFZhbHVlID0gX2JbMV07XG5cbiAgICByZXR1cm4gW2lkZW50RW5kSW5kZXgsIFsnPGRpbWVuc2lvbi10b2tlbj4nLCBudW1iZXJWYWx1ZSwgaWRlbnRWYWx1ZV1dO1xuICB9XG5cbiAgaWYgKG51bWJlckVuZEluZGV4ICsgMSA8IHN0ci5sZW5ndGggJiYgc3RyLmNoYXJDb2RlQXQobnVtYmVyRW5kSW5kZXggKyAxKSA9PT0gMHgwMDI1KSB7XG4gICAgcmV0dXJuIFtudW1iZXJFbmRJbmRleCArIDEsIFsnPHBlcmNlbnRhZ2UtdG9rZW4+JywgbnVtYmVyVmFsdWVdXTtcbiAgfVxuXG4gIHJldHVybiBbbnVtYmVyRW5kSW5kZXgsIFsnPG51bWJlci10b2tlbj4nLCBudW1iZXJWYWx1ZSwgbnVtYmVyRmxhZ11dO1xufTtcbnZhciBjb25zdW1lTnVtYmVyID0gZnVuY3Rpb24gY29uc3VtZU51bWJlcihzdHIsIGluZGV4KSB7XG4gIGlmIChzdHIubGVuZ3RoIDw9IGluZGV4KSByZXR1cm4gbnVsbDtcbiAgdmFyIGZsYWcgPSAnaW50ZWdlcic7XG4gIHZhciBudW1iZXJDaGFycyA9IFtdO1xuICB2YXIgZmlyc3RDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gIGlmIChmaXJzdENvZGUgPT09IDB4MDAyYiB8fCBmaXJzdENvZGUgPT09IDB4MDAyZCkge1xuICAgIGluZGV4ICs9IDE7XG4gICAgaWYgKGZpcnN0Q29kZSA9PT0gMHgwMDJkKSBudW1iZXJDaGFycy5wdXNoKDB4MDAyZCk7XG4gIH1cblxuICB3aGlsZSAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgICBpZiAoY29kZSA+PSAweDAwMzAgJiYgY29kZSA8PSAweDAwMzkpIHtcbiAgICAgIG51bWJlckNoYXJzLnB1c2goY29kZSk7XG4gICAgICBpbmRleCArPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoaW5kZXggKyAxIDwgc3RyLmxlbmd0aCkge1xuICAgIHZhciBuZXh0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICB2YXIgbmV4dE5leHRDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcblxuICAgIGlmIChuZXh0Q29kZSA9PT0gMHgwMDJlICYmIG5leHROZXh0Q29kZSA+PSAweDAwMzAgJiYgbmV4dE5leHRDb2RlIDw9IDB4MDAzOSkge1xuICAgICAgbnVtYmVyQ2hhcnMucHVzaChuZXh0Q29kZSwgbmV4dE5leHRDb2RlKTtcbiAgICAgIGZsYWcgPSAnbnVtYmVyJztcbiAgICAgIGluZGV4ICs9IDI7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgICAgICAgaWYgKGNvZGUgPj0gMHgwMDMwICYmIGNvZGUgPD0gMHgwMDM5KSB7XG4gICAgICAgICAgbnVtYmVyQ2hhcnMucHVzaChjb2RlKTtcbiAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGluZGV4ICsgMSA8IHN0ci5sZW5ndGgpIHtcbiAgICB2YXIgbmV4dENvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG4gICAgdmFyIG5leHROZXh0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG4gICAgdmFyIG5leHROZXh0TmV4dENvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCArIDIpO1xuXG4gICAgaWYgKG5leHRDb2RlID09PSAweDAwNDUgfHwgbmV4dENvZGUgPT09IDB4MDA2NSkge1xuICAgICAgdmFyIG5leHROZXh0SXNEaWdpdCA9IG5leHROZXh0Q29kZSA+PSAweDAwMzAgJiYgbmV4dE5leHRDb2RlIDw9IDB4MDAzOTtcblxuICAgICAgaWYgKG5leHROZXh0SXNEaWdpdCB8fCAobmV4dE5leHRDb2RlID09PSAweDAwMmIgfHwgbmV4dE5leHRDb2RlID09PSAweDAwMmQpICYmIG5leHROZXh0TmV4dENvZGUgPj0gMHgwMDMwICYmIG5leHROZXh0TmV4dENvZGUgPD0gMHgwMDM5KSB7XG4gICAgICAgIGZsYWcgPSAnbnVtYmVyJztcblxuICAgICAgICBpZiAobmV4dE5leHRJc0RpZ2l0KSB7XG4gICAgICAgICAgbnVtYmVyQ2hhcnMucHVzaCgweDAwNDUsIG5leHROZXh0Q29kZSk7XG4gICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0TmV4dENvZGUgPT09IDB4MDAyZCkge1xuICAgICAgICAgIG51bWJlckNoYXJzLnB1c2goMHgwMDQ1LCAweDAwMmQsIG5leHROZXh0TmV4dENvZGUpO1xuICAgICAgICAgIGluZGV4ICs9IDM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbnVtYmVyQ2hhcnMucHVzaCgweDAwNDUsIG5leHROZXh0TmV4dENvZGUpO1xuICAgICAgICAgIGluZGV4ICs9IDM7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgICAgICAgICBpZiAoY29kZSA+PSAweDAwMzAgJiYgY29kZSA8PSAweDAwMzkpIHtcbiAgICAgICAgICAgIG51bWJlckNoYXJzLnB1c2goY29kZSk7XG4gICAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgbnVtYmVyU3RyaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBudW1iZXJDaGFycyk7XG4gIHZhciB2YWx1ZSA9IGZsYWcgPT09ICdudW1iZXInID8gcGFyc2VGbG9hdChudW1iZXJTdHJpbmcpIDogcGFyc2VJbnQobnVtYmVyU3RyaW5nKTtcbiAgaWYgKHZhbHVlID09PSAtMCkgdmFsdWUgPSAwO1xuICByZXR1cm4gTnVtYmVyLmlzTmFOKHZhbHVlKSA/IG51bGwgOiBbaW5kZXggLSAxLCB2YWx1ZSwgZmxhZ107XG59O1xudmFyIGNvbnN1bWVJZGVudFVuc2FmZSA9IGZ1bmN0aW9uIGNvbnN1bWVJZGVudFVuc2FmZShzdHIsIGluZGV4KSB7XG4gIGlmIChzdHIubGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgaWRlbnRDaGFycyA9IFtdO1xuXG4gIGZvciAodmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7IGluZGV4IDwgc3RyLmxlbmd0aDsgY29kZSA9IHN0ci5jaGFyQ29kZUF0KCsraW5kZXgpKSB7XG4gICAgaWYgKGNvZGUgPT09IDB4MDAyZCB8fCBjb2RlID09PSAweDAwNWYgfHwgY29kZSA+PSAweDAwNDEgJiYgY29kZSA8PSAweDAwNWEgfHwgY29kZSA+PSAweDAwNjEgJiYgY29kZSA8PSAweDAwN2EgfHwgY29kZSA+PSAweDAwODAgfHwgY29kZSA+PSAweDAwMzAgJiYgY29kZSA8PSAweDAwMzkpIHtcbiAgICAgIGlkZW50Q2hhcnMucHVzaChjb2RlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVzdWx0ID0gY29uc3VtZUVzY2FwZShzdHIsIGluZGV4KTtcblxuICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX2EgPSBfX3JlYWQocmVzdWx0LCAyKSxcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IF9hWzBdLFxuICAgICAgICAgICAgY29kZV80ID0gX2FbMV07XG5cbiAgICAgICAgaWRlbnRDaGFycy5wdXNoKGNvZGVfNCk7XG4gICAgICAgIGluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBpbmRleCA9PT0gMCA/IG51bGwgOiBbaW5kZXggLSAxLCBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGlkZW50Q2hhcnMpXTtcbn07XG52YXIgY29uc3VtZUlkZW50ID0gZnVuY3Rpb24gY29uc3VtZUlkZW50KHN0ciwgaW5kZXgpIHtcbiAgaWYgKHN0ci5sZW5ndGggPD0gaW5kZXggfHwgIXdvdWxkU3RhcnRJZGVudGlmaWVyKHN0ciwgaW5kZXgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgaWRlbnRDaGFycyA9IFtdO1xuXG4gIGZvciAodmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7IGluZGV4IDwgc3RyLmxlbmd0aDsgY29kZSA9IHN0ci5jaGFyQ29kZUF0KCsraW5kZXgpKSB7XG4gICAgaWYgKGNvZGUgPT09IDB4MDAyZCB8fCBjb2RlID09PSAweDAwNWYgfHwgY29kZSA+PSAweDAwNDEgJiYgY29kZSA8PSAweDAwNWEgfHwgY29kZSA+PSAweDAwNjEgJiYgY29kZSA8PSAweDAwN2EgfHwgY29kZSA+PSAweDAwODAgfHwgY29kZSA+PSAweDAwMzAgJiYgY29kZSA8PSAweDAwMzkpIHtcbiAgICAgIGlkZW50Q2hhcnMucHVzaChjb2RlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVzdWx0ID0gY29uc3VtZUVzY2FwZShzdHIsIGluZGV4KTtcblxuICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX2EgPSBfX3JlYWQocmVzdWx0LCAyKSxcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IF9hWzBdLFxuICAgICAgICAgICAgY29kZV81ID0gX2FbMV07XG5cbiAgICAgICAgaWRlbnRDaGFycy5wdXNoKGNvZGVfNSk7XG4gICAgICAgIGluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBbaW5kZXggLSAxLCBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGlkZW50Q2hhcnMpXTtcbn07XG52YXIgY29uc3VtZVVybCA9IGZ1bmN0aW9uIGNvbnN1bWVVcmwoc3RyLCBpbmRleCkge1xuICB2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4KTtcblxuICB3aGlsZSAoY29kZSA9PT0gMHgwMDA5IHx8IGNvZGUgPT09IDB4MDAyMCB8fCBjb2RlID09PSAweDAwMGEpIHtcbiAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQoKytpbmRleCk7XG4gIH1cblxuICB2YXIgdXJsQ2hhcnMgPSBbXTtcbiAgdmFyIGhhc0ZpbmlzaGVkV29yZCA9IGZhbHNlO1xuXG4gIHdoaWxlIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICBpZiAoY29kZSA9PT0gMHgwMDI5KSB7XG4gICAgICByZXR1cm4gW2luZGV4LCBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHVybENoYXJzKV07XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwMjIgfHwgY29kZSA9PT0gMHgwMDI3IHx8IGNvZGUgPT09IDB4MDAyOCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwMDkgfHwgY29kZSA9PT0gMHgwMDIwIHx8IGNvZGUgPT09IDB4MDAwYSkge1xuICAgICAgaWYgKCFoYXNGaW5pc2hlZFdvcmQgJiYgdXJsQ2hhcnMubGVuZ3RoICE9PSAwKSBoYXNGaW5pc2hlZFdvcmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDVjKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gY29uc3VtZUVzY2FwZShzdHIsIGluZGV4KTtcbiAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgaGFzRmluaXNoZWRXb3JkKSByZXR1cm4gbnVsbDtcblxuICAgICAgdmFyIF9hID0gX19yZWFkKHJlc3VsdCwgMiksXG4gICAgICAgICAgbGFzdEluZGV4ID0gX2FbMF0sXG4gICAgICAgICAgdmFsdWUgPSBfYVsxXTtcblxuICAgICAgdXJsQ2hhcnMucHVzaCh2YWx1ZSk7XG4gICAgICBpbmRleCA9IGxhc3RJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhc0ZpbmlzaGVkV29yZCkgcmV0dXJuIG51bGw7XG4gICAgICB1cmxDaGFycy5wdXNoKGNvZGUpO1xuICAgIH1cblxuICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdCgrK2luZGV4KTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcbnZhciBjb25zdW1lSWRlbnRMaWtlID0gZnVuY3Rpb24gY29uc3VtZUlkZW50TGlrZShzdHIsIGluZGV4KSB7XG4gIHZhciByZXN1bHQgPSBjb25zdW1lSWRlbnQoc3RyLCBpbmRleCk7XG4gIGlmIChyZXN1bHQgPT09IG51bGwpIHJldHVybiBudWxsO1xuXG4gIHZhciBfYSA9IF9fcmVhZChyZXN1bHQsIDIpLFxuICAgICAgbGFzdEluZGV4ID0gX2FbMF0sXG4gICAgICB2YWx1ZSA9IF9hWzFdO1xuXG4gIGlmICh2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAndXJsJykge1xuICAgIGlmIChzdHIubGVuZ3RoID4gbGFzdEluZGV4ICsgMSkge1xuICAgICAgdmFyIG5leHRDb2RlID0gc3RyLmNoYXJDb2RlQXQobGFzdEluZGV4ICsgMSk7XG5cbiAgICAgIGlmIChuZXh0Q29kZSA9PT0gMHgwMDI4KSB7XG4gICAgICAgIGZvciAodmFyIG9mZnNldCA9IDI7IGxhc3RJbmRleCArIG9mZnNldCA8IHN0ci5sZW5ndGg7IG9mZnNldCArPSAxKSB7XG4gICAgICAgICAgdmFyIG5leHROZXh0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGxhc3RJbmRleCArIG9mZnNldCk7XG5cbiAgICAgICAgICBpZiAobmV4dE5leHRDb2RlID09PSAweDAwMjIgfHwgbmV4dE5leHRDb2RlID09PSAweDAwMjcpIHtcbiAgICAgICAgICAgIHJldHVybiBbbGFzdEluZGV4ICsgMSwgdmFsdWUudG9Mb3dlckNhc2UoKSwgJzxmdW5jdGlvbi10b2tlbj4nXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5leHROZXh0Q29kZSAhPT0gMHgwMDA5ICYmIG5leHROZXh0Q29kZSAhPT0gMHgwMDIwICYmIG5leHROZXh0Q29kZSAhPT0gMHgwMDBhKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0XzEgPSBjb25zdW1lVXJsKHN0ciwgbGFzdEluZGV4ICsgb2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRfMSA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChyZXN1bHRfMSwgMiksXG4gICAgICAgICAgICAgICAgbGFzdFVybEluZGV4ID0gX2JbMF0sXG4gICAgICAgICAgICAgICAgdmFsdWVfMSA9IF9iWzFdO1xuXG4gICAgICAgICAgICByZXR1cm4gW2xhc3RVcmxJbmRleCwgdmFsdWVfMSwgJzx1cmwtdG9rZW4+J107XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtsYXN0SW5kZXggKyAxLCB2YWx1ZS50b0xvd2VyQ2FzZSgpLCAnPGZ1bmN0aW9uLXRva2VuPiddO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChzdHIubGVuZ3RoID4gbGFzdEluZGV4ICsgMSkge1xuICAgIHZhciBuZXh0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGxhc3RJbmRleCArIDEpO1xuXG4gICAgaWYgKG5leHRDb2RlID09PSAweDAwMjgpIHtcbiAgICAgIHJldHVybiBbbGFzdEluZGV4ICsgMSwgdmFsdWUudG9Mb3dlckNhc2UoKSwgJzxmdW5jdGlvbi10b2tlbj4nXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gW2xhc3RJbmRleCwgdmFsdWUudG9Mb3dlckNhc2UoKSwgJzxpZGVudC10b2tlbj4nXTtcbn07XG5cbnZhciBzaW1wbGlmeUFTVCA9IGZ1bmN0aW9uIHNpbXBsaWZ5QVNUKGFzdCkge1xuICBmb3IgKHZhciBpID0gYXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgYXN0W2ldID0gc2ltcGxpZnlNZWRpYVF1ZXJ5KGFzdFtpXSk7XG4gIH1cblxuICByZXR1cm4gYXN0O1xufTtcblxudmFyIHNpbXBsaWZ5TWVkaWFRdWVyeSA9IGZ1bmN0aW9uIHNpbXBsaWZ5TWVkaWFRdWVyeShtZWRpYVF1ZXJ5KSB7XG4gIGlmIChtZWRpYVF1ZXJ5Lm1lZGlhQ29uZGl0aW9uID09PSBudWxsKSByZXR1cm4gbWVkaWFRdWVyeTtcbiAgdmFyIG1lZGlhQ29uZGl0aW9uID0gc2ltcGxpZnlNZWRpYUNvbmRpdGlvbihtZWRpYVF1ZXJ5Lm1lZGlhQ29uZGl0aW9uKTtcblxuICBpZiAobWVkaWFDb25kaXRpb24ub3BlcmF0b3IgPT09IG51bGwgJiYgbWVkaWFDb25kaXRpb24uY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmICdjaGlsZHJlbicgaW4gbWVkaWFDb25kaXRpb24uY2hpbGRyZW5bMF0pIHtcbiAgICBtZWRpYUNvbmRpdGlvbiA9IG1lZGlhQ29uZGl0aW9uLmNoaWxkcmVuWzBdO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtZWRpYVByZWZpeDogbWVkaWFRdWVyeS5tZWRpYVByZWZpeCxcbiAgICBtZWRpYVR5cGU6IG1lZGlhUXVlcnkubWVkaWFUeXBlLFxuICAgIG1lZGlhQ29uZGl0aW9uOiBtZWRpYUNvbmRpdGlvblxuICB9O1xufTtcblxudmFyIHNpbXBsaWZ5TWVkaWFDb25kaXRpb24gPSBmdW5jdGlvbiBzaW1wbGlmeU1lZGlhQ29uZGl0aW9uKG1lZGlhQ29uZGl0aW9uKSB7XG4gIGZvciAodmFyIGkgPSBtZWRpYUNvbmRpdGlvbi5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciB1bnNpbXBsaWZpZWRDaGlsZCA9IG1lZGlhQ29uZGl0aW9uLmNoaWxkcmVuW2ldO1xuXG4gICAgaWYgKCEoJ2NvbnRleHQnIGluIHVuc2ltcGxpZmllZENoaWxkKSkge1xuICAgICAgdmFyIGNoaWxkID0gc2ltcGxpZnlNZWRpYUNvbmRpdGlvbih1bnNpbXBsaWZpZWRDaGlsZCk7XG5cbiAgICAgIGlmIChjaGlsZC5vcGVyYXRvciA9PT0gbnVsbCAmJiBjaGlsZC5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgbWVkaWFDb25kaXRpb24uY2hpbGRyZW5baV0gPSBjaGlsZC5jaGlsZHJlblswXTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGQub3BlcmF0b3IgPT09IG1lZGlhQ29uZGl0aW9uLm9wZXJhdG9yICYmIChjaGlsZC5vcGVyYXRvciA9PT0gJ2FuZCcgfHwgY2hpbGQub3BlcmF0b3IgPT09ICdvcicpKSB7XG4gICAgICAgIHZhciBzcGxpY2VBcmdzID0gW2ksIDFdO1xuXG4gICAgICAgIGZvciAodmFyIGlfMSA9IDA7IGlfMSA8IGNoaWxkLmNoaWxkcmVuLmxlbmd0aDsgaV8xKyspIHtcbiAgICAgICAgICBzcGxpY2VBcmdzLnB1c2goY2hpbGQuY2hpbGRyZW5baV8xXSk7XG4gICAgICAgIH1cblxuICAgICAgICBtZWRpYUNvbmRpdGlvbi5jaGlsZHJlbi5zcGxpY2UuYXBwbHkobWVkaWFDb25kaXRpb24uY2hpbGRyZW4sIHNwbGljZUFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZWRpYUNvbmRpdGlvbjtcbn07XG5cbnZhciBjcmVhdGVFcnJvciA9IGZ1bmN0aW9uIGNyZWF0ZUVycm9yKG1lc3NhZ2UsIGVycikge1xuICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiXCIuY29uY2F0KGVyci5tZXNzYWdlLnRyaW0oKSwgXCJcXG5cIikuY29uY2F0KG1lc3NhZ2UudHJpbSgpKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihtZXNzYWdlLnRyaW0oKSk7XG4gIH1cbn07XG5cbnZhciB0b0FTVCA9IGZ1bmN0aW9uIHRvQVNUKHN0cikge1xuICByZXR1cm4gc2ltcGxpZnlBU1QodG9VbmZsYXR0ZW5lZEFTVChzdHIpKTtcbn07XG52YXIgdG9VbmZsYXR0ZW5lZEFTVCA9IGZ1bmN0aW9uIHRvVW5mbGF0dGVuZWRBU1Qoc3RyKSB7XG4gIHZhciB0b2tlbkxpc3QgPSBsZXhpY2FsQW5hbHlzaXMoc3RyLnRyaW0oKSk7XG5cbiAgaWYgKHRva2VuTGlzdCA9PT0gbnVsbCkge1xuICAgIHRocm93IGNyZWF0ZUVycm9yKCdGYWlsZWQgdG9rZW5pemluZycpO1xuICB9XG5cbiAgdmFyIHN0YXJ0SW5kZXggPSAwO1xuICB2YXIgZW5kSW5kZXggPSB0b2tlbkxpc3QubGVuZ3RoIC0gMTtcblxuICBpZiAodG9rZW5MaXN0WzBdLnR5cGUgPT09ICc8YXQta2V5d29yZC10b2tlbj4nICYmIHRva2VuTGlzdFswXS52YWx1ZSA9PT0gJ21lZGlhJykge1xuICAgIGlmICh0b2tlbkxpc3RbMV0udHlwZSAhPT0gJzx3aGl0ZXNwYWNlLXRva2VuPicpIHtcbiAgICAgIHRocm93IGNyZWF0ZUVycm9yKCdFeHBlY3RlZCB3aGl0ZXNwYWNlIGFmdGVyIG1lZGlhJyk7XG4gICAgfVxuXG4gICAgc3RhcnRJbmRleCA9IDI7XG5cbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IHRva2VuTGlzdC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIHZhciB0b2tlbiA9IHRva2VuTGlzdFtpXTtcblxuICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICc8ey10b2tlbj4nKSB7XG4gICAgICAgIGVuZEluZGV4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKHRva2VuLnR5cGUgPT09ICc8c2VtaWNvbG9uLXRva2VuPicpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoXCJFeHBlY3RlZCAneycgaW4gbWVkaWEgcXVlcnkgYnV0IGZvdW5kICc7J1wiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0b2tlbkxpc3QgPSB0b2tlbkxpc3Quc2xpY2Uoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICByZXR1cm4gc3ludGFjdGljQW5hbHlzaXModG9rZW5MaXN0KTtcbn07XG52YXIgcmVtb3ZlV2hpdGVzcGFjZSA9IGZ1bmN0aW9uIHJlbW92ZVdoaXRlc3BhY2UodG9rZW5MaXN0KSB7XG4gIHZhciBuZXdUb2tlbkxpc3QgPSBbXTtcbiAgdmFyIGJlZm9yZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRva2VuTGlzdFtpXS50eXBlID09PSAnPHdoaXRlc3BhY2UtdG9rZW4+Jykge1xuICAgICAgYmVmb3JlID0gdHJ1ZTtcblxuICAgICAgaWYgKG5ld1Rva2VuTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgIG5ld1Rva2VuTGlzdFtuZXdUb2tlbkxpc3QubGVuZ3RoIC0gMV0ud3NBZnRlciA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1Rva2VuTGlzdC5wdXNoKF9fYXNzaWduKF9fYXNzaWduKHt9LCB0b2tlbkxpc3RbaV0pLCB7XG4gICAgICAgIHdzQmVmb3JlOiBiZWZvcmUsXG4gICAgICAgIHdzQWZ0ZXI6IGZhbHNlXG4gICAgICB9KSk7XG4gICAgICBiZWZvcmUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3VG9rZW5MaXN0O1xufTtcbnZhciBzeW50YWN0aWNBbmFseXNpcyA9IGZ1bmN0aW9uIHN5bnRhY3RpY0FuYWx5c2lzKHRva2VuTGlzdCkge1xuICB2YXIgZV8xLCBfYTtcblxuICB2YXIgbWVkaWFRdWVyeUxpc3QgPSBbW11dO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gdG9rZW5MaXN0W2ldO1xuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICc8Y29tbWEtdG9rZW4+Jykge1xuICAgICAgbWVkaWFRdWVyeUxpc3QucHVzaChbXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lZGlhUXVlcnlMaXN0W21lZGlhUXVlcnlMaXN0Lmxlbmd0aCAtIDFdLnB1c2godG9rZW4pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtZWRpYVF1ZXJpZXMgPSBtZWRpYVF1ZXJ5TGlzdC5tYXAocmVtb3ZlV2hpdGVzcGFjZSk7XG5cbiAgaWYgKG1lZGlhUXVlcmllcy5sZW5ndGggPT09IDEgJiYgbWVkaWFRdWVyaWVzWzBdLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbe1xuICAgICAgbWVkaWFDb25kaXRpb246IG51bGwsXG4gICAgICBtZWRpYVByZWZpeDogbnVsbCxcbiAgICAgIG1lZGlhVHlwZTogJ2FsbCdcbiAgICB9XTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbWVkaWFRdWVyeVRva2VucyA9IG1lZGlhUXVlcmllcy5tYXAoZnVuY3Rpb24gKG1lZGlhUXVlcnlUb2tlbnMpIHtcbiAgICAgIGlmIChtZWRpYVF1ZXJ5VG9rZW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0b2tlbml6ZU1lZGlhUXVlcnkobWVkaWFRdWVyeVRva2Vucyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIG5vbk51bGxNZWRpYVF1ZXJ5VG9rZW5zID0gW107XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgbWVkaWFRdWVyeVRva2Vuc18xID0gX192YWx1ZXMobWVkaWFRdWVyeVRva2VucyksIG1lZGlhUXVlcnlUb2tlbnNfMV8xID0gbWVkaWFRdWVyeVRva2Vuc18xLm5leHQoKTsgIW1lZGlhUXVlcnlUb2tlbnNfMV8xLmRvbmU7IG1lZGlhUXVlcnlUb2tlbnNfMV8xID0gbWVkaWFRdWVyeVRva2Vuc18xLm5leHQoKSkge1xuICAgICAgICB2YXIgbWVkaWFRdWVyeVRva2VuID0gbWVkaWFRdWVyeVRva2Vuc18xXzEudmFsdWU7XG5cbiAgICAgICAgaWYgKG1lZGlhUXVlcnlUb2tlbiAhPT0gbnVsbCkge1xuICAgICAgICAgIG5vbk51bGxNZWRpYVF1ZXJ5VG9rZW5zLnB1c2gobWVkaWFRdWVyeVRva2VuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVfMV8xKSB7XG4gICAgICBlXzEgPSB7XG4gICAgICAgIGVycm9yOiBlXzFfMVxuICAgICAgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKG1lZGlhUXVlcnlUb2tlbnNfMV8xICYmICFtZWRpYVF1ZXJ5VG9rZW5zXzFfMS5kb25lICYmIChfYSA9IG1lZGlhUXVlcnlUb2tlbnNfMVtcInJldHVyblwiXSkpIF9hLmNhbGwobWVkaWFRdWVyeVRva2Vuc18xKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9uTnVsbE1lZGlhUXVlcnlUb2tlbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBjcmVhdGVFcnJvcignTm8gdmFsaWQgbWVkaWEgcXVlcmllcycpO1xuICAgIH1cblxuICAgIHJldHVybiBub25OdWxsTWVkaWFRdWVyeVRva2VucztcbiAgfVxufTtcbnZhciB0b2tlbml6ZU1lZGlhUXVlcnkgPSBmdW5jdGlvbiB0b2tlbml6ZU1lZGlhUXVlcnkodG9rZW5zKSB7XG4gIHZhciBmaXJzdFRva2VuID0gdG9rZW5zWzBdO1xuXG4gIGlmIChmaXJzdFRva2VuLnR5cGUgPT09ICc8KC10b2tlbj4nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1lZGlhUHJlZml4OiBudWxsLFxuICAgICAgICBtZWRpYVR5cGU6ICdhbGwnLFxuICAgICAgICBtZWRpYUNvbmRpdGlvbjogdG9rZW5pemVNZWRpYUNvbmRpdGlvbih0b2tlbnMsIHRydWUpXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoXCJFeHBlY3RlZCBtZWRpYSBjb25kaXRpb24gYWZ0ZXIgJygnXCIsIGVycik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGZpcnN0VG9rZW4udHlwZSA9PT0gJzxpZGVudC10b2tlbj4nKSB7XG4gICAgdmFyIG1lZGlhUHJlZml4ID0gbnVsbDtcbiAgICB2YXIgbWVkaWFUeXBlID0gdm9pZCAwO1xuICAgIHZhciB2YWx1ZSA9IGZpcnN0VG9rZW4udmFsdWU7XG5cbiAgICBpZiAodmFsdWUgPT09ICdvbmx5JyB8fCB2YWx1ZSA9PT0gJ25vdCcpIHtcbiAgICAgIG1lZGlhUHJlZml4ID0gdmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0SW5kZXggPSBtZWRpYVByZWZpeCA9PT0gbnVsbCA/IDAgOiAxO1xuXG4gICAgaWYgKHRva2Vucy5sZW5ndGggPD0gZmlyc3RJbmRleCkge1xuICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoXCJFeHBlY3RlZCBleHRyYSB0b2tlbiBpbiBtZWRpYSBxdWVyeVwiKTtcbiAgICB9XG5cbiAgICB2YXIgZmlyc3ROb25VbmFyeVRva2VuID0gdG9rZW5zW2ZpcnN0SW5kZXhdO1xuXG4gICAgaWYgKGZpcnN0Tm9uVW5hcnlUb2tlbi50eXBlID09PSAnPGlkZW50LXRva2VuPicpIHtcbiAgICAgIHZhciB2YWx1ZV8xID0gZmlyc3ROb25VbmFyeVRva2VuLnZhbHVlO1xuXG4gICAgICBpZiAodmFsdWVfMSA9PT0gJ2FsbCcpIHtcbiAgICAgICAgbWVkaWFUeXBlID0gJ2FsbCc7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlXzEgPT09ICdwcmludCcgfHwgdmFsdWVfMSA9PT0gJ3NjcmVlbicpIHtcbiAgICAgICAgbWVkaWFUeXBlID0gdmFsdWVfMTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWVfMSA9PT0gJ3R0eScgfHwgdmFsdWVfMSA9PT0gJ3R2JyB8fCB2YWx1ZV8xID09PSAncHJvamVjdGlvbicgfHwgdmFsdWVfMSA9PT0gJ2hhbmRoZWxkJyB8fCB2YWx1ZV8xID09PSAnYnJhaWxsZScgfHwgdmFsdWVfMSA9PT0gJ2VtYm9zc2VkJyB8fCB2YWx1ZV8xID09PSAnYXVyYWwnIHx8IHZhbHVlXzEgPT09ICdzcGVlY2gnKSB7XG4gICAgICAgIG1lZGlhUHJlZml4ID0gbWVkaWFQcmVmaXggPT09ICdub3QnID8gbnVsbCA6ICdub3QnO1xuICAgICAgICBtZWRpYVR5cGUgPSAnYWxsJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKFwiVW5rbm93biBpZGVudCAnXCIuY29uY2F0KHZhbHVlXzEsIFwiJyBpbiBtZWRpYSBxdWVyeVwiKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtZWRpYVByZWZpeCA9PT0gJ25vdCcgJiYgZmlyc3ROb25VbmFyeVRva2VuLnR5cGUgPT09ICc8KC10b2tlbj4nKSB7XG4gICAgICB2YXIgdG9rZW5zV2l0aFBhcmVucyA9IFt7XG4gICAgICAgIHR5cGU6ICc8KC10b2tlbj4nLFxuICAgICAgICB3c0JlZm9yZTogZmFsc2UsXG4gICAgICAgIHdzQWZ0ZXI6IGZhbHNlXG4gICAgICB9XTtcbiAgICAgIHRva2Vuc1dpdGhQYXJlbnMucHVzaC5hcHBseSh0b2tlbnNXaXRoUGFyZW5zLCB0b2tlbnMpO1xuICAgICAgdG9rZW5zV2l0aFBhcmVucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJzwpLXRva2VuPicsXG4gICAgICAgIHdzQmVmb3JlOiBmYWxzZSxcbiAgICAgICAgd3NBZnRlcjogZmFsc2VcbiAgICAgIH0pO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1lZGlhUHJlZml4OiBudWxsLFxuICAgICAgICAgIG1lZGlhVHlwZTogJ2FsbCcsXG4gICAgICAgICAgbWVkaWFDb25kaXRpb246IHRva2VuaXplTWVkaWFDb25kaXRpb24odG9rZW5zV2l0aFBhcmVucywgdHJ1ZSlcbiAgICAgICAgfTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihcIkV4cGVjdGVkIG1lZGlhIGNvbmRpdGlvbiBhZnRlciAnKCdcIiwgZXJyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoJ0ludmFsaWQgbWVkaWEgcXVlcnknKTtcbiAgICB9XG5cbiAgICBpZiAoZmlyc3RJbmRleCArIDEgPT09IHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1lZGlhUHJlZml4OiBtZWRpYVByZWZpeCxcbiAgICAgICAgbWVkaWFUeXBlOiBtZWRpYVR5cGUsXG4gICAgICAgIG1lZGlhQ29uZGl0aW9uOiBudWxsXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZmlyc3RJbmRleCArIDQgPCB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICB2YXIgc2Vjb25kTm9uVW5hcnlUb2tlbiA9IHRva2Vuc1tmaXJzdEluZGV4ICsgMV07XG5cbiAgICAgIGlmIChzZWNvbmROb25VbmFyeVRva2VuLnR5cGUgPT09ICc8aWRlbnQtdG9rZW4+JyAmJiBzZWNvbmROb25VbmFyeVRva2VuLnZhbHVlID09PSAnYW5kJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZWRpYVByZWZpeDogbWVkaWFQcmVmaXgsXG4gICAgICAgICAgICBtZWRpYVR5cGU6IG1lZGlhVHlwZSxcbiAgICAgICAgICAgIG1lZGlhQ29uZGl0aW9uOiB0b2tlbml6ZU1lZGlhQ29uZGl0aW9uKHRva2Vucy5zbGljZShmaXJzdEluZGV4ICsgMiksIGZhbHNlKVxuICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHRocm93IGNyZWF0ZUVycm9yKFwiRXhwZWN0ZWQgbWVkaWEgY29uZGl0aW9uIGFmdGVyICdhbmQnXCIsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKFwiRXhwZWN0ZWQgJ2FuZCcgYWZ0ZXIgbWVkaWEgcHJlZml4XCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBjcmVhdGVFcnJvcignRXhwZWN0ZWQgbWVkaWEgY29uZGl0aW9uIGFmdGVyIG1lZGlhIHByZWZpeCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBjcmVhdGVFcnJvcignRXhwZWN0ZWQgbWVkaWEgY29uZGl0aW9uIG9yIG1lZGlhIHByZWZpeCcpO1xuICB9XG59O1xudmFyIHRva2VuaXplTWVkaWFDb25kaXRpb24gPSBmdW5jdGlvbiB0b2tlbml6ZU1lZGlhQ29uZGl0aW9uKHRva2VucywgbWF5Q29udGFpbk9yLCBwcmV2aW91c09wZXJhdG9yKSB7XG4gIGlmIChwcmV2aW91c09wZXJhdG9yID09PSB2b2lkIDApIHtcbiAgICBwcmV2aW91c09wZXJhdG9yID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0b2tlbnMubGVuZ3RoIDwgMyB8fCB0b2tlbnNbMF0udHlwZSAhPT0gJzwoLXRva2VuPicgfHwgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS50eXBlICE9PSAnPCktdG9rZW4+Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZWRpYSBjb25kaXRpb24nKTtcbiAgfVxuXG4gIHZhciBlbmRJbmRleE9mRmlyc3RGZWF0dXJlID0gdG9rZW5zLmxlbmd0aCAtIDE7XG4gIHZhciBtYXhEZXB0aCA9IDA7XG4gIHZhciBjb3VudCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJzwoLXRva2VuPicpIHtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgICBtYXhEZXB0aCA9IE1hdGgubWF4KG1heERlcHRoLCBjb3VudCk7XG4gICAgfSBlbHNlIGlmICh0b2tlbi50eXBlID09PSAnPCktdG9rZW4+Jykge1xuICAgICAgY291bnQgLT0gMTtcbiAgICB9XG5cbiAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgIGVuZEluZGV4T2ZGaXJzdEZlYXR1cmUgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvdW50ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNtYXRjaGVkIHBhcmVuc1xcbkludmFsaWQgbWVkaWEgY29uZGl0aW9uJyk7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBmZWF0dXJlVG9rZW5zID0gdG9rZW5zLnNsaWNlKDAsIGVuZEluZGV4T2ZGaXJzdEZlYXR1cmUgKyAxKTtcblxuICBpZiAobWF4RGVwdGggPT09IDEpIHtcbiAgICBjaGlsZCA9IHRva2VuaXplTWVkaWFGZWF0dXJlKGZlYXR1cmVUb2tlbnMpO1xuICB9IGVsc2Uge1xuICAgIGlmIChmZWF0dXJlVG9rZW5zWzFdLnR5cGUgPT09ICc8aWRlbnQtdG9rZW4+JyAmJiBmZWF0dXJlVG9rZW5zWzFdLnZhbHVlID09PSAnbm90Jykge1xuICAgICAgY2hpbGQgPSB0b2tlbml6ZU1lZGlhQ29uZGl0aW9uKGZlYXR1cmVUb2tlbnMuc2xpY2UoMiwgLTEpLCB0cnVlLCAnbm90Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoaWxkID0gdG9rZW5pemVNZWRpYUNvbmRpdGlvbihmZWF0dXJlVG9rZW5zLnNsaWNlKDEsIC0xKSwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZEluZGV4T2ZGaXJzdEZlYXR1cmUgPT09IHRva2Vucy5sZW5ndGggLSAxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wZXJhdG9yOiBwcmV2aW91c09wZXJhdG9yLFxuICAgICAgY2hpbGRyZW46IFtjaGlsZF1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHZhciBuZXh0VG9rZW4gPSB0b2tlbnNbZW5kSW5kZXhPZkZpcnN0RmVhdHVyZSArIDFdO1xuXG4gICAgaWYgKG5leHRUb2tlbi50eXBlICE9PSAnPGlkZW50LXRva2VuPicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBvcGVyYXRvclxcbkludmFsaWQgbWVkaWEgY29uZGl0aW9uJyk7XG4gICAgfSBlbHNlIGlmIChwcmV2aW91c09wZXJhdG9yICE9PSBudWxsICYmIHByZXZpb3VzT3BlcmF0b3IgIT09IG5leHRUb2tlbi52YWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ1wiLmNvbmNhdChuZXh0VG9rZW4udmFsdWUsIFwiJyBhbmQgJ1wiKS5jb25jYXQocHJldmlvdXNPcGVyYXRvciwgXCInIG11c3Qgbm90IGJlIGF0IHNhbWUgbGV2ZWxcXG5JbnZhbGlkIG1lZGlhIGNvbmRpdGlvblwiKSk7XG4gICAgfSBlbHNlIGlmIChuZXh0VG9rZW4udmFsdWUgPT09ICdvcicgJiYgIW1heUNvbnRhaW5Pcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSAnb3InIGF0IHRvcCBsZXZlbCBvZiBhIG1lZGlhIHF1ZXJ5XFxuSW52YWxpZCBtZWRpYSBjb25kaXRpb25cIik7XG4gICAgfSBlbHNlIGlmIChuZXh0VG9rZW4udmFsdWUgIT09ICdhbmQnICYmIG5leHRUb2tlbi52YWx1ZSAhPT0gJ29yJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBvcGVyYXRvcjogJ1wiLmNvbmNhdChuZXh0VG9rZW4udmFsdWUsIFwiJ1xcbkludmFsaWQgbWVkaWEgY29uZGl0aW9uXCIpKTtcbiAgICB9XG5cbiAgICB2YXIgc2libGluZ3MgPSB0b2tlbml6ZU1lZGlhQ29uZGl0aW9uKHRva2Vucy5zbGljZShlbmRJbmRleE9mRmlyc3RGZWF0dXJlICsgMiksIG1heUNvbnRhaW5PciwgbmV4dFRva2VuLnZhbHVlKTtcbiAgICByZXR1cm4ge1xuICAgICAgb3BlcmF0b3I6IG5leHRUb2tlbi52YWx1ZSxcbiAgICAgIGNoaWxkcmVuOiBbY2hpbGRdLmNvbmNhdChzaWJsaW5ncy5jaGlsZHJlbilcbiAgICB9O1xuICB9XG59O1xudmFyIHRva2VuaXplTWVkaWFGZWF0dXJlID0gZnVuY3Rpb24gdG9rZW5pemVNZWRpYUZlYXR1cmUocmF3VG9rZW5zKSB7XG4gIGlmIChyYXdUb2tlbnMubGVuZ3RoIDwgMyB8fCByYXdUb2tlbnNbMF0udHlwZSAhPT0gJzwoLXRva2VuPicgfHwgcmF3VG9rZW5zW3Jhd1Rva2Vucy5sZW5ndGggLSAxXS50eXBlICE9PSAnPCktdG9rZW4+Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZWRpYSBmZWF0dXJlJyk7XG4gIH1cblxuICB2YXIgdG9rZW5zID0gW3Jhd1Rva2Vuc1swXV07XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCByYXdUb2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaSA8IHJhd1Rva2Vucy5sZW5ndGggLSAyKSB7XG4gICAgICB2YXIgYSA9IHJhd1Rva2Vuc1tpXTtcbiAgICAgIHZhciBiID0gcmF3VG9rZW5zW2kgKyAxXTtcbiAgICAgIHZhciBjID0gcmF3VG9rZW5zW2kgKyAyXTtcblxuICAgICAgaWYgKGEudHlwZSA9PT0gJzxudW1iZXItdG9rZW4+JyAmJiBhLnZhbHVlID4gMCAmJiBiLnR5cGUgPT09ICc8ZGVsaW0tdG9rZW4+JyAmJiBiLnZhbHVlID09PSAweDAwMmYgJiYgYy50eXBlID09PSAnPG51bWJlci10b2tlbj4nICYmIGMudmFsdWUgPiAwKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnPHJhdGlvLXRva2VuPicsXG4gICAgICAgICAgbnVtZXJhdG9yOiBhLnZhbHVlLFxuICAgICAgICAgIGRlbm9taW5hdG9yOiBjLnZhbHVlLFxuICAgICAgICAgIHdzQmVmb3JlOiBhLndzQmVmb3JlLFxuICAgICAgICAgIHdzQWZ0ZXI6IGMud3NBZnRlclxuICAgICAgICB9KTtcbiAgICAgICAgaSArPSAyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0b2tlbnMucHVzaChyYXdUb2tlbnNbaV0pO1xuICB9XG5cbiAgdmFyIG5leHRUb2tlbiA9IHRva2Vuc1sxXTtcblxuICBpZiAobmV4dFRva2VuLnR5cGUgPT09ICc8aWRlbnQtdG9rZW4+JyAmJiB0b2tlbnMubGVuZ3RoID09PSAzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRleHQ6ICdib29sZWFuJyxcbiAgICAgIGZlYXR1cmU6IG5leHRUb2tlbi52YWx1ZVxuICAgIH07XG4gIH0gZWxzZSBpZiAodG9rZW5zLmxlbmd0aCA9PT0gNSAmJiB0b2tlbnNbMV0udHlwZSA9PT0gJzxpZGVudC10b2tlbj4nICYmIHRva2Vuc1syXS50eXBlID09PSAnPGNvbG9uLXRva2VuPicpIHtcbiAgICB2YXIgdmFsdWVUb2tlbiA9IHRva2Vuc1szXTtcblxuICAgIGlmICh2YWx1ZVRva2VuLnR5cGUgPT09ICc8bnVtYmVyLXRva2VuPicgfHwgdmFsdWVUb2tlbi50eXBlID09PSAnPGRpbWVuc2lvbi10b2tlbj4nIHx8IHZhbHVlVG9rZW4udHlwZSA9PT0gJzxyYXRpby10b2tlbj4nIHx8IHZhbHVlVG9rZW4udHlwZSA9PT0gJzxpZGVudC10b2tlbj4nKSB7XG4gICAgICB2YXIgZmVhdHVyZSA9IHRva2Vuc1sxXS52YWx1ZTtcbiAgICAgIHZhciBwcmVmaXggPSBudWxsO1xuICAgICAgdmFyIHNsaWNlID0gZmVhdHVyZS5zbGljZSgwLCA0KTtcblxuICAgICAgaWYgKHNsaWNlID09PSAnbWluLScpIHtcbiAgICAgICAgcHJlZml4ID0gJ21pbic7XG4gICAgICAgIGZlYXR1cmUgPSBmZWF0dXJlLnNsaWNlKDQpO1xuICAgICAgfSBlbHNlIGlmIChzbGljZSA9PT0gJ21heC0nKSB7XG4gICAgICAgIHByZWZpeCA9ICdtYXgnO1xuICAgICAgICBmZWF0dXJlID0gZmVhdHVyZS5zbGljZSg0KTtcbiAgICAgIH1cblxuICAgICAgdmFsdWVUb2tlbi53c0JlZm9yZTtcbiAgICAgICAgICB2YWx1ZVRva2VuLndzQWZ0ZXI7XG4gICAgICAgICAgdmFyIHZhbHVlID0gX19yZXN0KHZhbHVlVG9rZW4sIFtcIndzQmVmb3JlXCIsIFwid3NBZnRlclwiXSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRleHQ6ICd2YWx1ZScsXG4gICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICBmZWF0dXJlOiBmZWF0dXJlLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKHRva2Vucy5sZW5ndGggPj0gNSkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgcmFuZ2UgPSB0b2tlbml6ZVJhbmdlKHRva2Vucyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250ZXh0OiAncmFuZ2UnLFxuICAgICAgICBmZWF0dXJlOiByYW5nZS5mZWF0dXJlTmFtZSxcbiAgICAgICAgcmFuZ2U6IHJhbmdlXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoJ0ludmFsaWQgbWVkaWEgZmVhdHVyZScsIGVycik7XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1lZGlhIGZlYXR1cmUnKTtcbn07XG52YXIgdG9rZW5pemVSYW5nZSA9IGZ1bmN0aW9uIHRva2VuaXplUmFuZ2UodG9rZW5zKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZDtcblxuICBpZiAodG9rZW5zLmxlbmd0aCA8IDUgfHwgdG9rZW5zWzBdLnR5cGUgIT09ICc8KC10b2tlbj4nIHx8IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0udHlwZSAhPT0gJzwpLXRva2VuPicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmFuZ2UnKTtcbiAgfVxuXG4gIHZhciByYW5nZSA9IHtcbiAgICBsZWZ0VG9rZW46IG51bGwsXG4gICAgbGVmdE9wOiBudWxsLFxuICAgIGZlYXR1cmVOYW1lOiAnJyxcbiAgICByaWdodE9wOiBudWxsLFxuICAgIHJpZ2h0VG9rZW46IG51bGxcbiAgfTtcbiAgdmFyIGhhc0xlZnQgPSB0b2tlbnNbMV0udHlwZSA9PT0gJzxudW1iZXItdG9rZW4+JyB8fCB0b2tlbnNbMV0udHlwZSA9PT0gJzxkaW1lbnNpb24tdG9rZW4+JyB8fCB0b2tlbnNbMV0udHlwZSA9PT0gJzxyYXRpby10b2tlbj4nIHx8IHRva2Vuc1sxXS50eXBlID09PSAnPGlkZW50LXRva2VuPicgJiYgdG9rZW5zWzFdLnZhbHVlID09PSAnaW5maW5pdGUnO1xuXG4gIGlmICh0b2tlbnNbMl0udHlwZSA9PT0gJzxkZWxpbS10b2tlbj4nKSB7XG4gICAgaWYgKHRva2Vuc1syXS52YWx1ZSA9PT0gMHgwMDNjKSB7XG4gICAgICBpZiAodG9rZW5zWzNdLnR5cGUgPT09ICc8ZGVsaW0tdG9rZW4+JyAmJiB0b2tlbnNbM10udmFsdWUgPT09IDB4MDAzZCAmJiAhdG9rZW5zWzNdLndzQmVmb3JlKSB7XG4gICAgICAgIHJhbmdlW2hhc0xlZnQgPyAnbGVmdE9wJyA6ICdyaWdodE9wJ10gPSAnPD0nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2VbaGFzTGVmdCA/ICdsZWZ0T3AnIDogJ3JpZ2h0T3AnXSA9ICc8JztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRva2Vuc1syXS52YWx1ZSA9PT0gMHgwMDNlKSB7XG4gICAgICBpZiAodG9rZW5zWzNdLnR5cGUgPT09ICc8ZGVsaW0tdG9rZW4+JyAmJiB0b2tlbnNbM10udmFsdWUgPT09IDB4MDAzZCAmJiAhdG9rZW5zWzNdLndzQmVmb3JlKSB7XG4gICAgICAgIHJhbmdlW2hhc0xlZnQgPyAnbGVmdE9wJyA6ICdyaWdodE9wJ10gPSAnPj0nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2VbaGFzTGVmdCA/ICdsZWZ0T3AnIDogJ3JpZ2h0T3AnXSA9ICc+JztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRva2Vuc1syXS52YWx1ZSA9PT0gMHgwMDNkKSB7XG4gICAgICByYW5nZVtoYXNMZWZ0ID8gJ2xlZnRPcCcgOiAncmlnaHRPcCddID0gJz0nO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmFuZ2UnKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzTGVmdCkge1xuICAgICAgcmFuZ2UubGVmdFRva2VuID0gdG9rZW5zWzFdO1xuICAgIH0gZWxzZSBpZiAodG9rZW5zWzFdLnR5cGUgPT09ICc8aWRlbnQtdG9rZW4+Jykge1xuICAgICAgcmFuZ2UuZmVhdHVyZU5hbWUgPSB0b2tlbnNbMV0udmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByYW5nZScpO1xuICAgIH1cblxuICAgIHZhciB0b2tlbkluZGV4QWZ0ZXJGaXJzdE9wID0gMiArICgoX2IgPSAoX2EgPSByYW5nZVtoYXNMZWZ0ID8gJ2xlZnRPcCcgOiAncmlnaHRPcCddKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKTtcbiAgICB2YXIgdG9rZW5BZnRlckZpcnN0T3AgPSB0b2tlbnNbdG9rZW5JbmRleEFmdGVyRmlyc3RPcF07XG5cbiAgICBpZiAoaGFzTGVmdCkge1xuICAgICAgaWYgKHRva2VuQWZ0ZXJGaXJzdE9wLnR5cGUgPT09ICc8aWRlbnQtdG9rZW4+Jykge1xuICAgICAgICByYW5nZS5mZWF0dXJlTmFtZSA9IHRva2VuQWZ0ZXJGaXJzdE9wLnZhbHVlO1xuXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID49IDcpIHtcbiAgICAgICAgICB2YXIgc2Vjb25kT3BUb2tlbiA9IHRva2Vuc1t0b2tlbkluZGV4QWZ0ZXJGaXJzdE9wICsgMV07XG4gICAgICAgICAgdmFyIGZvbGxvd2luZ1Rva2VuID0gdG9rZW5zW3Rva2VuSW5kZXhBZnRlckZpcnN0T3AgKyAyXTtcblxuICAgICAgICAgIGlmIChzZWNvbmRPcFRva2VuLnR5cGUgPT09ICc8ZGVsaW0tdG9rZW4+Jykge1xuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gc2Vjb25kT3BUb2tlbi52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09PSAweDAwM2MpIHtcbiAgICAgICAgICAgICAgaWYgKGZvbGxvd2luZ1Rva2VuLnR5cGUgPT09ICc8ZGVsaW0tdG9rZW4+JyAmJiBmb2xsb3dpbmdUb2tlbi52YWx1ZSA9PT0gMHgwMDNkICYmICFmb2xsb3dpbmdUb2tlbi53c0JlZm9yZSkge1xuICAgICAgICAgICAgICAgIHJhbmdlLnJpZ2h0T3AgPSAnPD0nO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJhbmdlLnJpZ2h0T3AgPSAnPCc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPT09IDB4MDAzZSkge1xuICAgICAgICAgICAgICBpZiAoZm9sbG93aW5nVG9rZW4udHlwZSA9PT0gJzxkZWxpbS10b2tlbj4nICYmIGZvbGxvd2luZ1Rva2VuLnZhbHVlID09PSAweDAwM2QgJiYgIWZvbGxvd2luZ1Rva2VuLndzQmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UucmlnaHRPcCA9ICc+PSc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UucmlnaHRPcCA9ICc+JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJhbmdlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0b2tlbkFmdGVyU2Vjb25kT3AgPSB0b2tlbnNbdG9rZW5JbmRleEFmdGVyRmlyc3RPcCArIDEgKyAoKF9kID0gKF9jID0gcmFuZ2UucmlnaHRPcCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmxlbmd0aCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogMCldO1xuICAgICAgICAgICAgcmFuZ2UucmlnaHRUb2tlbiA9IHRva2VuQWZ0ZXJTZWNvbmRPcDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJhbmdlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRva2VuSW5kZXhBZnRlckZpcnN0T3AgKyAyICE9PSB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByYW5nZScpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZS5yaWdodFRva2VuID0gdG9rZW5BZnRlckZpcnN0T3A7XG4gICAgfVxuXG4gICAgdmFyIHZhbGlkUmFuZ2UgPSBudWxsO1xuICAgIHZhciBsdCA9IHJhbmdlLmxlZnRUb2tlbixcbiAgICAgICAgbGVmdE9wID0gcmFuZ2UubGVmdE9wLFxuICAgICAgICBmZWF0dXJlTmFtZSA9IHJhbmdlLmZlYXR1cmVOYW1lLFxuICAgICAgICByaWdodE9wID0gcmFuZ2UucmlnaHRPcCxcbiAgICAgICAgcnQgPSByYW5nZS5yaWdodFRva2VuO1xuICAgIHZhciBsZWZ0VG9rZW4gPSBudWxsO1xuXG4gICAgaWYgKGx0ICE9PSBudWxsKSB7XG4gICAgICBpZiAobHQudHlwZSA9PT0gJzxpZGVudC10b2tlbj4nKSB7XG4gICAgICAgIHZhciB0eXBlID0gbHQudHlwZSxcbiAgICAgICAgICAgIHZhbHVlID0gbHQudmFsdWU7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSAnaW5maW5pdGUnKSB7XG4gICAgICAgICAgbGVmdFRva2VuID0ge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobHQudHlwZSA9PT0gJzxudW1iZXItdG9rZW4+JyB8fCBsdC50eXBlID09PSAnPGRpbWVuc2lvbi10b2tlbj4nIHx8IGx0LnR5cGUgPT09ICc8cmF0aW8tdG9rZW4+Jykge1xuICAgICAgICBsdC53c0JlZm9yZTtcbiAgICAgICAgICAgIGx0LndzQWZ0ZXI7XG4gICAgICAgICAgICB2YXIgbHROb1dTID0gX19yZXN0KGx0LCBbXCJ3c0JlZm9yZVwiLCBcIndzQWZ0ZXJcIl0pO1xuXG4gICAgICAgIGxlZnRUb2tlbiA9IGx0Tm9XUztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmlnaHRUb2tlbiA9IG51bGw7XG5cbiAgICBpZiAocnQgIT09IG51bGwpIHtcbiAgICAgIGlmIChydC50eXBlID09PSAnPGlkZW50LXRva2VuPicpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBydC50eXBlLFxuICAgICAgICAgICAgdmFsdWUgPSBydC52YWx1ZTtcblxuICAgICAgICBpZiAodmFsdWUgPT09ICdpbmZpbml0ZScpIHtcbiAgICAgICAgICByaWdodFRva2VuID0ge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocnQudHlwZSA9PT0gJzxudW1iZXItdG9rZW4+JyB8fCBydC50eXBlID09PSAnPGRpbWVuc2lvbi10b2tlbj4nIHx8IHJ0LnR5cGUgPT09ICc8cmF0aW8tdG9rZW4+Jykge1xuICAgICAgICBydC53c0JlZm9yZTtcbiAgICAgICAgICAgIHJ0LndzQWZ0ZXI7XG4gICAgICAgICAgICB2YXIgcnROb1dTID0gX19yZXN0KHJ0LCBbXCJ3c0JlZm9yZVwiLCBcIndzQWZ0ZXJcIl0pO1xuXG4gICAgICAgIHJpZ2h0VG9rZW4gPSBydE5vV1M7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxlZnRUb2tlbiAhPT0gbnVsbCAmJiByaWdodFRva2VuICE9PSBudWxsKSB7XG4gICAgICBpZiAoKGxlZnRPcCA9PT0gJzwnIHx8IGxlZnRPcCA9PT0gJzw9JykgJiYgKHJpZ2h0T3AgPT09ICc8JyB8fCByaWdodE9wID09PSAnPD0nKSkge1xuICAgICAgICB2YWxpZFJhbmdlID0ge1xuICAgICAgICAgIGxlZnRUb2tlbjogbGVmdFRva2VuLFxuICAgICAgICAgIGxlZnRPcDogbGVmdE9wLFxuICAgICAgICAgIGZlYXR1cmVOYW1lOiBmZWF0dXJlTmFtZSxcbiAgICAgICAgICByaWdodE9wOiByaWdodE9wLFxuICAgICAgICAgIHJpZ2h0VG9rZW46IHJpZ2h0VG9rZW5cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoKGxlZnRPcCA9PT0gJz4nIHx8IGxlZnRPcCA9PT0gJz49JykgJiYgKHJpZ2h0T3AgPT09ICc+JyB8fCByaWdodE9wID09PSAnPj0nKSkge1xuICAgICAgICB2YWxpZFJhbmdlID0ge1xuICAgICAgICAgIGxlZnRUb2tlbjogbGVmdFRva2VuLFxuICAgICAgICAgIGxlZnRPcDogbGVmdE9wLFxuICAgICAgICAgIGZlYXR1cmVOYW1lOiBmZWF0dXJlTmFtZSxcbiAgICAgICAgICByaWdodE9wOiByaWdodE9wLFxuICAgICAgICAgIHJpZ2h0VG9rZW46IHJpZ2h0VG9rZW5cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByYW5nZScpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGVmdFRva2VuID09PSBudWxsICYmIGxlZnRPcCA9PT0gbnVsbCAmJiByaWdodE9wICE9PSBudWxsICYmIHJpZ2h0VG9rZW4gIT09IG51bGwpIHtcbiAgICAgIHZhbGlkUmFuZ2UgPSB7XG4gICAgICAgIGxlZnRUb2tlbjogbGVmdFRva2VuLFxuICAgICAgICBsZWZ0T3A6IGxlZnRPcCxcbiAgICAgICAgZmVhdHVyZU5hbWU6IGZlYXR1cmVOYW1lLFxuICAgICAgICByaWdodE9wOiByaWdodE9wLFxuICAgICAgICByaWdodFRva2VuOiByaWdodFRva2VuXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAobGVmdFRva2VuICE9PSBudWxsICYmIGxlZnRPcCAhPT0gbnVsbCAmJiByaWdodE9wID09PSBudWxsICYmIHJpZ2h0VG9rZW4gPT09IG51bGwpIHtcbiAgICAgIHZhbGlkUmFuZ2UgPSB7XG4gICAgICAgIGxlZnRUb2tlbjogbGVmdFRva2VuLFxuICAgICAgICBsZWZ0T3A6IGxlZnRPcCxcbiAgICAgICAgZmVhdHVyZU5hbWU6IGZlYXR1cmVOYW1lLFxuICAgICAgICByaWdodE9wOiByaWdodE9wLFxuICAgICAgICByaWdodFRva2VuOiByaWdodFRva2VuXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB2YWxpZFJhbmdlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByYW5nZScpO1xuICB9XG59O1xuXG5leHBvcnQgeyBjb25zdW1lRXNjYXBlLCBjb25zdW1lSWRlbnQsIGNvbnN1bWVJZGVudExpa2UsIGNvbnN1bWVJZGVudFVuc2FmZSwgY29uc3VtZU51bWJlciwgY29uc3VtZU51bWVyaWMsIGNvbnN1bWVTdHJpbmcsIGNvbnN1bWVVcmwsIGxleGljYWxBbmFseXNpcywgcmVtb3ZlV2hpdGVzcGFjZSwgc3ludGFjdGljQW5hbHlzaXMsIHRvQVNULCB0b1VuZmxhdHRlbmVkQVNULCB0b2tlbml6ZU1lZGlhQ29uZGl0aW9uLCB0b2tlbml6ZU1lZGlhRmVhdHVyZSwgdG9rZW5pemVNZWRpYVF1ZXJ5LCB0b2tlbml6ZVJhbmdlLCB3b3VsZFN0YXJ0SWRlbnRpZmllciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVkaWEtcXVlcnktcGFyc2VyLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJfX2Fzc2lnbiIsIk9iamVjdCIsImFzc2lnbiIsInQiLCJzIiwiaSIsIm4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJfX3Jlc3QiLCJlIiwiaW5kZXhPZiIsImdldE93blByb3BlcnR5U3ltYm9scyIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiX192YWx1ZXMiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJtIiwibmV4dCIsInZhbHVlIiwiZG9uZSIsIlR5cGVFcnJvciIsIl9fcmVhZCIsInIiLCJhciIsInB1c2giLCJlcnJvciIsIndlaXJkTmV3bGluZXMiLCJudWxsT3JTdXJyb2dhdGVzIiwiY29tbWVudFJlZ2V4IiwibGV4aWNhbEFuYWx5c2lzIiwic3RyIiwiaW5kZXgiLCJyZXBsYWNlIiwidG9rZW5zIiwiY29kZSIsImNoYXJDb2RlQXQiLCJjb2RlXzEiLCJ0eXBlIiwicmVzdWx0IiwiY29uc3VtZVN0cmluZyIsIl9hIiwibGFzdEluZGV4IiwibmV4dENvZGUiLCJmbGFnIiwid291bGRTdGFydElkZW50aWZpZXIiLCJjb25zdW1lSWRlbnRVbnNhZmUiLCJfYiIsInRvTG93ZXJDYXNlIiwiX2MiLCJwbHVzTnVtZXJpYyIsImNvbnN1bWVOdW1lcmljIiwiX2QiLCJ0b2tlblR1cGxlIiwidW5pdCIsIm1pbnVzTnVtZXJpYyIsIl9lIiwibmV4dE5leHRDb2RlIiwiY29uc3VtZUlkZW50TGlrZSIsIl9mIiwiX2ciLCJuZXh0TmV4dE5leHRDb2RlIiwiY29uc3VtZUlkZW50IiwiX2giLCJjb25zdW1lRXNjYXBlIiwiX2oiLCJzbGljZSIsIl9rIiwiX2wiLCJmaXJzdENvZGUiLCJjaGFyQ29kZXMiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJjaGFyQ29kZSIsImhleENoYXJDb2RlcyIsIm1pbiIsIk1hdGgiLCJjb2RlXzIiLCJjb2RlXzMiLCJwYXJzZUludCIsIm51bWJlclJlc3VsdCIsImNvbnN1bWVOdW1iZXIiLCJudW1iZXJFbmRJbmRleCIsIm51bWJlclZhbHVlIiwibnVtYmVyRmxhZyIsImlkZW50UmVzdWx0IiwiaWRlbnRFbmRJbmRleCIsImlkZW50VmFsdWUiLCJudW1iZXJDaGFycyIsIm5leHROZXh0SXNEaWdpdCIsIm51bWJlclN0cmluZyIsInBhcnNlRmxvYXQiLCJOdW1iZXIiLCJpc05hTiIsImlkZW50Q2hhcnMiLCJjb2RlXzQiLCJjb2RlXzUiLCJjb25zdW1lVXJsIiwidXJsQ2hhcnMiLCJoYXNGaW5pc2hlZFdvcmQiLCJvZmZzZXQiLCJyZXN1bHRfMSIsImxhc3RVcmxJbmRleCIsInZhbHVlXzEiLCJzaW1wbGlmeUFTVCIsImFzdCIsInNpbXBsaWZ5TWVkaWFRdWVyeSIsIm1lZGlhUXVlcnkiLCJtZWRpYUNvbmRpdGlvbiIsInNpbXBsaWZ5TWVkaWFDb25kaXRpb24iLCJvcGVyYXRvciIsImNoaWxkcmVuIiwibWVkaWFQcmVmaXgiLCJtZWRpYVR5cGUiLCJ1bnNpbXBsaWZpZWRDaGlsZCIsImNoaWxkIiwic3BsaWNlQXJncyIsImlfMSIsInNwbGljZSIsImNyZWF0ZUVycm9yIiwibWVzc2FnZSIsImVyciIsIkVycm9yIiwiY29uY2F0IiwidHJpbSIsInRvQVNUIiwidG9VbmZsYXR0ZW5lZEFTVCIsInRva2VuTGlzdCIsInN0YXJ0SW5kZXgiLCJlbmRJbmRleCIsInRva2VuIiwic3ludGFjdGljQW5hbHlzaXMiLCJyZW1vdmVXaGl0ZXNwYWNlIiwibmV3VG9rZW5MaXN0IiwiYmVmb3JlIiwid3NBZnRlciIsIndzQmVmb3JlIiwiZV8xIiwibWVkaWFRdWVyeUxpc3QiLCJtZWRpYVF1ZXJpZXMiLCJtYXAiLCJtZWRpYVF1ZXJ5VG9rZW5zIiwidG9rZW5pemVNZWRpYVF1ZXJ5Iiwibm9uTnVsbE1lZGlhUXVlcnlUb2tlbnMiLCJtZWRpYVF1ZXJ5VG9rZW5zXzEiLCJtZWRpYVF1ZXJ5VG9rZW5zXzFfMSIsIm1lZGlhUXVlcnlUb2tlbiIsImVfMV8xIiwiZmlyc3RUb2tlbiIsInRva2VuaXplTWVkaWFDb25kaXRpb24iLCJmaXJzdEluZGV4IiwiZmlyc3ROb25VbmFyeVRva2VuIiwidG9rZW5zV2l0aFBhcmVucyIsInNlY29uZE5vblVuYXJ5VG9rZW4iLCJtYXlDb250YWluT3IiLCJwcmV2aW91c09wZXJhdG9yIiwiZW5kSW5kZXhPZkZpcnN0RmVhdHVyZSIsIm1heERlcHRoIiwiY291bnQiLCJtYXgiLCJmZWF0dXJlVG9rZW5zIiwidG9rZW5pemVNZWRpYUZlYXR1cmUiLCJuZXh0VG9rZW4iLCJzaWJsaW5ncyIsInJhd1Rva2VucyIsImEiLCJiIiwiYyIsIm51bWVyYXRvciIsImRlbm9taW5hdG9yIiwiY29udGV4dCIsImZlYXR1cmUiLCJ2YWx1ZVRva2VuIiwicHJlZml4IiwicmFuZ2UiLCJ0b2tlbml6ZVJhbmdlIiwiZmVhdHVyZU5hbWUiLCJsZWZ0VG9rZW4iLCJsZWZ0T3AiLCJyaWdodE9wIiwicmlnaHRUb2tlbiIsImhhc0xlZnQiLCJ0b2tlbkluZGV4QWZ0ZXJGaXJzdE9wIiwidG9rZW5BZnRlckZpcnN0T3AiLCJzZWNvbmRPcFRva2VuIiwiZm9sbG93aW5nVG9rZW4iLCJ0b2tlbkFmdGVyU2Vjb25kT3AiLCJ2YWxpZFJhbmdlIiwibHQiLCJydCIsImx0Tm9XUyIsInJ0Tm9XUyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/media-query-parser/dist/media-query-parser.esm.js\n");

/***/ })

};
;