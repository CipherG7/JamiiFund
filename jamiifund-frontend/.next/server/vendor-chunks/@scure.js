"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@scure";
exports.ids = ["vendor-chunks/@scure"];
exports.modules = {

/***/ "(ssr)/./node_modules/@scure/base/lib/esm/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@scure/base/lib/esm/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base16: () => (/* binding */ base16),\n/* harmony export */   base32: () => (/* binding */ base32),\n/* harmony export */   base32crockford: () => (/* binding */ base32crockford),\n/* harmony export */   base32hex: () => (/* binding */ base32hex),\n/* harmony export */   base32hexnopad: () => (/* binding */ base32hexnopad),\n/* harmony export */   base32nopad: () => (/* binding */ base32nopad),\n/* harmony export */   base58: () => (/* binding */ base58),\n/* harmony export */   base58check: () => (/* binding */ base58check),\n/* harmony export */   base58flickr: () => (/* binding */ base58flickr),\n/* harmony export */   base58xmr: () => (/* binding */ base58xmr),\n/* harmony export */   base58xrp: () => (/* binding */ base58xrp),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64nopad: () => (/* binding */ base64nopad),\n/* harmony export */   base64url: () => (/* binding */ base64url),\n/* harmony export */   base64urlnopad: () => (/* binding */ base64urlnopad),\n/* harmony export */   bech32: () => (/* binding */ bech32),\n/* harmony export */   bech32m: () => (/* binding */ bech32m),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   bytesToString: () => (/* binding */ bytesToString),\n/* harmony export */   createBase58check: () => (/* binding */ createBase58check),\n/* harmony export */   hex: () => (/* binding */ hex),\n/* harmony export */   str: () => (/* binding */ str),\n/* harmony export */   stringToBytes: () => (/* binding */ stringToBytes),\n/* harmony export */   utf8: () => (/* binding */ utf8),\n/* harmony export */   utils: () => (/* binding */ utils)\n/* harmony export */ });\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function isBytes(a) {\n    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === \"Uint8Array\";\n}\n/** Asserts something is Uint8Array. */ function abytes(b, ...lengths) {\n    if (!isBytes(b)) throw new Error(\"Uint8Array expected\");\n    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(\"Uint8Array expected of length \" + lengths + \", got length=\" + b.length);\n}\nfunction isArrayOf(isString, arr) {\n    if (!Array.isArray(arr)) return false;\n    if (arr.length === 0) return true;\n    if (isString) {\n        return arr.every((item)=>typeof item === \"string\");\n    } else {\n        return arr.every((item)=>Number.isSafeInteger(item));\n    }\n}\n// no abytes: seems to have 10% slowdown. Why?!\nfunction afn(input) {\n    if (typeof input !== \"function\") throw new Error(\"function expected\");\n    return true;\n}\nfunction astr(label, input) {\n    if (typeof input !== \"string\") throw new Error(`${label}: string expected`);\n    return true;\n}\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n)) throw new Error(`invalid integer: ${n}`);\n}\nfunction aArr(input) {\n    if (!Array.isArray(input)) throw new Error(\"array expected\");\n}\nfunction astrArr(label, input) {\n    if (!isArrayOf(true, input)) throw new Error(`${label}: array of strings expected`);\n}\nfunction anumArr(label, input) {\n    if (!isArrayOf(false, input)) throw new Error(`${label}: array of numbers expected`);\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function chain(...args) {\n    const id = (a)=>a;\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b)=>(c)=>a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = args.map((x)=>x.encode).reduceRight(wrap, id);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.map((x)=>x.decode).reduce(wrap, id);\n    return {\n        encode,\n        decode\n    };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back.\n * Could also be array of strings.\n * @__NO_SIDE_EFFECTS__\n */ function alphabet(letters) {\n    // mapping 1 to \"b\"\n    const lettersA = typeof letters === \"string\" ? letters.split(\"\") : letters;\n    const len = lettersA.length;\n    astrArr(\"alphabet\", lettersA);\n    // mapping \"b\" to 1\n    const indexes = new Map(lettersA.map((l, i)=>[\n            l,\n            i\n        ]));\n    return {\n        encode: (digits)=>{\n            aArr(digits);\n            return digits.map((i)=>{\n                if (!Number.isSafeInteger(i) || i < 0 || i >= len) throw new Error(`alphabet.encode: digit index outside alphabet \"${i}\". Allowed: ${letters}`);\n                return lettersA[i];\n            });\n        },\n        decode: (input)=>{\n            aArr(input);\n            return input.map((letter)=>{\n                astr(\"alphabet.decode\", letter);\n                const i = indexes.get(letter);\n                if (i === undefined) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${letters}`);\n                return i;\n            });\n        }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function join(separator = \"\") {\n    astr(\"join\", separator);\n    return {\n        encode: (from)=>{\n            astrArr(\"join.decode\", from);\n            return from.join(separator);\n        },\n        decode: (to)=>{\n            astr(\"join.decode\", to);\n            return to.split(separator);\n        }\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */ function padding(bits, chr = \"=\") {\n    anumber(bits);\n    astr(\"padding\", chr);\n    return {\n        encode (data) {\n            astrArr(\"padding.encode\", data);\n            while(data.length * bits % 8)data.push(chr);\n            return data;\n        },\n        decode (input) {\n            astrArr(\"padding.decode\", input);\n            let end = input.length;\n            if (end * bits % 8) throw new Error(\"padding: invalid, string should have whole number of bytes\");\n            for(; end > 0 && input[end - 1] === chr; end--){\n                const last = end - 1;\n                const byte = last * bits;\n                if (byte % 8 === 0) throw new Error(\"padding: invalid, string has too much padding\");\n            }\n            return input.slice(0, end);\n        }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function normalize(fn) {\n    afn(fn);\n    return {\n        encode: (from)=>from,\n        decode: (to)=>fn(to)\n    };\n}\n/**\n * Slow: O(n^2) time complexity\n */ function convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2) throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);\n    if (to < 2) throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);\n    aArr(data);\n    if (!data.length) return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data, (d)=>{\n        anumber(d);\n        if (d < 0 || d >= from) throw new Error(`invalid integer: ${d}`);\n        return d;\n    });\n    const dlen = digits.length;\n    while(true){\n        let carry = 0;\n        let done = true;\n        for(let i = pos; i < dlen; i++){\n            const digit = digits[i];\n            const fromCarry = from * carry;\n            const digitBase = fromCarry + digit;\n            if (!Number.isSafeInteger(digitBase) || fromCarry / from !== carry || digitBase - digit !== fromCarry) {\n                throw new Error(\"convertRadix: carry overflow\");\n            }\n            const div = digitBase / to;\n            carry = digitBase % to;\n            const rounded = Math.floor(div);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase) throw new Error(\"convertRadix: carry overflow\");\n            if (!done) continue;\n            else if (!rounded) pos = i;\n            else done = false;\n        }\n        res.push(carry);\n        if (done) break;\n    }\n    for(let i = 0; i < data.length - 1 && data[i] === 0; i++)res.push(0);\n    return res.reverse();\n}\nconst gcd = (a, b)=>b === 0 ? a : gcd(b, a % b);\nconst radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to)=>from + (to - gcd(from, to));\nconst powers = /* @__PURE__ */ (()=>{\n    let res = [];\n    for(let i = 0; i < 40; i++)res.push(2 ** i);\n    return res;\n})();\n/**\n * Implemented with numbers, because BigInt is 5x slower\n */ function convertRadix2(data, from, to, padding) {\n    aArr(data);\n    if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const max = powers[from];\n    const mask = powers[to] - 1;\n    const res = [];\n    for (const n of data){\n        anumber(n);\n        if (n >= max) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = carry << from | n;\n        if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for(; pos >= to; pos -= to)res.push((carry >> pos - to & mask) >>> 0);\n        const pow = powers[pos];\n        if (pow === undefined) throw new Error(\"invalid carry\");\n        carry &= pow - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = carry << to - pos & mask;\n    if (!padding && pos >= from) throw new Error(\"Excess padding\");\n    if (!padding && carry > 0) throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0) res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function radix(num) {\n    anumber(num);\n    const _256 = 2 ** 8;\n    return {\n        encode: (bytes)=>{\n            if (!isBytes(bytes)) throw new Error(\"radix.encode input should be Uint8Array\");\n            return convertRadix(Array.from(bytes), _256, num);\n        },\n        decode: (digits)=>{\n            anumArr(\"radix.decode\", digits);\n            return Uint8Array.from(convertRadix(digits, num, _256));\n        }\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */ function radix2(bits, revPadding = false) {\n    anumber(bits);\n    if (bits <= 0 || bits > 32) throw new Error(\"radix2: bits should be in (0..32]\");\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32) throw new Error(\"radix2: carry overflow\");\n    return {\n        encode: (bytes)=>{\n            if (!isBytes(bytes)) throw new Error(\"radix2.encode input should be Uint8Array\");\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits)=>{\n            anumArr(\"radix2.decode\", digits);\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        }\n    };\n}\nfunction unsafeWrapper(fn) {\n    afn(fn);\n    return function(...args) {\n        try {\n            return fn.apply(null, args);\n        } catch (e) {}\n    };\n}\nfunction checksum(len, fn) {\n    anumber(len);\n    afn(fn);\n    return {\n        encode (data) {\n            if (!isBytes(data)) throw new Error(\"checksum.encode: input should be Uint8Array\");\n            const sum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(sum, data.length);\n            return res;\n        },\n        decode (data) {\n            if (!isBytes(data)) throw new Error(\"checksum.decode: input should be Uint8Array\");\n            const payload = data.slice(0, -len);\n            const oldChecksum = data.slice(-len);\n            const newChecksum = fn(payload).slice(0, len);\n            for(let i = 0; i < len; i++)if (newChecksum[i] !== oldChecksum[i]) throw new Error(\"Invalid checksum\");\n            return payload;\n        }\n    };\n}\n// prettier-ignore\nconst utils = {\n    alphabet,\n    chain,\n    checksum,\n    convertRadix,\n    convertRadix2,\n    radix,\n    radix2,\n    join,\n    padding\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\n/**\n * base16 encoding from RFC 4648.\n * @example\n * ```js\n * base16.encode(Uint8Array.from([0x12, 0xab]));\n * // => '12AB'\n * ```\n */ const base16 = chain(radix2(4), alphabet(\"0123456789ABCDEF\"), join(\"\"));\n/**\n * base32 encoding from RFC 4648. Has padding.\n * Use `base32nopad` for unpadded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ===='\n * base32.decode('CKVQ====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */ const base32 = chain(radix2(5), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"), padding(5), join(\"\"));\n/**\n * base32 encoding from RFC 4648. No padding.\n * Use `base32` for padded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ'\n * base32nopad.decode('CKVQ');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */ const base32nopad = chain(radix2(5), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"), join(\"\"));\n/**\n * base32 encoding from RFC 4648. Padded. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hexnopad` for unpadded version.\n * @example\n * ```js\n * base32hex.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG===='\n * base32hex.decode('2ALG====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */ const base32hex = chain(radix2(5), alphabet(\"0123456789ABCDEFGHIJKLMNOPQRSTUV\"), padding(5), join(\"\"));\n/**\n * base32 encoding from RFC 4648. No padding. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hex` for padded version.\n * @example\n * ```js\n * base32hexnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG'\n * base32hexnopad.decode('2ALG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */ const base32hexnopad = chain(radix2(5), alphabet(\"0123456789ABCDEFGHIJKLMNOPQRSTUV\"), join(\"\"));\n/**\n * base32 encoding from RFC 4648. Doug Crockford's version.\n * https://www.crockford.com/base32.html\n * @example\n * ```js\n * base32crockford.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ANG'\n * base32crockford.decode('2ANG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */ const base32crockford = chain(radix2(5), alphabet(\"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"), join(\"\"), normalize((s)=>s.toUpperCase().replace(/O/g, \"0\").replace(/[IL]/g, \"1\")));\n// Built-in base64 conversion https://caniuse.com/mdn-javascript_builtins_uint8array_frombase64\n// TODO: temporarily set to false, trying to understand bugs\n// prettier-ignore\nconst hasBase64Builtin = /* @__PURE__ */ (()=>typeof Uint8Array.from([]).toBase64 === \"function\" && typeof Uint8Array.fromBase64 === \"function\")();\n/**\n * base64 from RFC 4648. Padded.\n * Use `base64nopad` for unpadded version.\n * Also check out `base64url`, `base64urlnopad`.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */ // prettier-ignore\nconst base64 = hasBase64Builtin ? {\n    encode (b) {\n        abytes(b);\n        return b.toBase64();\n    },\n    decode (s) {\n        astr(\"base64\", s);\n        return Uint8Array.fromBase64(s, {\n            lastChunkHandling: \"strict\"\n        });\n    }\n} : chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"), padding(6), join(\"\"));\n/**\n * base64 from RFC 4648. No padding.\n * Use `base64` for padded version.\n * @example\n * ```js\n * base64nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64nopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */ const base64nopad = chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"), join(\"\"));\n/**\n * base64 from RFC 4648, using URL-safe alphabet. Padded.\n * Use `base64urlnopad` for unpadded version.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64url.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64url.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */ // prettier-ignore\nconst base64url = hasBase64Builtin ? {\n    encode (b) {\n        abytes(b);\n        return b.toBase64({\n            alphabet: \"base64url\"\n        });\n    },\n    decode (s) {\n        astr(\"base64\", s);\n        return Uint8Array.fromBase64(s, {\n            alphabet: \"base64url\"\n        });\n    }\n} : chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"), padding(6), join(\"\"));\n/**\n * base64 from RFC 4648, using URL-safe alphabet. No padding.\n * Use `base64url` for padded version.\n * @example\n * ```js\n * base64urlnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64urlnopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */ const base64urlnopad = chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"), join(\"\"));\n// base58 code\n// -----------\nconst genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc)=>chain(radix(58), alphabet(abc), join(\"\"));\n/**\n * base58: base64 without ambigous characters +, /, 0, O, I, l.\n * Quadratic (O(n^2)) - so, can't be used on large inputs.\n * @example\n * ```js\n * base58.decode('01abcdef');\n * // => '3UhJW'\n * ```\n */ const base58 = genBase58(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\n/**\n * base58: flickr version. Check out `base58`.\n */ const base58flickr = genBase58(\"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\");\n/**\n * base58: XRP version. Check out `base58`.\n */ const base58xrp = genBase58(\"rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz\");\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [\n    0,\n    2,\n    3,\n    5,\n    6,\n    7,\n    9,\n    10,\n    11\n];\n/**\n * base58: XMR version. Check out `base58`.\n * Done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n * Block encoding significantly reduces quadratic complexity of base58.\n */ const base58xmr = {\n    encode (data) {\n        let res = \"\";\n        for(let i = 0; i < data.length; i += 8){\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], \"1\");\n        }\n        return res;\n    },\n    decode (str) {\n        let res = [];\n        for(let i = 0; i < str.length; i += 11){\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for(let j = 0; j < block.length - blockLen; j++){\n                if (block[j] !== 0) throw new Error(\"base58xmr: wrong padding\");\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    }\n};\n/**\n * Method, which creates base58check encoder.\n * Requires function, calculating sha256.\n */ const createBase58check = (sha256)=>chain(checksum(4, (data)=>sha256(sha256(data))), base58);\n/**\n * Use `createBase58check` instead.\n * @deprecated\n */ const base58check = createBase58check;\nconst BECH_ALPHABET = chain(alphabet(\"qpzry9x8gf2tvdw0s3jn54khce6mua7l\"), join(\"\"));\nconst POLYMOD_GENERATORS = [\n    0x3b6a57b2,\n    0x26508e6d,\n    0x1ea119fa,\n    0x3d4233dd,\n    0x2a1462b3\n];\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for(let i = 0; i < POLYMOD_GENERATORS.length; i++){\n        if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for(let i = 0; i < len; i++){\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ c >> 5;\n    }\n    chk = bech32Polymod(chk);\n    for(let i = 0; i < len; i++)chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 0x1f;\n    for (let v of words)chk = bech32Polymod(chk) ^ v;\n    for(let i = 0; i < 6; i++)chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([\n        chk % powers[30]\n    ], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function genBech32(encoding) {\n    const ENCODING_CONST = encoding === \"bech32\" ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        astr(\"bech32.encode prefix\", prefix);\n        if (isBytes(words)) words = Array.from(words);\n        anumArr(\"bech32.encode\", words);\n        const plen = prefix.length;\n        if (plen === 0) throw new TypeError(`Invalid prefix length ${plen}`);\n        const actualLength = plen + 7 + words.length;\n        if (limit !== false && actualLength > limit) throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        astr(\"bech32.decode input\", str);\n        const slen = str.length;\n        if (slen < 8 || limit !== false && slen > limit) throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase()) throw new Error(`String must be lowercase or uppercase`);\n        const sepIndex = lowered.lastIndexOf(\"1\");\n        if (sepIndex === 0 || sepIndex === -1) throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = lowered.slice(0, sepIndex);\n        const data = lowered.slice(sepIndex + 1);\n        if (data.length < 6) throw new Error(\"Data must be at least 6 characters long\");\n        const words = BECH_ALPHABET.decode(data).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!data.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return {\n            prefix,\n            words\n        };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return {\n            prefix,\n            words,\n            bytes: fromWords(words)\n        };\n    }\n    function encodeFromBytes(prefix, bytes) {\n        return encode(prefix, toWords(bytes));\n    }\n    return {\n        encode,\n        decode,\n        encodeFromBytes,\n        decodeToBytes,\n        decodeUnsafe,\n        fromWords,\n        fromWordsUnsafe,\n        toWords\n    };\n}\n/**\n * bech32 from BIP 173. Operates on words.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */ const bech32 = genBech32(\"bech32\");\n/**\n * bech32m from BIP 350. Operates on words.\n * It was to mitigate `bech32` weaknesses.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */ const bech32m = genBech32(\"bech32m\");\n/**\n * UTF-8-to-byte decoder. Uses built-in TextDecoder / TextEncoder.\n * @example\n * ```js\n * const b = utf8.decode(\"hey\"); // => new Uint8Array([ 104, 101, 121 ])\n * const str = utf8.encode(b); // \"hey\"\n * ```\n */ const utf8 = {\n    encode: (data)=>new TextDecoder().decode(data),\n    decode: (str)=>new TextEncoder().encode(str)\n};\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\n// prettier-ignore\nconst hasHexBuiltin = /* @__PURE__ */ (()=>typeof Uint8Array.from([]).toHex === \"function\" && typeof Uint8Array.fromHex === \"function\")();\n// prettier-ignore\nconst hexBuiltin = {\n    encode (data) {\n        abytes(data);\n        return data.toHex();\n    },\n    decode (s) {\n        astr(\"hex\", s);\n        return Uint8Array.fromHex(s);\n    }\n};\n/**\n * hex string decoder. Uses built-in function, when available.\n * @example\n * ```js\n * const b = hex.decode(\"0102ff\"); // => new Uint8Array([ 1, 2, 255 ])\n * const str = hex.encode(b); // \"0102ff\"\n * ```\n */ const hex = hasHexBuiltin ? hexBuiltin : chain(radix2(4), alphabet(\"0123456789abcdef\"), join(\"\"), normalize((s)=>{\n    if (typeof s !== \"string\" || s.length % 2 !== 0) throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n    utf8,\n    hex,\n    base16,\n    base32,\n    base64,\n    base64url,\n    base58,\n    base58xmr\n};\nconst coderTypeError = \"Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr\";\n/** @deprecated */ const bytesToString = (type, bytes)=>{\n    if (typeof type !== \"string\" || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n    if (!isBytes(bytes)) throw new TypeError(\"bytesToString() expects Uint8Array\");\n    return CODERS[type].encode(bytes);\n};\n/** @deprecated */ const str = bytesToString; // as in python, but for bytes only\n/** @deprecated */ const stringToBytes = (type, str)=>{\n    if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n    if (typeof str !== \"string\") throw new TypeError(\"stringToBytes() expects string\");\n    return CODERS[type].decode(str);\n};\n/** @deprecated */ const bytes = stringToBytes; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2Jhc2UvbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsa0VBQWtFLEdBQ2xFLFNBQVNBLFFBQVFDLENBQUM7SUFDZCxPQUFPQSxhQUFhQyxjQUFlQyxZQUFZQyxNQUFNLENBQUNILE1BQU1BLEVBQUVJLFdBQVcsQ0FBQ0MsSUFBSSxLQUFLO0FBQ3ZGO0FBQ0EscUNBQXFDLEdBQ3JDLFNBQVNDLE9BQU9DLENBQUMsRUFBRSxHQUFHQyxPQUFPO0lBQ3pCLElBQUksQ0FBQ1QsUUFBUVEsSUFDVCxNQUFNLElBQUlFLE1BQU07SUFDcEIsSUFBSUQsUUFBUUUsTUFBTSxHQUFHLEtBQUssQ0FBQ0YsUUFBUUcsUUFBUSxDQUFDSixFQUFFRyxNQUFNLEdBQ2hELE1BQU0sSUFBSUQsTUFBTSxtQ0FBbUNELFVBQVUsa0JBQWtCRCxFQUFFRyxNQUFNO0FBQy9GO0FBQ0EsU0FBU0UsVUFBVUMsUUFBUSxFQUFFQyxHQUFHO0lBQzVCLElBQUksQ0FBQ0MsTUFBTUMsT0FBTyxDQUFDRixNQUNmLE9BQU87SUFDWCxJQUFJQSxJQUFJSixNQUFNLEtBQUssR0FDZixPQUFPO0lBQ1gsSUFBSUcsVUFBVTtRQUNWLE9BQU9DLElBQUlHLEtBQUssQ0FBQyxDQUFDQyxPQUFTLE9BQU9BLFNBQVM7SUFDL0MsT0FDSztRQUNELE9BQU9KLElBQUlHLEtBQUssQ0FBQyxDQUFDQyxPQUFTQyxPQUFPQyxhQUFhLENBQUNGO0lBQ3BEO0FBQ0o7QUFDQSwrQ0FBK0M7QUFDL0MsU0FBU0csSUFBSUMsS0FBSztJQUNkLElBQUksT0FBT0EsVUFBVSxZQUNqQixNQUFNLElBQUliLE1BQU07SUFDcEIsT0FBTztBQUNYO0FBQ0EsU0FBU2MsS0FBS0MsS0FBSyxFQUFFRixLQUFLO0lBQ3RCLElBQUksT0FBT0EsVUFBVSxVQUNqQixNQUFNLElBQUliLE1BQU0sQ0FBQyxFQUFFZSxNQUFNLGlCQUFpQixD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LE9BQ25ELE1BQU0sSUFBSXhCLFVBQVVzQjtJQUN4QixJQUFJLENBQUN6TCxRQUFRK0YsUUFDVCxNQUFNLElBQUlvRSxVQUFVO0lBQ3hCLE9BQU9xQixNQUFNLENBQUNHLEtBQUssQ0FBQ3ZKLE1BQU0sQ0FBQzJEO0FBQy9CLEVBQUU7QUFDRixnQkFBZ0IsR0FDVCxNQUFNd0MsTUFBTW1ELGNBQWMsQ0FBQyxtQ0FBbUM7QUFDckUsZ0JBQWdCLEdBQ1QsTUFBTUcsZ0JBQWdCLENBQUNGLE1BQU1wRDtJQUNoQyxJQUFJLENBQUNpRCxPQUFPSSxjQUFjLENBQUNELE9BQ3ZCLE1BQU0sSUFBSXhCLFVBQVVzQjtJQUN4QixJQUFJLE9BQU9sRCxRQUFRLFVBQ2YsTUFBTSxJQUFJNEIsVUFBVTtJQUN4QixPQUFPcUIsTUFBTSxDQUFDRyxLQUFLLENBQUNuSixNQUFNLENBQUMrRjtBQUMvQixFQUFFO0FBQ0YsZ0JBQWdCLEdBQ1QsTUFBTXhDLFFBQVE4RixjQUFjLENBQ25DLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2phbWlpZnVuZC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmFzZS9saWIvZXNtL2luZGV4LmpzP2U3OTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIHNjdXJlLWJhc2UgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiBhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCAoQXJyYXlCdWZmZXIuaXNWaWV3KGEpICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKTtcbn1cbi8qKiBBc3NlcnRzIHNvbWV0aGluZyBpcyBVaW50OEFycmF5LiAqL1xuZnVuY3Rpb24gYWJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIWlzQnl0ZXMoYikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQgb2YgbGVuZ3RoICcgKyBsZW5ndGhzICsgJywgZ290IGxlbmd0aD0nICsgYi5sZW5ndGgpO1xufVxuZnVuY3Rpb24gaXNBcnJheU9mKGlzU3RyaW5nLCBhcnIpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChhcnIubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGFyci5ldmVyeSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBhcnIuZXZlcnkoKGl0ZW0pID0+IE51bWJlci5pc1NhZmVJbnRlZ2VyKGl0ZW0pKTtcbiAgICB9XG59XG4vLyBubyBhYnl0ZXM6IHNlZW1zIHRvIGhhdmUgMTAlIHNsb3dkb3duLiBXaHk/IVxuZnVuY3Rpb24gYWZuKGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmdW5jdGlvbiBleHBlY3RlZCcpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYXN0cihsYWJlbCwgaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2xhYmVsfTogc3RyaW5nIGV4cGVjdGVkYCk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBhbnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW50ZWdlcjogJHtufWApO1xufVxuZnVuY3Rpb24gYUFycihpbnB1dCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXJyYXkgZXhwZWN0ZWQnKTtcbn1cbmZ1bmN0aW9uIGFzdHJBcnIobGFiZWwsIGlucHV0KSB7XG4gICAgaWYgKCFpc0FycmF5T2YodHJ1ZSwgaW5wdXQpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bGFiZWx9OiBhcnJheSBvZiBzdHJpbmdzIGV4cGVjdGVkYCk7XG59XG5mdW5jdGlvbiBhbnVtQXJyKGxhYmVsLCBpbnB1dCkge1xuICAgIGlmICghaXNBcnJheU9mKGZhbHNlLCBpbnB1dCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtsYWJlbH06IGFycmF5IG9mIG51bWJlcnMgZXhwZWN0ZWRgKTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gY2hhaW4oLi4uYXJncykge1xuICAgIGNvbnN0IGlkID0gKGEpID0+IGE7XG4gICAgLy8gV3JhcCBjYWxsIGluIGNsb3N1cmUgc28gSklUIGNhbiBpbmxpbmUgY2FsbHNcbiAgICBjb25zdCB3cmFwID0gKGEsIGIpID0+IChjKSA9PiBhKGIoYykpO1xuICAgIC8vIENvbnN0cnVjdCBjaGFpbiBvZiBhcmdzWy0xXS5lbmNvZGUoYXJnc1stMl0uZW5jb2RlKFsuLi5dKSlcbiAgICBjb25zdCBlbmNvZGUgPSBhcmdzLm1hcCgoeCkgPT4geC5lbmNvZGUpLnJlZHVjZVJpZ2h0KHdyYXAsIGlkKTtcbiAgICAvLyBDb25zdHJ1Y3QgY2hhaW4gb2YgYXJnc1swXS5kZWNvZGUoYXJnc1sxXS5kZWNvZGUoLi4uKSlcbiAgICBjb25zdCBkZWNvZGUgPSBhcmdzLm1hcCgoeCkgPT4geC5kZWNvZGUpLnJlZHVjZSh3cmFwLCBpZCk7XG4gICAgcmV0dXJuIHsgZW5jb2RlLCBkZWNvZGUgfTtcbn1cbi8qKlxuICogRW5jb2RlcyBpbnRlZ2VyIHJhZGl4IHJlcHJlc2VudGF0aW9uIHRvIGFycmF5IG9mIHN0cmluZ3MgdXNpbmcgYWxwaGFiZXQgYW5kIGJhY2suXG4gKiBDb3VsZCBhbHNvIGJlIGFycmF5IG9mIHN0cmluZ3MuXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBhbHBoYWJldChsZXR0ZXJzKSB7XG4gICAgLy8gbWFwcGluZyAxIHRvIFwiYlwiXG4gICAgY29uc3QgbGV0dGVyc0EgPSB0eXBlb2YgbGV0dGVycyA9PT0gJ3N0cmluZycgPyBsZXR0ZXJzLnNwbGl0KCcnKSA6IGxldHRlcnM7XG4gICAgY29uc3QgbGVuID0gbGV0dGVyc0EubGVuZ3RoO1xuICAgIGFzdHJBcnIoJ2FscGhhYmV0JywgbGV0dGVyc0EpO1xuICAgIC8vIG1hcHBpbmcgXCJiXCIgdG8gMVxuICAgIGNvbnN0IGluZGV4ZXMgPSBuZXcgTWFwKGxldHRlcnNBLm1hcCgobCwgaSkgPT4gW2wsIGldKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBhQXJyKGRpZ2l0cyk7XG4gICAgICAgICAgICByZXR1cm4gZGlnaXRzLm1hcCgoaSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoaSkgfHwgaSA8IDAgfHwgaSA+PSBsZW4pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYWxwaGFiZXQuZW5jb2RlOiBkaWdpdCBpbmRleCBvdXRzaWRlIGFscGhhYmV0IFwiJHtpfVwiLiBBbGxvd2VkOiAke2xldHRlcnN9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxldHRlcnNBW2ldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBhQXJyKGlucHV0KTtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5tYXAoKGxldHRlcikgPT4ge1xuICAgICAgICAgICAgICAgIGFzdHIoJ2FscGhhYmV0LmRlY29kZScsIGxldHRlcik7XG4gICAgICAgICAgICAgICAgY29uc3QgaSA9IGluZGV4ZXMuZ2V0KGxldHRlcik7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGxldHRlcjogXCIke2xldHRlcn1cIi4gQWxsb3dlZDogJHtsZXR0ZXJzfWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gam9pbihzZXBhcmF0b3IgPSAnJykge1xuICAgIGFzdHIoJ2pvaW4nLCBzZXBhcmF0b3IpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGZyb20pID0+IHtcbiAgICAgICAgICAgIGFzdHJBcnIoJ2pvaW4uZGVjb2RlJywgZnJvbSk7XG4gICAgICAgICAgICByZXR1cm4gZnJvbS5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKHRvKSA9PiB7XG4gICAgICAgICAgICBhc3RyKCdqb2luLmRlY29kZScsIHRvKTtcbiAgICAgICAgICAgIHJldHVybiB0by5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIFBhZCBzdHJpbmdzIGFycmF5IHNvIGl0IGhhcyBpbnRlZ2VyIG51bWJlciBvZiBiaXRzXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBwYWRkaW5nKGJpdHMsIGNociA9ICc9Jykge1xuICAgIGFudW1iZXIoYml0cyk7XG4gICAgYXN0cigncGFkZGluZycsIGNocik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGFzdHJBcnIoJ3BhZGRpbmcuZW5jb2RlJywgZGF0YSk7XG4gICAgICAgICAgICB3aGlsZSAoKGRhdGEubGVuZ3RoICogYml0cykgJSA4KVxuICAgICAgICAgICAgICAgIGRhdGEucHVzaChjaHIpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShpbnB1dCkge1xuICAgICAgICAgICAgYXN0ckFycigncGFkZGluZy5kZWNvZGUnLCBpbnB1dCk7XG4gICAgICAgICAgICBsZXQgZW5kID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKChlbmQgKiBiaXRzKSAlIDgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nOiBpbnZhbGlkLCBzdHJpbmcgc2hvdWxkIGhhdmUgd2hvbGUgbnVtYmVyIG9mIGJ5dGVzJyk7XG4gICAgICAgICAgICBmb3IgKDsgZW5kID4gMCAmJiBpbnB1dFtlbmQgLSAxXSA9PT0gY2hyOyBlbmQtLSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSBlbmQgLSAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGUgPSBsYXN0ICogYml0cztcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZSAlIDggPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZzogaW52YWxpZCwgc3RyaW5nIGhhcyB0b28gbXVjaCBwYWRkaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQuc2xpY2UoMCwgZW5kKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBub3JtYWxpemUoZm4pIHtcbiAgICBhZm4oZm4pO1xuICAgIHJldHVybiB7IGVuY29kZTogKGZyb20pID0+IGZyb20sIGRlY29kZTogKHRvKSA9PiBmbih0bykgfTtcbn1cbi8qKlxuICogU2xvdzogTyhuXjIpIHRpbWUgY29tcGxleGl0eVxuICovXG5mdW5jdGlvbiBjb252ZXJ0UmFkaXgoZGF0YSwgZnJvbSwgdG8pIHtcbiAgICAvLyBiYXNlIDEgaXMgaW1wb3NzaWJsZVxuICAgIGlmIChmcm9tIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXg6IGludmFsaWQgZnJvbT0ke2Zyb219LCBiYXNlIGNhbm5vdCBiZSBsZXNzIHRoYW4gMmApO1xuICAgIGlmICh0byA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4OiBpbnZhbGlkIHRvPSR7dG99LCBiYXNlIGNhbm5vdCBiZSBsZXNzIHRoYW4gMmApO1xuICAgIGFBcnIoZGF0YSk7XG4gICAgaWYgKCFkYXRhLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGNvbnN0IGRpZ2l0cyA9IEFycmF5LmZyb20oZGF0YSwgKGQpID0+IHtcbiAgICAgICAgYW51bWJlcihkKTtcbiAgICAgICAgaWYgKGQgPCAwIHx8IGQgPj0gZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnRlZ2VyOiAke2R9YCk7XG4gICAgICAgIHJldHVybiBkO1xuICAgIH0pO1xuICAgIGNvbnN0IGRsZW4gPSBkaWdpdHMubGVuZ3RoO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCBjYXJyeSA9IDA7XG4gICAgICAgIGxldCBkb25lID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGRsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZGlnaXQgPSBkaWdpdHNbaV07XG4gICAgICAgICAgICBjb25zdCBmcm9tQ2FycnkgPSBmcm9tICogY2Fycnk7XG4gICAgICAgICAgICBjb25zdCBkaWdpdEJhc2UgPSBmcm9tQ2FycnkgKyBkaWdpdDtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoZGlnaXRCYXNlKSB8fFxuICAgICAgICAgICAgICAgIGZyb21DYXJyeSAvIGZyb20gIT09IGNhcnJ5IHx8XG4gICAgICAgICAgICAgICAgZGlnaXRCYXNlIC0gZGlnaXQgIT09IGZyb21DYXJyeSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBjYXJyeSBvdmVyZmxvdycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGl2ID0gZGlnaXRCYXNlIC8gdG87XG4gICAgICAgICAgICBjYXJyeSA9IGRpZ2l0QmFzZSAlIHRvO1xuICAgICAgICAgICAgY29uc3Qgcm91bmRlZCA9IE1hdGguZmxvb3IoZGl2KTtcbiAgICAgICAgICAgIGRpZ2l0c1tpXSA9IHJvdW5kZWQ7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHJvdW5kZWQpIHx8IHJvdW5kZWQgKiB0byArIGNhcnJ5ICE9PSBkaWdpdEJhc2UpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgICAgICAgICBpZiAoIWRvbmUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBlbHNlIGlmICghcm91bmRlZClcbiAgICAgICAgICAgICAgICBwb3MgPSBpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChjYXJyeSk7XG4gICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggLSAxICYmIGRhdGFbaV0gPT09IDA7IGkrKylcbiAgICAgICAgcmVzLnB1c2goMCk7XG4gICAgcmV0dXJuIHJlcy5yZXZlcnNlKCk7XG59XG5jb25zdCBnY2QgPSAoYSwgYikgPT4gKGIgPT09IDAgPyBhIDogZ2NkKGIsIGEgJSBiKSk7XG5jb25zdCByYWRpeDJjYXJyeSA9IC8qIEBfX05PX1NJREVfRUZGRUNUU19fICovIChmcm9tLCB0bykgPT4gZnJvbSArICh0byAtIGdjZChmcm9tLCB0bykpO1xuY29uc3QgcG93ZXJzID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gICAgbGV0IHJlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDA7IGkrKylcbiAgICAgICAgcmVzLnB1c2goMiAqKiBpKTtcbiAgICByZXR1cm4gcmVzO1xufSkoKTtcbi8qKlxuICogSW1wbGVtZW50ZWQgd2l0aCBudW1iZXJzLCBiZWNhdXNlIEJpZ0ludCBpcyA1eCBzbG93ZXJcbiAqL1xuZnVuY3Rpb24gY29udmVydFJhZGl4MihkYXRhLCBmcm9tLCB0bywgcGFkZGluZykge1xuICAgIGFBcnIoZGF0YSk7XG4gICAgaWYgKGZyb20gPD0gMCB8fCBmcm9tID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4Mjogd3JvbmcgZnJvbT0ke2Zyb219YCk7XG4gICAgaWYgKHRvIDw9IDAgfHwgdG8gPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiB3cm9uZyB0bz0ke3RvfWApO1xuICAgIGlmIChyYWRpeDJjYXJyeShmcm9tLCB0bykgPiAzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGNhcnJ5IG92ZXJmbG93IGZyb209JHtmcm9tfSB0bz0ke3RvfSBjYXJyeUJpdHM9JHtyYWRpeDJjYXJyeShmcm9tLCB0byl9YCk7XG4gICAgfVxuICAgIGxldCBjYXJyeSA9IDA7XG4gICAgbGV0IHBvcyA9IDA7IC8vIGJpdHdpc2UgcG9zaXRpb24gaW4gY3VycmVudCBlbGVtZW50XG4gICAgY29uc3QgbWF4ID0gcG93ZXJzW2Zyb21dO1xuICAgIGNvbnN0IG1hc2sgPSBwb3dlcnNbdG9dIC0gMTtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgZGF0YSkge1xuICAgICAgICBhbnVtYmVyKG4pO1xuICAgICAgICBpZiAobiA+PSBtYXgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGludmFsaWQgZGF0YSB3b3JkPSR7bn0gZnJvbT0ke2Zyb219YCk7XG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IDw8IGZyb20pIHwgbjtcbiAgICAgICAgaWYgKHBvcyArIGZyb20gPiAzMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogY2Fycnkgb3ZlcmZsb3cgcG9zPSR7cG9zfSBmcm9tPSR7ZnJvbX1gKTtcbiAgICAgICAgcG9zICs9IGZyb207XG4gICAgICAgIGZvciAoOyBwb3MgPj0gdG87IHBvcyAtPSB0bylcbiAgICAgICAgICAgIHJlcy5wdXNoKCgoY2FycnkgPj4gKHBvcyAtIHRvKSkgJiBtYXNrKSA+Pj4gMCk7XG4gICAgICAgIGNvbnN0IHBvdyA9IHBvd2Vyc1twb3NdO1xuICAgICAgICBpZiAocG93ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgY2FycnknKTtcbiAgICAgICAgY2FycnkgJj0gcG93IC0gMTsgLy8gY2xlYW4gY2FycnksIG90aGVyd2lzZSBpdCB3aWxsIGNhdXNlIG92ZXJmbG93XG4gICAgfVxuICAgIGNhcnJ5ID0gKGNhcnJ5IDw8ICh0byAtIHBvcykpICYgbWFzaztcbiAgICBpZiAoIXBhZGRpbmcgJiYgcG9zID49IGZyb20pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhjZXNzIHBhZGRpbmcnKTtcbiAgICBpZiAoIXBhZGRpbmcgJiYgY2FycnkgPiAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbi16ZXJvIHBhZGRpbmc6ICR7Y2Fycnl9YCk7XG4gICAgaWYgKHBhZGRpbmcgJiYgcG9zID4gMClcbiAgICAgICAgcmVzLnB1c2goY2FycnkgPj4+IDApO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIHJhZGl4KG51bSkge1xuICAgIGFudW1iZXIobnVtKTtcbiAgICBjb25zdCBfMjU2ID0gMiAqKiA4O1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzQnl0ZXMoYnl0ZXMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXguZW5jb2RlIGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFJhZGl4KEFycmF5LmZyb20oYnl0ZXMpLCBfMjU2LCBudW0pO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGFudW1BcnIoJ3JhZGl4LmRlY29kZScsIGRpZ2l0cyk7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGNvbnZlcnRSYWRpeChkaWdpdHMsIG51bSwgXzI1NikpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIElmIGJvdGggYmFzZXMgYXJlIHBvd2VyIG9mIHNhbWUgbnVtYmVyIChsaWtlIGAyKio4IDwtPiAyKio2NGApLFxuICogdGhlcmUgaXMgYSBsaW5lYXIgYWxnb3JpdGhtLiBGb3Igbm93IHdlIGhhdmUgaW1wbGVtZW50YXRpb24gZm9yIHBvd2VyLW9mLXR3byBiYXNlcyBvbmx5LlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gcmFkaXgyKGJpdHMsIHJldlBhZGRpbmcgPSBmYWxzZSkge1xuICAgIGFudW1iZXIoYml0cyk7XG4gICAgaWYgKGJpdHMgPD0gMCB8fCBiaXRzID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyOiBiaXRzIHNob3VsZCBiZSBpbiAoMC4uMzJdJyk7XG4gICAgaWYgKHJhZGl4MmNhcnJ5KDgsIGJpdHMpID4gMzIgfHwgcmFkaXgyY2FycnkoYml0cywgOCkgPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDI6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmICghaXNCeXRlcyhieXRlcykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDIuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFJhZGl4MihBcnJheS5mcm9tKGJ5dGVzKSwgOCwgYml0cywgIXJldlBhZGRpbmcpO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGFudW1BcnIoJ3JhZGl4Mi5kZWNvZGUnLCBkaWdpdHMpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjb252ZXJ0UmFkaXgyKGRpZ2l0cywgYml0cywgOCwgcmV2UGFkZGluZykpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiB1bnNhZmVXcmFwcGVyKGZuKSB7XG4gICAgYWZuKGZuKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNoZWNrc3VtKGxlbiwgZm4pIHtcbiAgICBhbnVtYmVyKGxlbik7XG4gICAgYWZuKGZuKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFpc0J5dGVzKGRhdGEpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0uZW5jb2RlOiBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgY29uc3Qgc3VtID0gZm4oZGF0YSkuc2xpY2UoMCwgbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoICsgbGVuKTtcbiAgICAgICAgICAgIHJlcy5zZXQoZGF0YSk7XG4gICAgICAgICAgICByZXMuc2V0KHN1bSwgZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghaXNCeXRlcyhkYXRhKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtLmRlY29kZTogaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBkYXRhLnNsaWNlKDAsIC1sZW4pO1xuICAgICAgICAgICAgY29uc3Qgb2xkQ2hlY2tzdW0gPSBkYXRhLnNsaWNlKC1sZW4pO1xuICAgICAgICAgICAgY29uc3QgbmV3Q2hlY2tzdW0gPSBmbihwYXlsb2FkKS5zbGljZSgwLCBsZW4pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICAgICAgICBpZiAobmV3Q2hlY2tzdW1baV0gIT09IG9sZENoZWNrc3VtW2ldKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2hlY2tzdW0nKTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCBjb25zdCB1dGlscyA9IHtcbiAgICBhbHBoYWJldCwgY2hhaW4sIGNoZWNrc3VtLCBjb252ZXJ0UmFkaXgsIGNvbnZlcnRSYWRpeDIsIHJhZGl4LCByYWRpeDIsIGpvaW4sIHBhZGRpbmcsXG59O1xuLy8gUkZDIDQ2NDggYWthIFJGQyAzNTQ4XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogYmFzZTE2IGVuY29kaW5nIGZyb20gUkZDIDQ2NDguXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGJhc2UxNi5lbmNvZGUoVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSkpO1xuICogLy8gPT4gJzEyQUInXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2UxNiA9IGNoYWluKHJhZGl4Mig0KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUYnKSwgam9pbignJykpO1xuLyoqXG4gKiBiYXNlMzIgZW5jb2RpbmcgZnJvbSBSRkMgNDY0OC4gSGFzIHBhZGRpbmcuXG4gKiBVc2UgYGJhc2UzMm5vcGFkYCBmb3IgdW5wYWRkZWQgdmVyc2lvbi5cbiAqIEFsc28gY2hlY2sgb3V0IGBiYXNlMzJoZXhgLCBgYmFzZTMyaGV4bm9wYWRgLCBgYmFzZTMyY3JvY2tmb3JkYC5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogYmFzZTMyLmVuY29kZShVaW50OEFycmF5LmZyb20oWzB4MTIsIDB4YWJdKSk7XG4gKiAvLyA9PiAnQ0tWUT09PT0nXG4gKiBiYXNlMzIuZGVjb2RlKCdDS1ZRPT09PScpO1xuICogLy8gPT4gVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSlcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgYmFzZTMyID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjcnKSwgcGFkZGluZyg1KSwgam9pbignJykpO1xuLyoqXG4gKiBiYXNlMzIgZW5jb2RpbmcgZnJvbSBSRkMgNDY0OC4gTm8gcGFkZGluZy5cbiAqIFVzZSBgYmFzZTMyYCBmb3IgcGFkZGVkIHZlcnNpb24uXG4gKiBBbHNvIGNoZWNrIG91dCBgYmFzZTMyaGV4YCwgYGJhc2UzMmhleG5vcGFkYCwgYGJhc2UzMmNyb2NrZm9yZGAuXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGJhc2UzMm5vcGFkLmVuY29kZShVaW50OEFycmF5LmZyb20oWzB4MTIsIDB4YWJdKSk7XG4gKiAvLyA9PiAnQ0tWUSdcbiAqIGJhc2UzMm5vcGFkLmRlY29kZSgnQ0tWUScpO1xuICogLy8gPT4gVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSlcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgYmFzZTMybm9wYWQgPSBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2NycpLCBqb2luKCcnKSk7XG4vKipcbiAqIGJhc2UzMiBlbmNvZGluZyBmcm9tIFJGQyA0NjQ4LiBQYWRkZWQuIENvbXBhcmVkIHRvIG9yZGluYXJ5IGBiYXNlMzJgLCBzbGlnaHRseSBkaWZmZXJlbnQgYWxwaGFiZXQuXG4gKiBVc2UgYGJhc2UzMmhleG5vcGFkYCBmb3IgdW5wYWRkZWQgdmVyc2lvbi5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogYmFzZTMyaGV4LmVuY29kZShVaW50OEFycmF5LmZyb20oWzB4MTIsIDB4YWJdKSk7XG4gKiAvLyA9PiAnMkFMRz09PT0nXG4gKiBiYXNlMzJoZXguZGVjb2RlKCcyQUxHPT09PScpO1xuICogLy8gPT4gVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSlcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgYmFzZTMyaGV4ID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVYnKSwgcGFkZGluZyg1KSwgam9pbignJykpO1xuLyoqXG4gKiBiYXNlMzIgZW5jb2RpbmcgZnJvbSBSRkMgNDY0OC4gTm8gcGFkZGluZy4gQ29tcGFyZWQgdG8gb3JkaW5hcnkgYGJhc2UzMmAsIHNsaWdodGx5IGRpZmZlcmVudCBhbHBoYWJldC5cbiAqIFVzZSBgYmFzZTMyaGV4YCBmb3IgcGFkZGVkIHZlcnNpb24uXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGJhc2UzMmhleG5vcGFkLmVuY29kZShVaW50OEFycmF5LmZyb20oWzB4MTIsIDB4YWJdKSk7XG4gKiAvLyA9PiAnMkFMRydcbiAqIGJhc2UzMmhleG5vcGFkLmRlY29kZSgnMkFMRycpO1xuICogLy8gPT4gVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSlcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgYmFzZTMyaGV4bm9wYWQgPSBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVicpLCBqb2luKCcnKSk7XG4vKipcbiAqIGJhc2UzMiBlbmNvZGluZyBmcm9tIFJGQyA0NjQ4LiBEb3VnIENyb2NrZm9yZCdzIHZlcnNpb24uXG4gKiBodHRwczovL3d3dy5jcm9ja2ZvcmQuY29tL2Jhc2UzMi5odG1sXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGJhc2UzMmNyb2NrZm9yZC5lbmNvZGUoVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSkpO1xuICogLy8gPT4gJzJBTkcnXG4gKiBiYXNlMzJjcm9ja2ZvcmQuZGVjb2RlKCcyQU5HJyk7XG4gKiAvLyA9PiBVaW50OEFycmF5LmZyb20oWzB4MTIsIDB4YWJdKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBiYXNlMzJjcm9ja2ZvcmQgPSBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGR0hKS01OUFFSU1RWV1hZWicpLCBqb2luKCcnKSwgbm9ybWFsaXplKChzKSA9PiBzLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvTy9nLCAnMCcpLnJlcGxhY2UoL1tJTF0vZywgJzEnKSkpO1xuLy8gQnVpbHQtaW4gYmFzZTY0IGNvbnZlcnNpb24gaHR0cHM6Ly9jYW5pdXNlLmNvbS9tZG4tamF2YXNjcmlwdF9idWlsdGluc191aW50OGFycmF5X2Zyb21iYXNlNjRcbi8vIFRPRE86IHRlbXBvcmFyaWx5IHNldCB0byBmYWxzZSwgdHJ5aW5nIHRvIHVuZGVyc3RhbmQgYnVnc1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBoYXNCYXNlNjRCdWlsdGluID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB0eXBlb2YgVWludDhBcnJheS5mcm9tKFtdKS50b0Jhc2U2NCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBVaW50OEFycmF5LmZyb21CYXNlNjQgPT09ICdmdW5jdGlvbicpKCk7XG4vKipcbiAqIGJhc2U2NCBmcm9tIFJGQyA0NjQ4LiBQYWRkZWQuXG4gKiBVc2UgYGJhc2U2NG5vcGFkYCBmb3IgdW5wYWRkZWQgdmVyc2lvbi5cbiAqIEFsc28gY2hlY2sgb3V0IGBiYXNlNjR1cmxgLCBgYmFzZTY0dXJsbm9wYWRgLlxuICogRmFsbHMgYmFjayB0byBidWlsdC1pbiBmdW5jdGlvbiwgd2hlbiBhdmFpbGFibGUuXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGJhc2U2NC5lbmNvZGUoVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSkpO1xuICogLy8gPT4gJ0Vxcz0nXG4gKiBiYXNlNjQuZGVjb2RlKCdFcXM9Jyk7XG4gKiAvLyA9PiBVaW50OEFycmF5LmZyb20oWzB4MTIsIDB4YWJdKVxuICogYGBgXG4gKi9cbi8vIHByZXR0aWVyLWlnbm9yZVxuZXhwb3J0IGNvbnN0IGJhc2U2NCA9IGhhc0Jhc2U2NEJ1aWx0aW4gPyB7XG4gICAgZW5jb2RlKGIpIHsgYWJ5dGVzKGIpOyByZXR1cm4gYi50b0Jhc2U2NCgpOyB9LFxuICAgIGRlY29kZShzKSB7XG4gICAgICAgIGFzdHIoJ2Jhc2U2NCcsIHMpO1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tQmFzZTY0KHMsIHsgbGFzdENodW5rSGFuZGxpbmc6ICdzdHJpY3QnIH0pO1xuICAgIH0sXG59IDogY2hhaW4ocmFkaXgyKDYpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycpLCBwYWRkaW5nKDYpLCBqb2luKCcnKSk7XG4vKipcbiAqIGJhc2U2NCBmcm9tIFJGQyA0NjQ4LiBObyBwYWRkaW5nLlxuICogVXNlIGBiYXNlNjRgIGZvciBwYWRkZWQgdmVyc2lvbi5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogYmFzZTY0bm9wYWQuZW5jb2RlKFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pKTtcbiAqIC8vID0+ICdFcXMnXG4gKiBiYXNlNjRub3BhZC5kZWNvZGUoJ0VxcycpO1xuICogLy8gPT4gVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSlcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgYmFzZTY0bm9wYWQgPSBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJyksIGpvaW4oJycpKTtcbi8qKlxuICogYmFzZTY0IGZyb20gUkZDIDQ2NDgsIHVzaW5nIFVSTC1zYWZlIGFscGhhYmV0LiBQYWRkZWQuXG4gKiBVc2UgYGJhc2U2NHVybG5vcGFkYCBmb3IgdW5wYWRkZWQgdmVyc2lvbi5cbiAqIEZhbGxzIGJhY2sgdG8gYnVpbHQtaW4gZnVuY3Rpb24sIHdoZW4gYXZhaWxhYmxlLlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBiYXNlNjR1cmwuZW5jb2RlKFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pKTtcbiAqIC8vID0+ICdFcXM9J1xuICogYmFzZTY0dXJsLmRlY29kZSgnRXFzPScpO1xuICogLy8gPT4gVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSlcbiAqIGBgYFxuICovXG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCBjb25zdCBiYXNlNjR1cmwgPSBoYXNCYXNlNjRCdWlsdGluID8ge1xuICAgIGVuY29kZShiKSB7IGFieXRlcyhiKTsgcmV0dXJuIGIudG9CYXNlNjQoeyBhbHBoYWJldDogJ2Jhc2U2NHVybCcgfSk7IH0sXG4gICAgZGVjb2RlKHMpIHsgYXN0cignYmFzZTY0Jywgcyk7IHJldHVybiBVaW50OEFycmF5LmZyb21CYXNlNjQocywgeyBhbHBoYWJldDogJ2Jhc2U2NHVybCcgfSk7IH0sXG59IDogY2hhaW4ocmFkaXgyKDYpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXycpLCBwYWRkaW5nKDYpLCBqb2luKCcnKSk7XG4vKipcbiAqIGJhc2U2NCBmcm9tIFJGQyA0NjQ4LCB1c2luZyBVUkwtc2FmZSBhbHBoYWJldC4gTm8gcGFkZGluZy5cbiAqIFVzZSBgYmFzZTY0dXJsYCBmb3IgcGFkZGVkIHZlcnNpb24uXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGJhc2U2NHVybG5vcGFkLmVuY29kZShVaW50OEFycmF5LmZyb20oWzB4MTIsIDB4YWJdKSk7XG4gKiAvLyA9PiAnRXFzJ1xuICogYmFzZTY0dXJsbm9wYWQuZGVjb2RlKCdFcXMnKTtcbiAqIC8vID0+IFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2U2NHVybG5vcGFkID0gY2hhaW4ocmFkaXgyKDYpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXycpLCBqb2luKCcnKSk7XG4vLyBiYXNlNTggY29kZVxuLy8gLS0tLS0tLS0tLS1cbmNvbnN0IGdlbkJhc2U1OCA9IC8qIEBfX05PX1NJREVfRUZGRUNUU19fICovIChhYmMpID0+IGNoYWluKHJhZGl4KDU4KSwgYWxwaGFiZXQoYWJjKSwgam9pbignJykpO1xuLyoqXG4gKiBiYXNlNTg6IGJhc2U2NCB3aXRob3V0IGFtYmlnb3VzIGNoYXJhY3RlcnMgKywgLywgMCwgTywgSSwgbC5cbiAqIFF1YWRyYXRpYyAoTyhuXjIpKSAtIHNvLCBjYW4ndCBiZSB1c2VkIG9uIGxhcmdlIGlucHV0cy5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogYmFzZTU4LmRlY29kZSgnMDFhYmNkZWYnKTtcbiAqIC8vID0+ICczVWhKVydcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgYmFzZTU4ID0gZ2VuQmFzZTU4KCcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6Jyk7XG4vKipcbiAqIGJhc2U1ODogZmxpY2tyIHZlcnNpb24uIENoZWNrIG91dCBgYmFzZTU4YC5cbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2U1OGZsaWNrciA9IGdlbkJhc2U1OCgnMTIzNDU2Nzg5YWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5ekFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWicpO1xuLyoqXG4gKiBiYXNlNTg6IFhSUCB2ZXJzaW9uLiBDaGVjayBvdXQgYGJhc2U1OGAuXG4gKi9cbmV4cG9ydCBjb25zdCBiYXNlNTh4cnAgPSBnZW5CYXNlNTgoJ3Jwc2huYWYzOXdCVURORUdISktMTTRQUVJTVDdWV1hZWjJiY2RlQ2c2NWprbThvRnFpMXR1dkF4eXonKTtcbi8vIERhdGEgbGVuIChpbmRleCkgLT4gZW5jb2RlZCBibG9jayBsZW5cbmNvbnN0IFhNUl9CTE9DS19MRU4gPSBbMCwgMiwgMywgNSwgNiwgNywgOSwgMTAsIDExXTtcbi8qKlxuICogYmFzZTU4OiBYTVIgdmVyc2lvbi4gQ2hlY2sgb3V0IGBiYXNlNThgLlxuICogRG9uZSBpbiA4LWJ5dGUgYmxvY2tzICh3aGljaCBlcXVhbHMgMTEgY2hhcnMgaW4gZGVjb2RpbmcpLiBMYXN0IChub24tZnVsbCkgYmxvY2sgcGFkZGVkIHdpdGggJzEnIHRvIHNpemUgaW4gWE1SX0JMT0NLX0xFTi5cbiAqIEJsb2NrIGVuY29kaW5nIHNpZ25pZmljYW50bHkgcmVkdWNlcyBxdWFkcmF0aWMgY29tcGxleGl0eSBvZiBiYXNlNTguXG4gKi9cbmV4cG9ydCBjb25zdCBiYXNlNTh4bXIgPSB7XG4gICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgbGV0IHJlcyA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gZGF0YS5zdWJhcnJheShpLCBpICsgOCk7XG4gICAgICAgICAgICByZXMgKz0gYmFzZTU4LmVuY29kZShibG9jaykucGFkU3RhcnQoWE1SX0JMT0NLX0xFTltibG9jay5sZW5ndGhdLCAnMScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBkZWNvZGUoc3RyKSB7XG4gICAgICAgIGxldCByZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDExKSB7XG4gICAgICAgICAgICBjb25zdCBzbGljZSA9IHN0ci5zbGljZShpLCBpICsgMTEpO1xuICAgICAgICAgICAgY29uc3QgYmxvY2tMZW4gPSBYTVJfQkxPQ0tfTEVOLmluZGV4T2Yoc2xpY2UubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gYmFzZTU4LmRlY29kZShzbGljZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJsb2NrLmxlbmd0aCAtIGJsb2NrTGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tbal0gIT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFzZTU4eG1yOiB3cm9uZyBwYWRkaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMgPSByZXMuY29uY2F0KEFycmF5LmZyb20oYmxvY2suc2xpY2UoYmxvY2subGVuZ3RoIC0gYmxvY2tMZW4pKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShyZXMpO1xuICAgIH0sXG59O1xuLyoqXG4gKiBNZXRob2QsIHdoaWNoIGNyZWF0ZXMgYmFzZTU4Y2hlY2sgZW5jb2Rlci5cbiAqIFJlcXVpcmVzIGZ1bmN0aW9uLCBjYWxjdWxhdGluZyBzaGEyNTYuXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVCYXNlNThjaGVjayA9IChzaGEyNTYpID0+IGNoYWluKGNoZWNrc3VtKDQsIChkYXRhKSA9PiBzaGEyNTYoc2hhMjU2KGRhdGEpKSksIGJhc2U1OCk7XG4vKipcbiAqIFVzZSBgY3JlYXRlQmFzZTU4Y2hlY2tgIGluc3RlYWQuXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnQgY29uc3QgYmFzZTU4Y2hlY2sgPSBjcmVhdGVCYXNlNThjaGVjaztcbmNvbnN0IEJFQ0hfQUxQSEFCRVQgPSBjaGFpbihhbHBoYWJldCgncXB6cnk5eDhnZjJ0dmR3MHMzam41NGtoY2U2bXVhN2wnKSwgam9pbignJykpO1xuY29uc3QgUE9MWU1PRF9HRU5FUkFUT1JTID0gWzB4M2I2YTU3YjIsIDB4MjY1MDhlNmQsIDB4MWVhMTE5ZmEsIDB4M2Q0MjMzZGQsIDB4MmExNDYyYjNdO1xuZnVuY3Rpb24gYmVjaDMyUG9seW1vZChwcmUpIHtcbiAgICBjb25zdCBiID0gcHJlID4+IDI1O1xuICAgIGxldCBjaGsgPSAocHJlICYgMHgxZmZmZmZmKSA8PCA1O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgUE9MWU1PRF9HRU5FUkFUT1JTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgoKGIgPj4gaSkgJiAxKSA9PT0gMSlcbiAgICAgICAgICAgIGNoayBePSBQT0xZTU9EX0dFTkVSQVRPUlNbaV07XG4gICAgfVxuICAgIHJldHVybiBjaGs7XG59XG5mdW5jdGlvbiBiZWNoQ2hlY2tzdW0ocHJlZml4LCB3b3JkcywgZW5jb2RpbmdDb25zdCA9IDEpIHtcbiAgICBjb25zdCBsZW4gPSBwcmVmaXgubGVuZ3RoO1xuICAgIGxldCBjaGsgPSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IHByZWZpeC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDMzIHx8IGMgPiAxMjYpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHJlZml4ICgke3ByZWZpeH0pYCk7XG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIChjID4+IDUpO1xuICAgIH1cbiAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoayk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspIF4gKHByZWZpeC5jaGFyQ29kZUF0KGkpICYgMHgxZik7XG4gICAgZm9yIChsZXQgdiBvZiB3b3JkcylcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspIF4gdjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKylcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspO1xuICAgIGNoayBePSBlbmNvZGluZ0NvbnN0O1xuICAgIHJldHVybiBCRUNIX0FMUEhBQkVULmVuY29kZShjb252ZXJ0UmFkaXgyKFtjaGsgJSBwb3dlcnNbMzBdXSwgMzAsIDUsIGZhbHNlKSk7XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGdlbkJlY2gzMihlbmNvZGluZykge1xuICAgIGNvbnN0IEVOQ09ESU5HX0NPTlNUID0gZW5jb2RpbmcgPT09ICdiZWNoMzInID8gMSA6IDB4MmJjODMwYTM7XG4gICAgY29uc3QgX3dvcmRzID0gcmFkaXgyKDUpO1xuICAgIGNvbnN0IGZyb21Xb3JkcyA9IF93b3Jkcy5kZWNvZGU7XG4gICAgY29uc3QgdG9Xb3JkcyA9IF93b3Jkcy5lbmNvZGU7XG4gICAgY29uc3QgZnJvbVdvcmRzVW5zYWZlID0gdW5zYWZlV3JhcHBlcihmcm9tV29yZHMpO1xuICAgIGZ1bmN0aW9uIGVuY29kZShwcmVmaXgsIHdvcmRzLCBsaW1pdCA9IDkwKSB7XG4gICAgICAgIGFzdHIoJ2JlY2gzMi5lbmNvZGUgcHJlZml4JywgcHJlZml4KTtcbiAgICAgICAgaWYgKGlzQnl0ZXMod29yZHMpKVxuICAgICAgICAgICAgd29yZHMgPSBBcnJheS5mcm9tKHdvcmRzKTtcbiAgICAgICAgYW51bUFycignYmVjaDMyLmVuY29kZScsIHdvcmRzKTtcbiAgICAgICAgY29uc3QgcGxlbiA9IHByZWZpeC5sZW5ndGg7XG4gICAgICAgIGlmIChwbGVuID09PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBwcmVmaXggbGVuZ3RoICR7cGxlbn1gKTtcbiAgICAgICAgY29uc3QgYWN0dWFsTGVuZ3RoID0gcGxlbiArIDcgKyB3b3Jkcy5sZW5ndGg7XG4gICAgICAgIGlmIChsaW1pdCAhPT0gZmFsc2UgJiYgYWN0dWFsTGVuZ3RoID4gbGltaXQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBMZW5ndGggJHthY3R1YWxMZW5ndGh9IGV4Y2VlZHMgbGltaXQgJHtsaW1pdH1gKTtcbiAgICAgICAgY29uc3QgbG93ZXJlZCA9IHByZWZpeC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBzdW0gPSBiZWNoQ2hlY2tzdW0obG93ZXJlZCwgd29yZHMsIEVOQ09ESU5HX0NPTlNUKTtcbiAgICAgICAgcmV0dXJuIGAke2xvd2VyZWR9MSR7QkVDSF9BTFBIQUJFVC5lbmNvZGUod29yZHMpfSR7c3VtfWA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZShzdHIsIGxpbWl0ID0gOTApIHtcbiAgICAgICAgYXN0cignYmVjaDMyLmRlY29kZSBpbnB1dCcsIHN0cik7XG4gICAgICAgIGNvbnN0IHNsZW4gPSBzdHIubGVuZ3RoO1xuICAgICAgICBpZiAoc2xlbiA8IDggfHwgKGxpbWl0ICE9PSBmYWxzZSAmJiBzbGVuID4gbGltaXQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBzdHJpbmcgbGVuZ3RoOiAke3NsZW59ICgke3N0cn0pLiBFeHBlY3RlZCAoOC4uJHtsaW1pdH0pYCk7XG4gICAgICAgIC8vIGRvbid0IGFsbG93IG1peGVkIGNhc2VcbiAgICAgICAgY29uc3QgbG93ZXJlZCA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoc3RyICE9PSBsb3dlcmVkICYmIHN0ciAhPT0gc3RyLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0cmluZyBtdXN0IGJlIGxvd2VyY2FzZSBvciB1cHBlcmNhc2VgKTtcbiAgICAgICAgY29uc3Qgc2VwSW5kZXggPSBsb3dlcmVkLmxhc3RJbmRleE9mKCcxJyk7XG4gICAgICAgIGlmIChzZXBJbmRleCA9PT0gMCB8fCBzZXBJbmRleCA9PT0gLTEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExldHRlciBcIjFcIiBtdXN0IGJlIHByZXNlbnQgYmV0d2VlbiBwcmVmaXggYW5kIGRhdGEgb25seWApO1xuICAgICAgICBjb25zdCBwcmVmaXggPSBsb3dlcmVkLnNsaWNlKDAsIHNlcEluZGV4KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGxvd2VyZWQuc2xpY2Uoc2VwSW5kZXggKyAxKTtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgNilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBtdXN0IGJlIGF0IGxlYXN0IDYgY2hhcmFjdGVycyBsb25nJyk7XG4gICAgICAgIGNvbnN0IHdvcmRzID0gQkVDSF9BTFBIQUJFVC5kZWNvZGUoZGF0YSkuc2xpY2UoMCwgLTYpO1xuICAgICAgICBjb25zdCBzdW0gPSBiZWNoQ2hlY2tzdW0ocHJlZml4LCB3b3JkcywgRU5DT0RJTkdfQ09OU1QpO1xuICAgICAgICBpZiAoIWRhdGEuZW5kc1dpdGgoc3VtKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjaGVja3N1bSBpbiAke3N0cn06IGV4cGVjdGVkIFwiJHtzdW19XCJgKTtcbiAgICAgICAgcmV0dXJuIHsgcHJlZml4LCB3b3JkcyB9O1xuICAgIH1cbiAgICBjb25zdCBkZWNvZGVVbnNhZmUgPSB1bnNhZmVXcmFwcGVyKGRlY29kZSk7XG4gICAgZnVuY3Rpb24gZGVjb2RlVG9CeXRlcyhzdHIpIHtcbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIHdvcmRzIH0gPSBkZWNvZGUoc3RyLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgd29yZHMsIGJ5dGVzOiBmcm9tV29yZHMod29yZHMpIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY29kZUZyb21CeXRlcyhwcmVmaXgsIGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGUocHJlZml4LCB0b1dvcmRzKGJ5dGVzKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZSxcbiAgICAgICAgZGVjb2RlLFxuICAgICAgICBlbmNvZGVGcm9tQnl0ZXMsXG4gICAgICAgIGRlY29kZVRvQnl0ZXMsXG4gICAgICAgIGRlY29kZVVuc2FmZSxcbiAgICAgICAgZnJvbVdvcmRzLFxuICAgICAgICBmcm9tV29yZHNVbnNhZmUsXG4gICAgICAgIHRvV29yZHMsXG4gICAgfTtcbn1cbi8qKlxuICogYmVjaDMyIGZyb20gQklQIDE3My4gT3BlcmF0ZXMgb24gd29yZHMuXG4gKiBGb3IgaGlnaC1sZXZlbCwgY2hlY2sgb3V0IHNjdXJlLWJ0Yy1zaWduZXI6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL3NjdXJlLWJ0Yy1zaWduZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBiZWNoMzIgPSBnZW5CZWNoMzIoJ2JlY2gzMicpO1xuLyoqXG4gKiBiZWNoMzJtIGZyb20gQklQIDM1MC4gT3BlcmF0ZXMgb24gd29yZHMuXG4gKiBJdCB3YXMgdG8gbWl0aWdhdGUgYGJlY2gzMmAgd2Vha25lc3Nlcy5cbiAqIEZvciBoaWdoLWxldmVsLCBjaGVjayBvdXQgc2N1cmUtYnRjLXNpZ25lcjpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvc2N1cmUtYnRjLXNpZ25lci5cbiAqL1xuZXhwb3J0IGNvbnN0IGJlY2gzMm0gPSBnZW5CZWNoMzIoJ2JlY2gzMm0nKTtcbi8qKlxuICogVVRGLTgtdG8tYnl0ZSBkZWNvZGVyLiBVc2VzIGJ1aWx0LWluIFRleHREZWNvZGVyIC8gVGV4dEVuY29kZXIuXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGNvbnN0IGIgPSB1dGY4LmRlY29kZShcImhleVwiKTsgLy8gPT4gbmV3IFVpbnQ4QXJyYXkoWyAxMDQsIDEwMSwgMTIxIF0pXG4gKiBjb25zdCBzdHIgPSB1dGY4LmVuY29kZShiKTsgLy8gXCJoZXlcIlxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCB1dGY4ID0ge1xuICAgIGVuY29kZTogKGRhdGEpID0+IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShkYXRhKSxcbiAgICBkZWNvZGU6IChzdHIpID0+IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpLFxufTtcbi8vIEJ1aWx0LWluIGhleCBjb252ZXJzaW9uIGh0dHBzOi8vY2FuaXVzZS5jb20vbWRuLWphdmFzY3JpcHRfYnVpbHRpbnNfdWludDhhcnJheV9mcm9taGV4XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IGhhc0hleEJ1aWx0aW4gPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHR5cGVvZiBVaW50OEFycmF5LmZyb20oW10pLnRvSGV4ID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIFVpbnQ4QXJyYXkuZnJvbUhleCA9PT0gJ2Z1bmN0aW9uJykoKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgaGV4QnVpbHRpbiA9IHtcbiAgICBlbmNvZGUoZGF0YSkgeyBhYnl0ZXMoZGF0YSk7IHJldHVybiBkYXRhLnRvSGV4KCk7IH0sXG4gICAgZGVjb2RlKHMpIHsgYXN0cignaGV4Jywgcyk7IHJldHVybiBVaW50OEFycmF5LmZyb21IZXgocyk7IH0sXG59O1xuLyoqXG4gKiBoZXggc3RyaW5nIGRlY29kZXIuIFVzZXMgYnVpbHQtaW4gZnVuY3Rpb24sIHdoZW4gYXZhaWxhYmxlLlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBjb25zdCBiID0gaGV4LmRlY29kZShcIjAxMDJmZlwiKTsgLy8gPT4gbmV3IFVpbnQ4QXJyYXkoWyAxLCAyLCAyNTUgXSlcbiAqIGNvbnN0IHN0ciA9IGhleC5lbmNvZGUoYik7IC8vIFwiMDEwMmZmXCJcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgaGV4ID0gaGFzSGV4QnVpbHRpblxuICAgID8gaGV4QnVpbHRpblxuICAgIDogY2hhaW4ocmFkaXgyKDQpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OWFiY2RlZicpLCBqb2luKCcnKSwgbm9ybWFsaXplKChzKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgcyAhPT0gJ3N0cmluZycgfHwgcy5sZW5ndGggJSAyICE9PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaGV4LmRlY29kZTogZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc30gd2l0aCBsZW5ndGggJHtzLmxlbmd0aH1gKTtcbiAgICAgICAgcmV0dXJuIHMudG9Mb3dlckNhc2UoKTtcbiAgICB9KSk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IENPREVSUyA9IHtcbiAgICB1dGY4LCBoZXgsIGJhc2UxNiwgYmFzZTMyLCBiYXNlNjQsIGJhc2U2NHVybCwgYmFzZTU4LCBiYXNlNTh4bXJcbn07XG5jb25zdCBjb2RlclR5cGVFcnJvciA9ICdJbnZhbGlkIGVuY29kaW5nIHR5cGUuIEF2YWlsYWJsZSB0eXBlczogdXRmOCwgaGV4LCBiYXNlMTYsIGJhc2UzMiwgYmFzZTY0LCBiYXNlNjR1cmwsIGJhc2U1OCwgYmFzZTU4eG1yJztcbi8qKiBAZGVwcmVjYXRlZCAqL1xuZXhwb3J0IGNvbnN0IGJ5dGVzVG9TdHJpbmcgPSAodHlwZSwgYnl0ZXMpID0+IHtcbiAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnIHx8ICFDT0RFUlMuaGFzT3duUHJvcGVydHkodHlwZSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY29kZXJUeXBlRXJyb3IpO1xuICAgIGlmICghaXNCeXRlcyhieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J5dGVzVG9TdHJpbmcoKSBleHBlY3RzIFVpbnQ4QXJyYXknKTtcbiAgICByZXR1cm4gQ09ERVJTW3R5cGVdLmVuY29kZShieXRlcyk7XG59O1xuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnQgY29uc3Qgc3RyID0gYnl0ZXNUb1N0cmluZzsgLy8gYXMgaW4gcHl0aG9uLCBidXQgZm9yIGJ5dGVzIG9ubHlcbi8qKiBAZGVwcmVjYXRlZCAqL1xuZXhwb3J0IGNvbnN0IHN0cmluZ1RvQnl0ZXMgPSAodHlwZSwgc3RyKSA9PiB7XG4gICAgaWYgKCFDT0RFUlMuaGFzT3duUHJvcGVydHkodHlwZSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY29kZXJUeXBlRXJyb3IpO1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc3RyaW5nVG9CeXRlcygpIGV4cGVjdHMgc3RyaW5nJyk7XG4gICAgcmV0dXJuIENPREVSU1t0eXBlXS5kZWNvZGUoc3RyKTtcbn07XG4vKiogQGRlcHJlY2F0ZWQgKi9cbmV4cG9ydCBjb25zdCBieXRlcyA9IHN0cmluZ1RvQnl0ZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiaXNCeXRlcyIsImEiLCJVaW50OEFycmF5IiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJhYnl0ZXMiLCJiIiwibGVuZ3RocyIsIkVycm9yIiwibGVuZ3RoIiwiaW5jbHVkZXMiLCJpc0FycmF5T2YiLCJpc1N0cmluZyIsImFyciIsIkFycmF5IiwiaXNBcnJheSIsImV2ZXJ5IiwiaXRlbSIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJhZm4iLCJpbnB1dCIsImFzdHIiLCJsYWJlbCIsImFudW1iZXIiLCJuIiwiYUFyciIsImFzdHJBcnIiLCJhbnVtQXJyIiwiY2hhaW4iLCJhcmdzIiwiaWQiLCJ3cmFwIiwiYyIsImVuY29kZSIsIm1hcCIsIngiLCJyZWR1Y2VSaWdodCIsImRlY29kZSIsInJlZHVjZSIsImFscGhhYmV0IiwibGV0dGVycyIsImxldHRlcnNBIiwic3BsaXQiLCJsZW4iLCJpbmRleGVzIiwiTWFwIiwibCIsImkiLCJkaWdpdHMiLCJsZXR0ZXIiLCJnZXQiLCJ1bmRlZmluZWQiLCJqb2luIiwic2VwYXJhdG9yIiwiZnJvbSIsInRvIiwicGFkZGluZyIsImJpdHMiLCJjaHIiLCJkYXRhIiwicHVzaCIsImVuZCIsImxhc3QiLCJieXRlIiwic2xpY2UiLCJub3JtYWxpemUiLCJmbiIsImNvbnZlcnRSYWRpeCIsInBvcyIsInJlcyIsImQiLCJkbGVuIiwiY2FycnkiLCJkb25lIiwiZGlnaXQiLCJmcm9tQ2FycnkiLCJkaWdpdEJhc2UiLCJkaXYiLCJyb3VuZGVkIiwiTWF0aCIsImZsb29yIiwicmV2ZXJzZSIsImdjZCIsInJhZGl4MmNhcnJ5IiwicG93ZXJzIiwiY29udmVydFJhZGl4MiIsIm1heCIsIm1hc2siLCJwb3ciLCJyYWRpeCIsIm51bSIsIl8yNTYiLCJieXRlcyIsInJhZGl4MiIsInJldlBhZGRpbmciLCJ1bnNhZmVXcmFwcGVyIiwiYXBwbHkiLCJlIiwiY2hlY2tzdW0iLCJzdW0iLCJzZXQiLCJwYXlsb2FkIiwib2xkQ2hlY2tzdW0iLCJuZXdDaGVja3N1bSIsInV0aWxzIiwiYmFzZTE2IiwiYmFzZTMyIiwiYmFzZTMybm9wYWQiLCJiYXNlMzJoZXgiLCJiYXNlMzJoZXhub3BhZCIsImJhc2UzMmNyb2NrZm9yZCIsInMiLCJ0b1VwcGVyQ2FzZSIsInJlcGxhY2UiLCJoYXNCYXNlNjRCdWlsdGluIiwidG9CYXNlNjQiLCJmcm9tQmFzZTY0IiwiYmFzZTY0IiwibGFzdENodW5rSGFuZGxpbmciLCJiYXNlNjRub3BhZCIsImJhc2U2NHVybCIsImJhc2U2NHVybG5vcGFkIiwiZ2VuQmFzZTU4IiwiYWJjIiwiYmFzZTU4IiwiYmFzZTU4ZmxpY2tyIiwiYmFzZTU4eHJwIiwiWE1SX0JMT0NLX0xFTiIsImJhc2U1OHhtciIsImJsb2NrIiwic3ViYXJyYXkiLCJwYWRTdGFydCIsInN0ciIsImJsb2NrTGVuIiwiaW5kZXhPZiIsImoiLCJjb25jYXQiLCJjcmVhdGVCYXNlNThjaGVjayIsInNoYTI1NiIsImJhc2U1OGNoZWNrIiwiQkVDSF9BTFBIQUJFVCIsIlBPTFlNT0RfR0VORVJBVE9SUyIsImJlY2gzMlBvbHltb2QiLCJwcmUiLCJjaGsiLCJiZWNoQ2hlY2tzdW0iLCJwcmVmaXgiLCJ3b3JkcyIsImVuY29kaW5nQ29uc3QiLCJjaGFyQ29kZUF0IiwidiIsImdlbkJlY2gzMiIsImVuY29kaW5nIiwiRU5DT0RJTkdfQ09OU1QiLCJfd29yZHMiLCJmcm9tV29yZHMiLCJ0b1dvcmRzIiwiZnJvbVdvcmRzVW5zYWZlIiwibGltaXQiLCJwbGVuIiwiVHlwZUVycm9yIiwiYWN0dWFsTGVuZ3RoIiwibG93ZXJlZCIsInRvTG93ZXJDYXNlIiwic2xlbiIsInNlcEluZGV4IiwibGFzdEluZGV4T2YiLCJlbmRzV2l0aCIsImRlY29kZVVuc2FmZSIsImRlY29kZVRvQnl0ZXMiLCJlbmNvZGVGcm9tQnl0ZXMiLCJiZWNoMzIiLCJiZWNoMzJtIiwidXRmOCIsIlRleHREZWNvZGVyIiwiVGV4dEVuY29kZXIiLCJoYXNIZXhCdWlsdGluIiwidG9IZXgiLCJmcm9tSGV4IiwiaGV4QnVpbHRpbiIsImhleCIsIkNPREVSUyIsImNvZGVyVHlwZUVycm9yIiwiYnl0ZXNUb1N0cmluZyIsInR5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsInN0cmluZ1RvQnl0ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/base/lib/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@scure/bip39/esm/index.js":
/*!************************************************!*\
  !*** ./node_modules/@scure/bip39/esm/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   entropyToMnemonic: () => (/* binding */ entropyToMnemonic),\n/* harmony export */   generateMnemonic: () => (/* binding */ generateMnemonic),\n/* harmony export */   mnemonicToEntropy: () => (/* binding */ mnemonicToEntropy),\n/* harmony export */   mnemonicToSeed: () => (/* binding */ mnemonicToSeed),\n/* harmony export */   mnemonicToSeedSync: () => (/* binding */ mnemonicToSeedSync),\n/* harmony export */   validateMnemonic: () => (/* binding */ validateMnemonic)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/pbkdf2 */ \"(ssr)/./node_modules/@noble/hashes/esm/pbkdf2.js\");\n/* harmony import */ var _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/sha2 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha2.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@scure/base/lib/esm/index.js\");\n/**\n * Audited & minimal JS implementation of\n * [BIP39 mnemonic phrases](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki).\n * @module\n * @example\n```js\nimport * as bip39 from '@scure/bip39';\nimport { wordlist } from '@scure/bip39/wordlists/english';\nconst mn = bip39.generateMnemonic(wordlist);\nconsole.log(mn);\nconst ent = bip39.mnemonicToEntropy(mn, wordlist)\nbip39.entropyToMnemonic(ent, wordlist);\nbip39.validateMnemonic(mn, wordlist);\nawait bip39.mnemonicToSeed(mn, 'password');\nbip39.mnemonicToSeedSync(mn, 'password');\n\n// Wordlists\nimport { wordlist as czech } from '@scure/bip39/wordlists/czech';\nimport { wordlist as english } from '@scure/bip39/wordlists/english';\nimport { wordlist as french } from '@scure/bip39/wordlists/french';\nimport { wordlist as italian } from '@scure/bip39/wordlists/italian';\nimport { wordlist as japanese } from '@scure/bip39/wordlists/japanese';\nimport { wordlist as korean } from '@scure/bip39/wordlists/korean';\nimport { wordlist as portuguese } from '@scure/bip39/wordlists/portuguese';\nimport { wordlist as simplifiedChinese } from '@scure/bip39/wordlists/simplified-chinese';\nimport { wordlist as spanish } from '@scure/bip39/wordlists/spanish';\nimport { wordlist as traditionalChinese } from '@scure/bip39/wordlists/traditional-chinese';\n```\n */ /*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */ \n\n\n\n// Japanese wordlist\nconst isJapanese = (wordlist)=>wordlist[0] === \"あいこくしん\";\n// Normalization replaces equivalent sequences of characters\n// so that any two texts that are equivalent will be reduced\n// to the same sequence of code points, called the normal form of the original text.\n// https://tonsky.me/blog/unicode/#why-is-a----\nfunction nfkd(str) {\n    if (typeof str !== \"string\") throw new TypeError(\"invalid mnemonic type: \" + typeof str);\n    return str.normalize(\"NFKD\");\n}\nfunction normalize(str) {\n    const norm = nfkd(str);\n    const words = norm.split(\" \");\n    if (![\n        12,\n        15,\n        18,\n        21,\n        24\n    ].includes(words.length)) throw new Error(\"Invalid mnemonic\");\n    return {\n        nfkd: norm,\n        words\n    };\n}\nfunction aentropy(ent) {\n    (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.abytes)(ent, 16, 20, 24, 28, 32);\n}\n/**\n * Generate x random words. Uses Cryptographically-Secure Random Number Generator.\n * @param wordlist imported wordlist for specific language\n * @param strength mnemonic strength 128-256 bits\n * @example\n * generateMnemonic(wordlist, 128)\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */ function generateMnemonic(wordlist, strength = 128) {\n    (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.anumber)(strength);\n    if (strength % 32 !== 0 || strength > 256) throw new TypeError(\"Invalid entropy\");\n    return entropyToMnemonic((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.randomBytes)(strength / 8), wordlist);\n}\nconst calcChecksum = (entropy)=>{\n    // Checksum is ent.length/4 bits long\n    const bitsLeft = 8 - entropy.length / 4;\n    // Zero rightmost \"bitsLeft\" bits in byte\n    // For example: bitsLeft=4 val=10111101 -> 10110000\n    return new Uint8Array([\n        (0,_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_1__.sha256)(entropy)[0] >> bitsLeft << bitsLeft\n    ]);\n};\nfunction getCoder(wordlist) {\n    if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== \"string\") throw new Error(\"Wordlist: expected array of 2048 strings\");\n    wordlist.forEach((i)=>{\n        if (typeof i !== \"string\") throw new Error(\"wordlist: non-string element: \" + i);\n    });\n    return _scure_base__WEBPACK_IMPORTED_MODULE_2__.utils.chain(_scure_base__WEBPACK_IMPORTED_MODULE_2__.utils.checksum(1, calcChecksum), _scure_base__WEBPACK_IMPORTED_MODULE_2__.utils.radix2(11, true), _scure_base__WEBPACK_IMPORTED_MODULE_2__.utils.alphabet(wordlist));\n}\n/**\n * Reversible: Converts mnemonic string to raw entropy in form of byte array.\n * @param mnemonic 12-24 words\n * @param wordlist imported wordlist for specific language\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToEntropy(mnem, wordlist)\n * // Produces\n * new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ])\n */ function mnemonicToEntropy(mnemonic, wordlist) {\n    const { words } = normalize(mnemonic);\n    const entropy = getCoder(wordlist).decode(words);\n    aentropy(entropy);\n    return entropy;\n}\n/**\n * Reversible: Converts raw entropy in form of byte array to mnemonic string.\n * @param entropy byte array\n * @param wordlist imported wordlist for specific language\n * @returns 12-24 words\n * @example\n * const ent = new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ]);\n * entropyToMnemonic(ent, wordlist);\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */ function entropyToMnemonic(entropy, wordlist) {\n    aentropy(entropy);\n    const words = getCoder(wordlist).encode(entropy);\n    return words.join(isJapanese(wordlist) ? \"　\" : \" \");\n}\n/**\n * Validates mnemonic for being 12-24 words contained in `wordlist`.\n */ function validateMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}\nconst psalt = (passphrase)=>nfkd(\"mnemonic\" + passphrase);\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * await mnemonicToSeed(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */ function mnemonicToSeed(mnemonic, passphrase = \"\") {\n    return (0,_noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_3__.pbkdf2Async)(_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_1__.sha512, normalize(mnemonic).nfkd, psalt(passphrase), {\n        c: 2048,\n        dkLen: 64\n    });\n}\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToSeedSync(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */ function mnemonicToSeedSync(mnemonic, passphrase = \"\") {\n    return (0,_noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_3__.pbkdf2)(_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_1__.sha512, normalize(mnemonic).nfkd, psalt(passphrase), {\n        c: 2048,\n        dkLen: 64\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E0QkMsR0FDRCx1RkFBdUYsR0FDNUI7QUFDUDtBQUNlO0FBQ2xCO0FBQ2pELG9CQUFvQjtBQUNwQixNQUFNUyxhQUFhLENBQUNDLFdBQWFBLFFBQVEsQ0FBQyxFQUFFLEtBQUs7QUFDakQsNERBQTREO0FBQzVELDREQUE0RDtBQUM1RCxvRkFBb0Y7QUFDcEYsK0NBQStDO0FBQy9DLFNBQVNDLEtBQUtDLEdBQUc7SUFDYixJQUFJLE9BQU9BLFFBQVEsVUFDZixNQUFNLElBQUlDLFVBQVUsNEJBQTRCLE9BQU9EO0lBQzNELE9BQU9BLElBQUlFLFNBQVMsQ0FBQztBQUN6QjtBQUNBLFNBQVNBLFVBQVVGLEdBQUc7SUFDbEIsTUFBTUcsT0FBT0osS0FBS0M7SUFDbEIsTUFBTUksUUFBUUQsS0FBS0UsS0FBSyxDQUFDO0lBQ3pCLElBQUksQ0FBQztRQUFDO1FBQUk7UUFBSTtRQUFJO1FBQUk7S0FBRyxDQUFDQyxRQUFRLENBQUNGLE1BQU1HLE1BQU0sR0FDM0MsTUFBTSxJQUFJQyxNQUFNO0lBQ3BCLE9BQU87UUFBRVQsTUFBTUk7UUFBTUM7SUFBTTtBQUMvQjtBQUNBLFNBQVNLLFNBQVNDLEdBQUc7SUFDakJsQiwyREFBTUEsQ0FBQ2tCLEtBQUssSUFBSSxJQUFJLElBQUksSUFBSTtBQUNoQztBQUNBOzs7Ozs7O0NBT0MsR0FDTSxTQUFTQyxpQkFBaUJiLFFBQVEsRUFBRWMsV0FBVyxHQUFHO0lBQ3JEbkIsNERBQU9BLENBQUNtQjtJQUNSLElBQUlBLFdBQVcsT0FBTyxLQUFLQSxXQUFXLEtBQ2xDLE1BQU0sSUFBSVgsVUFBVTtJQUN4QixPQUFPWSxrQkFBa0JuQixnRUFBV0EsQ0FBQ2tCLFdBQVcsSUFBSWQ7QUFDeEQ7QUFDQSxNQUFNZ0IsZUFBZSxDQUFDQztJQUNsQixxQ0FBcUM7SUFDckMsTUFBTUMsV0FBVyxJQUFJRCxRQUFRUixNQUFNLEdBQUc7SUFDdEMseUNBQXlDO0lBQ3pDLG1EQUFtRDtJQUNuRCxPQUFPLElBQUlVLFdBQVc7UUFBRTNCLDBEQUFNQSxDQUFDeUIsUUFBUSxDQUFDLEVBQUUsSUFBSUMsWUFBYUE7S0FBUztBQUN4RTtBQUNBLFNBQVNFLFNBQVNwQixRQUFRO0lBQ3RCLElBQUksQ0FBQ3FCLE1BQU1DLE9BQU8sQ0FBQ3RCLGFBQWFBLFNBQVNTLE1BQU0sS0FBSyxRQUFRLE9BQU9ULFFBQVEsQ0FBQyxFQUFFLEtBQUssVUFDL0UsTUFBTSxJQUFJVSxNQUFNO0lBQ3BCVixTQUFTdUIsT0FBTyxDQUFDLENBQUNDO1FBQ2QsSUFBSSxPQUFPQSxNQUFNLFVBQ2IsTUFBTSxJQUFJZCxNQUFNLG1DQUFtQ2M7SUFDM0Q7SUFDQSxPQUFPMUIsOENBQVNBLENBQUMyQixLQUFLLENBQUMzQiw4Q0FBU0EsQ0FBQzRCLFFBQVEsQ0FBQyxHQUFHVixlQUFlbEIsOENBQVNBLENBQUM2QixNQUFNLENBQUMsSUFBSSxPQUFPN0IsOENBQVNBLENBQUM4QixRQUFRLENBQUM1QjtBQUMvRztBQUNBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNNLFNBQVM2QixrQkFBa0JDLFFBQVEsRUFBRTlCLFFBQVE7SUFDaEQsTUFBTSxFQUFFTSxLQUFLLEVBQUUsR0FBR0YsVUFBVTBCO0lBQzVCLE1BQU1iLFVBQVVHLFNBQVNwQixVQUFVK0IsTUFBTSxDQUFDekI7SUFDMUNLLFNBQVNNO0lBQ1QsT0FBT0E7QUFDWDtBQUNBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNNLFNBQVNGLGtCQUFrQkUsT0FBTyxFQUFFakIsUUFBUTtJQUMvQ1csU0FBU007SUFDVCxNQUFNWCxRQUFRYyxTQUFTcEIsVUFBVWdDLE1BQU0sQ0FBQ2Y7SUFDeEMsT0FBT1gsTUFBTTJCLElBQUksQ0FBQ2xDLFdBQVdDLFlBQVksTUFBVztBQUN4RDtBQUNBOztDQUVDLEdBQ00sU0FBU2tDLGlCQUFpQkosUUFBUSxFQUFFOUIsUUFBUTtJQUMvQyxJQUFJO1FBQ0E2QixrQkFBa0JDLFVBQVU5QjtJQUNoQyxFQUNBLE9BQU9tQyxHQUFHO1FBQ04sT0FBTztJQUNYO0lBQ0EsT0FBTztBQUNYO0FBQ0EsTUFBTUMsUUFBUSxDQUFDQyxhQUFlcEMsS0FBSyxhQUFhb0M7QUFDaEQ7Ozs7Ozs7OztDQVNDLEdBQ00sU0FBU0MsZUFBZVIsUUFBUSxFQUFFTyxhQUFhLEVBQUU7SUFDcEQsT0FBTzlDLGlFQUFXQSxDQUFDRSxzREFBTUEsRUFBRVcsVUFBVTBCLFVBQVU3QixJQUFJLEVBQUVtQyxNQUFNQyxhQUFhO1FBQUVFLEdBQUc7UUFBTUMsT0FBTztJQUFHO0FBQ2pHO0FBQ0E7Ozs7Ozs7OztDQVNDLEdBQ00sU0FBU0MsbUJBQW1CWCxRQUFRLEVBQUVPLGFBQWEsRUFBRTtJQUN4RCxPQUFPL0MsNERBQU1BLENBQUNHLHNEQUFNQSxFQUFFVyxVQUFVMEIsVUFBVTdCLElBQUksRUFBRW1DLE1BQU1DLGFBQWE7UUFBRUUsR0FBRztRQUFNQyxPQUFPO0lBQUc7QUFDNUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qYW1paWZ1bmQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L2VzbS9pbmRleC5qcz81MmEzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQXVkaXRlZCAmIG1pbmltYWwgSlMgaW1wbGVtZW50YXRpb24gb2ZcbiAqIFtCSVAzOSBtbmVtb25pYyBwaHJhc2VzXShodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMDM5Lm1lZGlhd2lraSkuXG4gKiBAbW9kdWxlXG4gKiBAZXhhbXBsZVxuYGBganNcbmltcG9ydCAqIGFzIGJpcDM5IGZyb20gJ0BzY3VyZS9iaXAzOSc7XG5pbXBvcnQgeyB3b3JkbGlzdCB9IGZyb20gJ0BzY3VyZS9iaXAzOS93b3JkbGlzdHMvZW5nbGlzaCc7XG5jb25zdCBtbiA9IGJpcDM5LmdlbmVyYXRlTW5lbW9uaWMod29yZGxpc3QpO1xuY29uc29sZS5sb2cobW4pO1xuY29uc3QgZW50ID0gYmlwMzkubW5lbW9uaWNUb0VudHJvcHkobW4sIHdvcmRsaXN0KVxuYmlwMzkuZW50cm9weVRvTW5lbW9uaWMoZW50LCB3b3JkbGlzdCk7XG5iaXAzOS52YWxpZGF0ZU1uZW1vbmljKG1uLCB3b3JkbGlzdCk7XG5hd2FpdCBiaXAzOS5tbmVtb25pY1RvU2VlZChtbiwgJ3Bhc3N3b3JkJyk7XG5iaXAzOS5tbmVtb25pY1RvU2VlZFN5bmMobW4sICdwYXNzd29yZCcpO1xuXG4vLyBXb3JkbGlzdHNcbmltcG9ydCB7IHdvcmRsaXN0IGFzIGN6ZWNoIH0gZnJvbSAnQHNjdXJlL2JpcDM5L3dvcmRsaXN0cy9jemVjaCc7XG5pbXBvcnQgeyB3b3JkbGlzdCBhcyBlbmdsaXNoIH0gZnJvbSAnQHNjdXJlL2JpcDM5L3dvcmRsaXN0cy9lbmdsaXNoJztcbmltcG9ydCB7IHdvcmRsaXN0IGFzIGZyZW5jaCB9IGZyb20gJ0BzY3VyZS9iaXAzOS93b3JkbGlzdHMvZnJlbmNoJztcbmltcG9ydCB7IHdvcmRsaXN0IGFzIGl0YWxpYW4gfSBmcm9tICdAc2N1cmUvYmlwMzkvd29yZGxpc3RzL2l0YWxpYW4nO1xuaW1wb3J0IHsgd29yZGxpc3QgYXMgamFwYW5lc2UgfSBmcm9tICdAc2N1cmUvYmlwMzkvd29yZGxpc3RzL2phcGFuZXNlJztcbmltcG9ydCB7IHdvcmRsaXN0IGFzIGtvcmVhbiB9IGZyb20gJ0BzY3VyZS9iaXAzOS93b3JkbGlzdHMva29yZWFuJztcbmltcG9ydCB7IHdvcmRsaXN0IGFzIHBvcnR1Z3Vlc2UgfSBmcm9tICdAc2N1cmUvYmlwMzkvd29yZGxpc3RzL3BvcnR1Z3Vlc2UnO1xuaW1wb3J0IHsgd29yZGxpc3QgYXMgc2ltcGxpZmllZENoaW5lc2UgfSBmcm9tICdAc2N1cmUvYmlwMzkvd29yZGxpc3RzL3NpbXBsaWZpZWQtY2hpbmVzZSc7XG5pbXBvcnQgeyB3b3JkbGlzdCBhcyBzcGFuaXNoIH0gZnJvbSAnQHNjdXJlL2JpcDM5L3dvcmRsaXN0cy9zcGFuaXNoJztcbmltcG9ydCB7IHdvcmRsaXN0IGFzIHRyYWRpdGlvbmFsQ2hpbmVzZSB9IGZyb20gJ0BzY3VyZS9iaXAzOS93b3JkbGlzdHMvdHJhZGl0aW9uYWwtY2hpbmVzZSc7XG5gYGBcbiAqL1xuLyohIHNjdXJlLWJpcDM5IC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF0cmljaW8gUGFsbGFkaW5vLCBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IHBia2RmMiwgcGJrZGYyQXN5bmMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3Bia2RmMic7XG5pbXBvcnQgeyBzaGEyNTYsIHNoYTUxMiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMic7XG5pbXBvcnQgeyBhYnl0ZXMsIGFudW1iZXIsIHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyB1dGlscyBhcyBiYXNlVXRpbHMgfSBmcm9tICdAc2N1cmUvYmFzZSc7XG4vLyBKYXBhbmVzZSB3b3JkbGlzdFxuY29uc3QgaXNKYXBhbmVzZSA9ICh3b3JkbGlzdCkgPT4gd29yZGxpc3RbMF0gPT09ICdcXHUzMDQyXFx1MzA0NFxcdTMwNTNcXHUzMDRmXFx1MzA1N1xcdTMwOTMnO1xuLy8gTm9ybWFsaXphdGlvbiByZXBsYWNlcyBlcXVpdmFsZW50IHNlcXVlbmNlcyBvZiBjaGFyYWN0ZXJzXG4vLyBzbyB0aGF0IGFueSB0d28gdGV4dHMgdGhhdCBhcmUgZXF1aXZhbGVudCB3aWxsIGJlIHJlZHVjZWRcbi8vIHRvIHRoZSBzYW1lIHNlcXVlbmNlIG9mIGNvZGUgcG9pbnRzLCBjYWxsZWQgdGhlIG5vcm1hbCBmb3JtIG9mIHRoZSBvcmlnaW5hbCB0ZXh0LlxuLy8gaHR0cHM6Ly90b25za3kubWUvYmxvZy91bmljb2RlLyN3aHktaXMtYS0tLS1cbmZ1bmN0aW9uIG5ma2Qoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIG1uZW1vbmljIHR5cGU6ICcgKyB0eXBlb2Ygc3RyKTtcbiAgICByZXR1cm4gc3RyLm5vcm1hbGl6ZSgnTkZLRCcpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplKHN0cikge1xuICAgIGNvbnN0IG5vcm0gPSBuZmtkKHN0cik7XG4gICAgY29uc3Qgd29yZHMgPSBub3JtLnNwbGl0KCcgJyk7XG4gICAgaWYgKCFbMTIsIDE1LCAxOCwgMjEsIDI0XS5pbmNsdWRlcyh3b3Jkcy5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbW5lbW9uaWMnKTtcbiAgICByZXR1cm4geyBuZmtkOiBub3JtLCB3b3JkcyB9O1xufVxuZnVuY3Rpb24gYWVudHJvcHkoZW50KSB7XG4gICAgYWJ5dGVzKGVudCwgMTYsIDIwLCAyNCwgMjgsIDMyKTtcbn1cbi8qKlxuICogR2VuZXJhdGUgeCByYW5kb20gd29yZHMuIFVzZXMgQ3J5cHRvZ3JhcGhpY2FsbHktU2VjdXJlIFJhbmRvbSBOdW1iZXIgR2VuZXJhdG9yLlxuICogQHBhcmFtIHdvcmRsaXN0IGltcG9ydGVkIHdvcmRsaXN0IGZvciBzcGVjaWZpYyBsYW5ndWFnZVxuICogQHBhcmFtIHN0cmVuZ3RoIG1uZW1vbmljIHN0cmVuZ3RoIDEyOC0yNTYgYml0c1xuICogQGV4YW1wbGVcbiAqIGdlbmVyYXRlTW5lbW9uaWMod29yZGxpc3QsIDEyOClcbiAqIC8vICdsZWdhbCB3aW5uZXIgdGhhbmsgeWVhciB3YXZlIHNhdXNhZ2Ugd29ydGggdXNlZnVsIGxlZ2FsIHdpbm5lciB0aGFuayB5ZWxsb3cnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZU1uZW1vbmljKHdvcmRsaXN0LCBzdHJlbmd0aCA9IDEyOCkge1xuICAgIGFudW1iZXIoc3RyZW5ndGgpO1xuICAgIGlmIChzdHJlbmd0aCAlIDMyICE9PSAwIHx8IHN0cmVuZ3RoID4gMjU2KVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGVudHJvcHknKTtcbiAgICByZXR1cm4gZW50cm9weVRvTW5lbW9uaWMocmFuZG9tQnl0ZXMoc3RyZW5ndGggLyA4KSwgd29yZGxpc3QpO1xufVxuY29uc3QgY2FsY0NoZWNrc3VtID0gKGVudHJvcHkpID0+IHtcbiAgICAvLyBDaGVja3N1bSBpcyBlbnQubGVuZ3RoLzQgYml0cyBsb25nXG4gICAgY29uc3QgYml0c0xlZnQgPSA4IC0gZW50cm9weS5sZW5ndGggLyA0O1xuICAgIC8vIFplcm8gcmlnaHRtb3N0IFwiYml0c0xlZnRcIiBiaXRzIGluIGJ5dGVcbiAgICAvLyBGb3IgZXhhbXBsZTogYml0c0xlZnQ9NCB2YWw9MTAxMTExMDEgLT4gMTAxMTAwMDBcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWyhzaGEyNTYoZW50cm9weSlbMF0gPj4gYml0c0xlZnQpIDw8IGJpdHNMZWZ0XSk7XG59O1xuZnVuY3Rpb24gZ2V0Q29kZXIod29yZGxpc3QpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkod29yZGxpc3QpIHx8IHdvcmRsaXN0Lmxlbmd0aCAhPT0gMjA0OCB8fCB0eXBlb2Ygd29yZGxpc3RbMF0gIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmRsaXN0OiBleHBlY3RlZCBhcnJheSBvZiAyMDQ4IHN0cmluZ3MnKTtcbiAgICB3b3JkbGlzdC5mb3JFYWNoKChpKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dvcmRsaXN0OiBub24tc3RyaW5nIGVsZW1lbnQ6ICcgKyBpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYmFzZVV0aWxzLmNoYWluKGJhc2VVdGlscy5jaGVja3N1bSgxLCBjYWxjQ2hlY2tzdW0pLCBiYXNlVXRpbHMucmFkaXgyKDExLCB0cnVlKSwgYmFzZVV0aWxzLmFscGhhYmV0KHdvcmRsaXN0KSk7XG59XG4vKipcbiAqIFJldmVyc2libGU6IENvbnZlcnRzIG1uZW1vbmljIHN0cmluZyB0byByYXcgZW50cm9weSBpbiBmb3JtIG9mIGJ5dGUgYXJyYXkuXG4gKiBAcGFyYW0gbW5lbW9uaWMgMTItMjQgd29yZHNcbiAqIEBwYXJhbSB3b3JkbGlzdCBpbXBvcnRlZCB3b3JkbGlzdCBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBtbmVtID0gJ2xlZ2FsIHdpbm5lciB0aGFuayB5ZWFyIHdhdmUgc2F1c2FnZSB3b3J0aCB1c2VmdWwgbGVnYWwgd2lubmVyIHRoYW5rIHllbGxvdyc7XG4gKiBtbmVtb25pY1RvRW50cm9weShtbmVtLCB3b3JkbGlzdClcbiAqIC8vIFByb2R1Y2VzXG4gKiBuZXcgVWludDhBcnJheShbXG4gKiAgIDB4N2YsIDB4N2YsIDB4N2YsIDB4N2YsIDB4N2YsIDB4N2YsIDB4N2YsIDB4N2YsXG4gKiAgIDB4N2YsIDB4N2YsIDB4N2YsIDB4N2YsIDB4N2YsIDB4N2YsIDB4N2YsIDB4N2ZcbiAqIF0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtbmVtb25pY1RvRW50cm9weShtbmVtb25pYywgd29yZGxpc3QpIHtcbiAgICBjb25zdCB7IHdvcmRzIH0gPSBub3JtYWxpemUobW5lbW9uaWMpO1xuICAgIGNvbnN0IGVudHJvcHkgPSBnZXRDb2Rlcih3b3JkbGlzdCkuZGVjb2RlKHdvcmRzKTtcbiAgICBhZW50cm9weShlbnRyb3B5KTtcbiAgICByZXR1cm4gZW50cm9weTtcbn1cbi8qKlxuICogUmV2ZXJzaWJsZTogQ29udmVydHMgcmF3IGVudHJvcHkgaW4gZm9ybSBvZiBieXRlIGFycmF5IHRvIG1uZW1vbmljIHN0cmluZy5cbiAqIEBwYXJhbSBlbnRyb3B5IGJ5dGUgYXJyYXlcbiAqIEBwYXJhbSB3b3JkbGlzdCBpbXBvcnRlZCB3b3JkbGlzdCBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIEByZXR1cm5zIDEyLTI0IHdvcmRzXG4gKiBAZXhhbXBsZVxuICogY29uc3QgZW50ID0gbmV3IFVpbnQ4QXJyYXkoW1xuICogICAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLFxuICogICAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmXG4gKiBdKTtcbiAqIGVudHJvcHlUb01uZW1vbmljKGVudCwgd29yZGxpc3QpO1xuICogLy8gJ2xlZ2FsIHdpbm5lciB0aGFuayB5ZWFyIHdhdmUgc2F1c2FnZSB3b3J0aCB1c2VmdWwgbGVnYWwgd2lubmVyIHRoYW5rIHllbGxvdydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVudHJvcHlUb01uZW1vbmljKGVudHJvcHksIHdvcmRsaXN0KSB7XG4gICAgYWVudHJvcHkoZW50cm9weSk7XG4gICAgY29uc3Qgd29yZHMgPSBnZXRDb2Rlcih3b3JkbGlzdCkuZW5jb2RlKGVudHJvcHkpO1xuICAgIHJldHVybiB3b3Jkcy5qb2luKGlzSmFwYW5lc2Uod29yZGxpc3QpID8gJ1xcdTMwMDAnIDogJyAnKTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIG1uZW1vbmljIGZvciBiZWluZyAxMi0yNCB3b3JkcyBjb250YWluZWQgaW4gYHdvcmRsaXN0YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlTW5lbW9uaWMobW5lbW9uaWMsIHdvcmRsaXN0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbW5lbW9uaWNUb0VudHJvcHkobW5lbW9uaWMsIHdvcmRsaXN0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IHBzYWx0ID0gKHBhc3NwaHJhc2UpID0+IG5ma2QoJ21uZW1vbmljJyArIHBhc3NwaHJhc2UpO1xuLyoqXG4gKiBJcnJldmVyc2libGU6IFVzZXMgS0RGIHRvIGRlcml2ZSA2NCBieXRlcyBvZiBrZXkgZGF0YSBmcm9tIG1uZW1vbmljICsgb3B0aW9uYWwgcGFzc3dvcmQuXG4gKiBAcGFyYW0gbW5lbW9uaWMgMTItMjQgd29yZHNcbiAqIEBwYXJhbSBwYXNzcGhyYXNlIHN0cmluZyB0aGF0IHdpbGwgYWRkaXRpb25hbGx5IHByb3RlY3QgdGhlIGtleVxuICogQHJldHVybnMgNjQgYnl0ZXMgb2Yga2V5IGRhdGFcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBtbmVtID0gJ2xlZ2FsIHdpbm5lciB0aGFuayB5ZWFyIHdhdmUgc2F1c2FnZSB3b3J0aCB1c2VmdWwgbGVnYWwgd2lubmVyIHRoYW5rIHllbGxvdyc7XG4gKiBhd2FpdCBtbmVtb25pY1RvU2VlZChtbmVtLCAncGFzc3dvcmQnKTtcbiAqIC8vIG5ldyBVaW50OEFycmF5KFsuLi42NCBieXRlc10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtbmVtb25pY1RvU2VlZChtbmVtb25pYywgcGFzc3BocmFzZSA9ICcnKSB7XG4gICAgcmV0dXJuIHBia2RmMkFzeW5jKHNoYTUxMiwgbm9ybWFsaXplKG1uZW1vbmljKS5uZmtkLCBwc2FsdChwYXNzcGhyYXNlKSwgeyBjOiAyMDQ4LCBka0xlbjogNjQgfSk7XG59XG4vKipcbiAqIElycmV2ZXJzaWJsZTogVXNlcyBLREYgdG8gZGVyaXZlIDY0IGJ5dGVzIG9mIGtleSBkYXRhIGZyb20gbW5lbW9uaWMgKyBvcHRpb25hbCBwYXNzd29yZC5cbiAqIEBwYXJhbSBtbmVtb25pYyAxMi0yNCB3b3Jkc1xuICogQHBhcmFtIHBhc3NwaHJhc2Ugc3RyaW5nIHRoYXQgd2lsbCBhZGRpdGlvbmFsbHkgcHJvdGVjdCB0aGUga2V5XG4gKiBAcmV0dXJucyA2NCBieXRlcyBvZiBrZXkgZGF0YVxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG1uZW0gPSAnbGVnYWwgd2lubmVyIHRoYW5rIHllYXIgd2F2ZSBzYXVzYWdlIHdvcnRoIHVzZWZ1bCBsZWdhbCB3aW5uZXIgdGhhbmsgeWVsbG93JztcbiAqIG1uZW1vbmljVG9TZWVkU3luYyhtbmVtLCAncGFzc3dvcmQnKTtcbiAqIC8vIG5ldyBVaW50OEFycmF5KFsuLi42NCBieXRlc10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtbmVtb25pY1RvU2VlZFN5bmMobW5lbW9uaWMsIHBhc3NwaHJhc2UgPSAnJykge1xuICAgIHJldHVybiBwYmtkZjIoc2hhNTEyLCBub3JtYWxpemUobW5lbW9uaWMpLm5ma2QsIHBzYWx0KHBhc3NwaHJhc2UpLCB7IGM6IDIwNDgsIGRrTGVuOiA2NCB9KTtcbn1cbiJdLCJuYW1lcyI6WyJwYmtkZjIiLCJwYmtkZjJBc3luYyIsInNoYTI1NiIsInNoYTUxMiIsImFieXRlcyIsImFudW1iZXIiLCJyYW5kb21CeXRlcyIsInV0aWxzIiwiYmFzZVV0aWxzIiwiaXNKYXBhbmVzZSIsIndvcmRsaXN0IiwibmZrZCIsInN0ciIsIlR5cGVFcnJvciIsIm5vcm1hbGl6ZSIsIm5vcm0iLCJ3b3JkcyIsInNwbGl0IiwiaW5jbHVkZXMiLCJsZW5ndGgiLCJFcnJvciIsImFlbnRyb3B5IiwiZW50IiwiZ2VuZXJhdGVNbmVtb25pYyIsInN0cmVuZ3RoIiwiZW50cm9weVRvTW5lbW9uaWMiLCJjYWxjQ2hlY2tzdW0iLCJlbnRyb3B5IiwiYml0c0xlZnQiLCJVaW50OEFycmF5IiwiZ2V0Q29kZXIiLCJBcnJheSIsImlzQXJyYXkiLCJmb3JFYWNoIiwiaSIsImNoYWluIiwiY2hlY2tzdW0iLCJyYWRpeDIiLCJhbHBoYWJldCIsIm1uZW1vbmljVG9FbnRyb3B5IiwibW5lbW9uaWMiLCJkZWNvZGUiLCJlbmNvZGUiLCJqb2luIiwidmFsaWRhdGVNbmVtb25pYyIsImUiLCJwc2FsdCIsInBhc3NwaHJhc2UiLCJtbmVtb25pY1RvU2VlZCIsImMiLCJka0xlbiIsIm1uZW1vbmljVG9TZWVkU3luYyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/bip39/esm/index.js\n");

/***/ })

};
;